From cc832d45e9d4ed6c1fd7f636653faf6e8aedcfdb Mon Sep 17 00:00:00 2001
From: Matus Kral <matuskral@me.com>
Date: Thu, 19 Nov 2015 08:03:05 +0100
Subject: [PATCH] Add back IMX rendering from v14.

---
 .../resource.language.en_gb/resources/strings.po   |   6 +-
 xbmc/Application.cpp                               |   9 +
 xbmc/cores/VideoRenderers/BaseRenderer.cpp         |   5 +
 xbmc/cores/VideoRenderers/BaseRenderer.h           |  22 +-
 xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp    | 234 ++++++++++++++++++---
 xbmc/cores/VideoRenderers/LinuxRendererGLES.h      |   4 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |   6 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp |  10 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h   |   8 +-
 xbmc/settings/DisplaySettings.cpp                  |   5 +
 xbmc/settings/Settings.cpp                         |   1 +
 11 files changed, 272 insertions(+), 38 deletions(-)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index c688f8b..e620008 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -6440,7 +6440,11 @@ msgctxt "#13423"
 msgid "Remember for this path"
 msgstr ""
 
-#empty string with id 13424
+#: system/settings/settings.xml
+#: xbmc/cores/VideoRenderers/BaseRenderer.cpp
+msgctxt "#13424"
+msgid "iMX6 v14 Renderer"
+msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#13425"
diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index eeef1e3..380ae77 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -220,6 +220,10 @@
 #include "utils/AMLUtils.h"
 #endif
 
+#ifdef HAS_IMXVPU
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h"
+#endif
+
 #include "cores/FFmpeg.h"
 #include "utils/CharsetConverter.h"
 #include "pictures/GUIWindowSlideShow.h"
@@ -1454,6 +1458,11 @@ void CApplication::OnSettingChanged(const CSetting *setting)
     m_replayGainSettings.iNoGainPreAmp = ((CSettingInt*)setting)->GetValue();
   else if (StringUtils::EqualsNoCase(settingId, CSettings::SETTING_MUSICPLAYER_REPLAYGAINAVOIDCLIPPING))
     m_replayGainSettings.bAvoidClipping = ((CSettingBool*)setting)->GetValue();
+
+#ifdef HAS_IMXVPU
+  if (settingId == CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD)
+    g_IMXContext.RendererAllowed(CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD) == RENDER_METHOD_AUTO);
+#endif
 }
 
 void CApplication::OnSettingAction(const CSetting *setting)
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.cpp b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
index 987714f..e11ecdf 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.cpp
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.cpp
@@ -795,6 +795,11 @@ void CBaseRenderer::SettingOptionsRenderMethodsFiller(const CSetting *setting, s
 {
   list.push_back(make_pair(g_localizeStrings.Get(13416), RENDER_METHOD_AUTO));
 
+#ifdef HAS_IMXVPU
+  list.push_back(make_pair(g_localizeStrings.Get(13424), RENDER_METHOD_IMXv14));
+  list.push_back(make_pair(g_localizeStrings.Get(13419), RENDER_METHOD_SOFTWARE));
+#endif
+
 #ifdef HAS_DX
   list.push_back(make_pair(g_localizeStrings.Get(16319), RENDER_METHOD_DXVA));
   list.push_back(make_pair(g_localizeStrings.Get(13431), RENDER_METHOD_D3D_PS));
diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index d6a7140..6c7befb 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -27,10 +27,15 @@
 #include "guilib/Geometry.h"
 #include "RenderFormats.h"
 #include "RenderFeatures.h"
-
+
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 6
+#ifdef HAS_IMXVPU
+   #define NUM_BUFFERS 10
+#else
+   #define NUM_BUFFERS 6
+#endif
+
 
 class CSetting;
 
@@ -64,6 +69,7 @@ enum RenderMethods
   RENDER_METHOD_SOFTWARE,
   RENDER_METHOD_D3D_PS,
   RENDER_METHOD_DXVA,
+  RENDER_METHOD_IMXv14,
   RENDER_OVERLAYS        = 99   // to retain compatibility
 };
 
@@ -80,12 +86,12 @@ public:
 
   void SetViewMode(int viewMode);
   RESOLUTION GetResolution() const;
-
-  /*! \brief Get video rectangle and view window
-  \param source is original size of the video
-  \param dest is the target rendering area honoring aspect ratio of source
-  \param view is the entire target rendering area for the video (including black bars)
-  */
+
+  /*! \brief Get video rectangle and view window
+  \param source is original size of the video
+  \param dest is the target rendering area honoring aspect ratio of source
+  \param view is the entire target rendering area for the video (including black bars)
+  */
   void GetVideoRect(CRect &source, CRect &dest, CRect &view);
   float GetAspectRatio() const;
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index 75c2dda..3b2d27d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -87,6 +87,13 @@ static PFNEGLCLIENTWAITSYNCKHRPROC eglClientWaitSyncKHR;
 #ifdef HAS_IMXVPU
 #include "windowing/egl/EGLWrapper.h"
 #include "DVDCodecs/Video/DVDVideoCodecIMX.h"
+
+#define GL_VIV_NV12 0x8FC1
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTVIVMAPPROC) (GLenum Target, GLsizei Width, GLsizei Height, GLenum Format, GLvoid ** Logical, const GLuint * Physical);
+typedef void (GL_APIENTRYP PFNGLTEXDIRECTINVALIDATEVIVPROC) (GLenum Target);
+static PFNGLTEXDIRECTVIVMAPPROC glTexDirectVIVMap;
+static PFNGLTEXDIRECTINVALIDATEVIVPROC glTexDirectInvalidateVIV;
+
 #endif
 
 #if defined(TARGET_ANDROID)
@@ -179,6 +186,15 @@ CLinuxRendererGLES::CLinuxRendererGLES()
     eglClientWaitSyncKHR = (PFNEGLCLIENTWAITSYNCKHRPROC) eglGetProcAddress("eglClientWaitSyncKHR");
   }
 #endif
+
+#ifdef HAS_IMXVPU
+  if (!glTexDirectVIVMap)
+    glTexDirectVIVMap = (PFNGLTEXDIRECTVIVMAPPROC) CEGLWrapper::GetProcAddress("glTexDirectVIVMap");
+  if (!glTexDirectInvalidateVIV)
+    glTexDirectInvalidateVIV = (PFNGLTEXDIRECTINVALIDATEVIVPROC) CEGLWrapper::GetProcAddress("glTexDirectInvalidateVIV");
+
+  g_IMXContext.RendererAllowed(CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD) == RENDER_METHOD_AUTO);
+#endif
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -357,6 +373,9 @@ void CLinuxRendererGLES::ReleaseImage(int source, bool preserve)
 
 void CLinuxRendererGLES::CalculateTextureSourceRects(int source, int num_planes)
 {
+  if (m_renderMethod == RENDER_IMXMAP)
+    return;
+
   YUVBUFFER& buf    =  m_buffers[source];
   YV12Image* im     = &buf.image;
   YUVFIELDS& fields =  buf.fields;
@@ -527,7 +546,7 @@ void CLinuxRendererGLES::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
   int index = m_iYV12RenderBuffer;
   YUVBUFFER& buf =  m_buffers[index];
 
-  if (m_format != RENDER_FMT_OMXEGL && m_format != RENDER_FMT_EGLIMG && m_format != RENDER_FMT_MEDIACODEC)
+  if (m_format != RENDER_FMT_OMXEGL && m_format != RENDER_FMT_EGLIMG && m_format != RENDER_FMT_MEDIACODEC && m_format != RENDER_FMT_IMXMAP)
   {
     if (!buf.fields[FIELD_FULL][0].id) return;
   }
@@ -921,6 +940,13 @@ void CLinuxRendererGLES::LoadShaders(int field)
           // drop through and try SW
         }
       }
+    case RENDER_METHOD_IMXv14:
+      if (m_format == RENDER_FMT_IMXMAP)
+      {
+        CLog::Log(LOGNOTICE, "GL: Using IMXv14 render method");
+        m_renderMethod = RENDER_IMXv14;
+        break;
+      }
     case RENDER_METHOD_SOFTWARE:
     default:
       {
@@ -947,7 +973,8 @@ void CLinuxRendererGLES::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGLES::CreateCVRefTexture;
     m_textureDelete = &CLinuxRendererGLES::DeleteCVRefTexture;
   }
-  else if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_MEDIACODECSURFACE)
+  else if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_MEDIACODECSURFACE ||
+          (m_format == RENDER_FMT_IMXMAP && m_renderMethod & RENDER_IMXMAP))
   {
     m_textureUpload = &CLinuxRendererGLES::UploadBYPASSTexture;
     m_textureCreate = &CLinuxRendererGLES::CreateBYPASSTexture;
@@ -1050,7 +1077,6 @@ void CLinuxRendererGLES::UnInit()
 
 inline void CLinuxRendererGLES::ReorderDrawPoints()
 {
-
   CBaseRenderer::ReorderDrawPoints();//call base impl. for rotating the points
 
   //corevideo and EGL are flipped in y
@@ -1092,7 +1118,7 @@ void CLinuxRendererGLES::ReleaseBuffer(int idx)
     SAFE_RELEASE(buf.mediacodec);
 #endif
 #ifdef HAS_IMXVPU
-  if (m_renderMethod & RENDER_IMXMAP)
+  if (m_renderMethod & (RENDER_IMXMAP | RENDER_IMXv14))
     SAFE_RELEASE(buf.IMXBuffer);
 #endif
 }
@@ -1100,7 +1126,7 @@ void CLinuxRendererGLES::ReleaseBuffer(int idx)
 void CLinuxRendererGLES::Render(DWORD flags, int index)
 {
   // If rendered directly by the hardware
-  if (m_renderMethod & RENDER_BYPASS || m_renderMethod & RENDER_MEDIACODECSURFACE)
+  if (m_renderMethod & RENDER_BYPASS || m_renderMethod & RENDER_MEDIACODECSURFACE || m_renderMethod & RENDER_IMXMAP)
     return;
 
   // obtain current field, if interlaced
@@ -1156,8 +1182,9 @@ void CLinuxRendererGLES::Render(DWORD flags, int index)
   {
     RenderSurfaceTexture(index, m_currentField);
   }
-  else if (m_renderMethod & RENDER_IMXMAP)
+  else if (m_renderMethod & RENDER_IMXv14)
   {
+    UpdateVideoFilter();
     RenderIMXMAPTexture(index, m_currentField);
     VerifyGLState();
   }
@@ -1875,6 +1902,102 @@ void CLinuxRendererGLES::RenderCoreVideoRef(int index, int field)
 
 void CLinuxRendererGLES::RenderIMXMAPTexture(int index, int field)
 {
+#ifdef HAS_IMXVPU
+  CDVDVideoCodecIMXBuffer *buffer = m_buffers[index].IMXBuffer;
+  if(!buffer || !buffer->IsValid())
+    return;
+
+#ifdef DEBUG_VERBOSE
+  unsigned int time = XbmcThreads::SystemClockMillis();
+#endif
+
+  YUVPLANE &plane  = m_buffers[index].fields[0][0];
+  YUVPLANE &planef = m_buffers[index].fields[field][0];
+
+  glDisable(GL_DEPTH_TEST);
+  glEnable(m_textureTarget);
+
+  glActiveTexture(GL_TEXTURE0);
+  glBindTexture(m_textureTarget, plane.id);
+
+  if (field != FIELD_FULL)
+  {
+    g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA_BOB);
+    GLint   fieldLoc = g_Windowing.GUIShaderGetField();
+    GLint   stepLoc = g_Windowing.GUIShaderGetStep();
+
+    if     (field == FIELD_TOP)
+      glUniform1i(fieldLoc, 1);
+    else if(field == FIELD_BOT)
+      glUniform1i(fieldLoc, 0);
+    glUniform1f(stepLoc, 1.0f / (float)plane.texheight);
+  }
+  else
+    g_Windowing.EnableGUIShader(SM_TEXTURE_RGBA);
+
+  GLint   contrastLoc = g_Windowing.GUIShaderGetContrast();
+  glUniform1f(contrastLoc, CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Contrast * 0.02f);
+  GLint   brightnessLoc = g_Windowing.GUIShaderGetBrightness();
+  glUniform1f(brightnessLoc, CMediaSettings::GetInstance().GetCurrentVideoSettings().m_Brightness * 0.01f - 0.5f);
+
+  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
+  GLfloat ver[4][4];
+  GLfloat tex[4][2];
+  GLfloat col[3] = {1.0f, 1.0f, 1.0f};
+
+  GLint   posLoc = g_Windowing.GUIShaderGetPos();
+  GLint   texLoc = g_Windowing.GUIShaderGetCoord0();
+  GLint   colLoc = g_Windowing.GUIShaderGetCol();
+
+  glVertexAttribPointer(posLoc, 4, GL_FLOAT, 0, 0, ver);
+  glVertexAttribPointer(texLoc, 2, GL_FLOAT, 0, 0, tex);
+  glVertexAttribPointer(colLoc, 3, GL_FLOAT, 0, 0, col);
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(texLoc);
+  glEnableVertexAttribArray(colLoc);
+
+  // Set vertex coordinates
+  for(int i = 0; i < 4; i++)
+  {
+    ver[i][0] = m_rotatedDestCoords[i].x;
+    ver[i][1] = m_rotatedDestCoords[i].y;
+    ver[i][2] = 0.0f;// set z to 0
+    ver[i][3] = 1.0f;
+  }
+
+  if (field == FIELD_FULL)
+  {
+    tex[0][0] = tex[3][0] = plane.rect.x1;
+    tex[0][1] = tex[1][1] = plane.rect.y1;
+    tex[1][0] = tex[2][0] = plane.rect.x2;
+    tex[2][1] = tex[3][1] = plane.rect.y2;
+  }
+  else
+  {
+    tex[0][0] = tex[3][0] = planef.rect.x1;
+    tex[0][1] = tex[1][1] = planef.rect.y1 * 2.0f;
+    tex[1][0] = tex[2][0] = planef.rect.x2;
+    tex[2][1] = tex[3][1] = planef.rect.y2 * 2.0f;
+  }
+
+  glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(texLoc);
+  glDisableVertexAttribArray(colLoc);
+
+  g_Windowing.DisableGUIShader();
+  glBindTexture(m_textureTarget, 0);
+
+  glDisable(m_textureTarget);
+  VerifyGLState();
+
+#ifdef DEBUG_VERBOSE
+  CLog::Log(LOGDEBUG, "RenderIMXMAPTexture %d: tm:%d\n", index, XbmcThreads::Sys
+#endif
+
+#endif
 }
 
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
@@ -2827,49 +2950,104 @@ void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 //********************************************************************************************************
 void CLinuxRendererGLES::UploadIMXMAPTexture(int index)
 {
+#ifdef HAS_IMXVPU
+  CDVDVideoCodecIMXBuffer* buffer = (CDVDVideoCodecIMXBuffer*)m_buffers[index].IMXBuffer;
+  if(!buffer || !buffer->IsValid())
+    return;
+
+    GLvoid*   virt  = (GLvoid*)buffer->pVirtAddr;
+    YUVPLANE &plane = m_buffers[index].fields[0][0];
+
+    if (!CDVDVideoCodecIMX::ptrToTexMap.count(virt))
+    {
+      GLuint physical = ~0U;
+      GLuint            tmpTexId;
+
+      CreateIMXMAPTexture(index, tmpTexId);
+      CDVDVideoCodecIMX::ptrToTexMap[virt] = tmpTexId;
+
+      glActiveTexture(GL_TEXTURE0);
+      glBindTexture(m_textureTarget, tmpTexId);
+      glTexDirectVIVMap(m_textureTarget, buffer->iWidth, buffer->iHeight, GL_VIV_NV12, (GLvoid **)&virt, &physical);
+    }
+    else
+    {
+      plane.id = CDVDVideoCodecIMX::ptrToTexMap.at(virt);
+
+      glActiveTexture(GL_TEXTURE0);
+      glBindTexture(m_textureTarget, plane.id);
+    }
+
+    glTexDirectInvalidateVIV(m_textureTarget);
+    glBindTexture(m_textureTarget, 0);
+
+    plane.flipindex = m_buffers[index].flipindex;
+    plane.texwidth  = buffer->iWidth;
+    plane.texheight = buffer->iHeight;
+
+    CalculateTextureSourceRects(index, 1);
+#endif
 }
 
 void CLinuxRendererGLES::DeleteIMXMAPTexture(int index)
 {
 #ifdef HAS_IMXVPU
-  YUVBUFFER &buf = m_buffers[index];
-  YUVPLANE &plane = buf.fields[0][0];
+  if (m_buffers[index].IMXBuffer)
+  {
+    CDVDVideoCodecIMXBuffer *buf = m_buffers[index].IMXBuffer;
+    GLvoid *virt                 = (GLvoid*)buf->pVirtAddr;
+    YUVPLANE &plane              = m_buffers[index].fields[0][0];
 
-  if(plane.id && glIsTexture(plane.id))
-    glDeleteTextures(1, &plane.id);
-  plane.id = 0;
+    if (CDVDVideoCodecIMX::ptrToTexMap.count(virt))
+    {
+      plane.id = CDVDVideoCodecIMX::ptrToTexMap.at(virt);
 
-  SAFE_RELEASE(buf.IMXBuffer);
+      if(plane.id && glIsTexture(plane.id))
+        glDeleteTextures(1, &plane.id);
+      plane.id = 0;
+
+      CDVDVideoCodecIMX::ptrToTexMap.erase(virt);
+    }
+  }
+  SAFE_RELEASE(m_buffers[index].IMXBuffer);
 #endif
 }
 
-bool CLinuxRendererGLES::CreateIMXMAPTexture(int index)
+bool CLinuxRendererGLES::CreateIMXMAPTexture(int index) { return true; }
+bool CLinuxRendererGLES::CreateIMXMAPTexture(int index, GLuint &tmpTexId)
 {
-  YV12Image &im     = m_buffers[index].image;
   YUVFIELDS &fields = m_buffers[index].fields;
-  YUVPLANE  &plane  = fields[0][0];
-
-  DeleteIMXMAPTexture(index);
 
-  memset(&im    , 0, sizeof(im));
   memset(&fields, 0, sizeof(fields));
 
-  im.height = m_sourceHeight;
-  im.width  = m_sourceWidth;
+  for (int f=0; f<3; ++f)
+  {
+    YUVPLANE  &plane  = fields[f][0];
+
+    plane.texwidth  = m_sourceWidth; //im.width; // Must be actual frame width for pseudocropping
+    plane.texheight = m_sourceHeight; //im.height; // Must be actual frame height for pseudocropping
+    plane.pixpertex_x = 1;
+    plane.pixpertex_y = 1;
+  }
 
-  plane.texwidth  = 0; // Must be actual frame width for pseudo-cropping
-  plane.texheight = 0; // Must be actual frame height for pseudo-cropping
+  YUVPLANE  &plane  = fields[0][0];
+
+  plane.texwidth  = 0; // Must be actual frame width for pseudocropping
+  plane.texheight = 0; // Must be actual frame height for pseudocropping
   plane.pixpertex_x = 1;
   plane.pixpertex_y = 1;
 
   glEnable(m_textureTarget);
   glGenTextures(1, &plane.id);
+  tmpTexId = plane.id;
   VerifyGLState();
 
   glBindTexture(m_textureTarget, plane.id);
 
   glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
   glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 
   glDisable(m_textureTarget);
   return true;
@@ -3047,6 +3225,9 @@ EINTERLACEMETHOD CLinuxRendererGLES::AutoInterlaceMethod()
   if(m_renderMethod & RENDER_EGLIMG)
     return VS_INTERLACEMETHOD_RENDER_BOB_INVERTED;
 
+  if(m_renderMethod & RENDER_IMXv14)
+    return VS_INTERLACEMETHOD_RENDER_BOB_INVERTED;
+
   if(m_renderMethod & RENDER_MEDIACODEC)
     return VS_INTERLACEMETHOD_RENDER_BOB_INVERTED;
 
@@ -3080,7 +3261,10 @@ CRenderInfo CLinuxRendererGLES::GetRenderInfo()
   else if(m_format == RENDER_FMT_IMXMAP)
   {
     // Let the codec control the buffer size
-    info.optimal_buffer_size = info.max_buffer_size;
+    if(CSettings::GetInstance().GetInt(CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD) == RENDER_METHOD_IMXv14)
+      info.optimal_buffer_size = info.max_buffer_size;
+    else
+      info.optimal_buffer_size = 6;
   }
   else
     info.optimal_buffer_size = 3;
@@ -3174,11 +3358,11 @@ void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecIMXBuffer *buffer, int index
 
 bool CLinuxRendererGLES::IsGuiLayer()
 {
-  if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_IMXMAP || m_format == RENDER_FMT_MEDIACODECSURFACE)
+  if (m_format == RENDER_FMT_BYPASS || (m_format == RENDER_FMT_IMXMAP && !(m_renderMethod & RENDER_IMXv14)) ||
+      m_format == RENDER_FMT_MEDIACODECSURFACE)
     return false;
   else
     return true;
 }
 
 #endif
-
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 77bbb57..5123234 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -94,7 +94,8 @@ enum RenderMethod
   RENDER_EGLIMG = 0x200,
   RENDER_MEDIACODEC = 0x400,
   RENDER_MEDIACODECSURFACE = 0x800,
-  RENDER_IMXMAP = 0x1000
+  RENDER_IMXMAP = 0x1000,
+  RENDER_IMXv14 = 0x2000
 };
 
 enum RenderQuality
@@ -225,6 +226,7 @@ protected:
   void UploadIMXMAPTexture(int index);
   void DeleteIMXMAPTexture(int index);
   bool CreateIMXMAPTexture(int index);
+  bool CreateIMXMAPTexture(int index, GLuint &tmpTexId);
 
   void CalculateTextureSourceRects(int source, int num_planes);
 
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 6fcb09c..9a9211b 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -208,7 +208,8 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
       m_format == RENDER_FMT_YUV420P16)
     m_defines += "#define XBMC_YV12\n";
   else if (m_format == RENDER_FMT_NV12 ||
-           m_format == RENDER_FMT_VAAPINV12)
+           m_format == RENDER_FMT_VAAPINV12 ||
+           m_format == RENDER_FMT_IMXMAP)
     m_defines += "#define XBMC_NV12\n";
   else if (m_format == RENDER_FMT_YUYV422)
     m_defines += "#define XBMC_YUY2\n";
@@ -230,7 +231,8 @@ BaseYUV2RGBGLSLShader::BaseYUV2RGBGLSLShader(bool rect, unsigned flags, ERenderF
   m_hAlpha  = -1;
   if (m_format == RENDER_FMT_YUV420P)
     m_defines += "#define XBMC_YV12\n";
-  else if (m_format == RENDER_FMT_NV12)
+  else if (m_format == RENDER_FMT_NV12 ||
+           m_format == RENDER_FMT_IMXMAP)
     m_defines += "#define XBMC_NV12\n";
   else
     CLog::Log(LOGERROR, "GL: BaseYUV2RGBGLSLShader - unsupported format %d", m_format);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index 7742fbe..40b7cf6 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -47,6 +47,7 @@
 
 // Global instance
 CIMXContext g_IMXContext;
+ptrToTexMap_t CDVDVideoCodecIMX::ptrToTexMap;
 
 // Number of fb pages used for paning
 const int CIMXContext::m_fbPages = 2;
@@ -2085,6 +2086,15 @@ bool CIMXContext::DoTask(IPUTask &ipu, int targetPage)
   return true;
 }
 
+void CIMXContext::RendererAllowed(bool yes)
+{
+  CLog::Log(LOGNOTICE, "iMX : changing to %s", yes ? "enabled" : "disabled");
+  if (yes)
+    TaskRestart();
+  else
+    StopThread(true);
+}
+
 void CIMXContext::OnStartup()
 {
   g_Windowing.Register(this);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index 559bea5..29208da 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -27,13 +27,14 @@
 #include "DVDVideoCodec.h"
 #include "DVDStreamInfo.h"
 #include "guilib/DispResource.h"
+#include "system_gl.h"
 
 #include <vector>
 #include <linux/ipu.h>
 #include <linux/mxcfb.h>
 #include <imx-mm/vpu/vpu_wrapper.h>
 #include <g2d.h>
-
+#include <map>
 
 // The decoding format of the VPU buffer. Comment this to decode
 // as NV12. The VPU works faster with NV12 in combination with
@@ -148,6 +149,8 @@ public:
 
   void OnResetDevice();
 
+  void RendererAllowed(bool yes);
+
 private:
   struct IPUTask
   {
@@ -227,6 +230,7 @@ private:
 extern CIMXContext g_IMXContext;
 /*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
 
+typedef std::map<GLvoid*, GLuint> ptrToTexMap_t;
 
 class CDecMemInfo
 {
@@ -314,6 +318,8 @@ public:
   virtual const char* GetName() { return (const char*)m_pFormatName; }
   virtual unsigned GetAllowedReferences();
 
+  static ptrToTexMap_t ptrToTexMap;
+
   static void Enter();
   static void Leave();
 
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 7993a73..8f91312 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -42,6 +42,11 @@
 #include "utils/Variant.h"
 #include "utils/XMLUtils.h"
 #include "windowing/WindowingFactory.h"
+#include "cores/VideoRenderers/BaseRenderer.h"
+
+#if defined(HAS_IMXVPU)
+#include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h"
+#endif
 
 using namespace KODI::MESSAGING;
 
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 3f67a20..73d9c7e 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -1050,6 +1050,7 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_VSYNC);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_MONITOR);
   settingSet.insert(CSettings::SETTING_VIDEOSCREEN_PREFEREDSTEREOSCOPICMODE);
+  settingSet.insert(CSettings::SETTING_VIDEOPLAYER_RENDERMETHOD);
   m_settingsManager->RegisterCallback(&CDisplaySettings::GetInstance(), settingSet);
   
   settingSet.clear();
-- 
2.1.0

