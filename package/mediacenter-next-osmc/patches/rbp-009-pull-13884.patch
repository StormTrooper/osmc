From ac82aed80e9d97e0a4cdfa9a71f138242c559ed6 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Sun, 13 May 2018 21:44:15 +0200
Subject: [PATCH 1/2] Remove AudioCodec::GetData(uint8_t**) from Interface

---
 .../VideoPlayer/DVDCodecs/Audio/DVDAudioCodec.h    |  6 ------
 .../Audio/DVDAudioCodecAndroidMediaCodec.h         |  4 ++--
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.h          |  2 +-
 .../DVDCodecs/Audio/DVDAudioCodecPassthrough.h     |  2 +-
 xbmc/cores/paplayer/VideoPlayerCodec.cpp           | 22 ++++++++++++----------
 xbmc/cores/paplayer/VideoPlayerCodec.h             |  2 +-
 6 files changed, 17 insertions(+), 21 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodec.h
index 9959e98dfb9f..354b16c38140 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodec.h
@@ -81,12 +81,6 @@ class CDVDAudioCodec
    */
   virtual bool AddData(const DemuxPacket &packet) = 0;
 
-  /*
-   * returns nr of bytes in decode buffer
-   * the data is valid until the next call
-   */
-  virtual int GetData(uint8_t** dst) = 0;
-
   /*
    * the data is valid until the next call
    */
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
index 2b05a44989da..3361889e6b81 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
@@ -52,12 +52,12 @@ class CDVDAudioCodecAndroidMediaCodec : public CDVDAudioCodec
   virtual void Dispose() override;
   virtual bool AddData(const DemuxPacket &packet) override;
   virtual void GetData(DVDAudioFrame &frame) override;
-  virtual int GetData(uint8_t** dst) override;
   virtual void Reset() override;
   virtual AEAudioFormat GetFormat() override { return m_format; }
   virtual const char* GetName() override { return "mediacodec"; }
-  
+
 protected:
+  int GetData(uint8_t** dst);
   int GetChannels() { return m_channels; }
   int GetEncodedChannels() { return m_channels; }
   CAEChannelInfo GetChannelMap();
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
index 51fb9f97a859..d3690b6f0cba 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.h
@@ -42,7 +42,6 @@ class CDVDAudioCodecFFmpeg : public CDVDAudioCodec
   void Dispose() override;
   bool AddData(const DemuxPacket &packet) override;
   void GetData(DVDAudioFrame &frame) override;
-  int GetData(uint8_t** dst) override;
   void Reset() override;
   AEAudioFormat GetFormat() override { return m_format; }
   const char* GetName() override { return "FFmpeg"; }
@@ -51,6 +50,7 @@ class CDVDAudioCodecFFmpeg : public CDVDAudioCodec
   int GetProfile() override;
 
 protected:
+  int GetData(uint8_t** dst);
   enum AEDataFormat GetDataFormat();
   int GetSampleRate();
   int GetChannels();
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h
index 8fdeed2f9c91..00b69b7710fb 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecPassthrough.h
@@ -40,7 +40,6 @@ class CDVDAudioCodecPassthrough : public CDVDAudioCodec
   void Dispose() override;
   bool AddData(const DemuxPacket &packet) override;
   void GetData(DVDAudioFrame &frame) override;
-  int GetData(uint8_t** dst) override;
   void Reset() override;
   AEAudioFormat GetFormat() override { return m_format; }
   bool NeedPassthrough() override { return true; }
@@ -48,6 +47,7 @@ class CDVDAudioCodecPassthrough : public CDVDAudioCodec
   int GetBufferSize() override;
 
 private:
+  int GetData(uint8_t** dst);
   CAEStreamParser m_parser;
   uint8_t* m_buffer = nullptr;
   unsigned int m_bufferSize = 0;
diff --git a/xbmc/cores/paplayer/VideoPlayerCodec.cpp b/xbmc/cores/paplayer/VideoPlayerCodec.cpp
index 59e82b564b1d..91c3350fa3b6 100644
--- a/xbmc/cores/paplayer/VideoPlayerCodec.cpp
+++ b/xbmc/cores/paplayer/VideoPlayerCodec.cpp
@@ -349,23 +349,24 @@ int VideoPlayerCodec::ReadPCM(unsigned char *pBuffer, int size, int *actualsize)
     {
       int samples = *actualsize / (m_bitsPerSample>>3);
       int frames = samples / m_channels;
-      m_pResampler->Resample(&pBuffer, frames, m_audioPlanes, frames, 1.0);
+      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);
       for (int i=0; i<m_planes; i++)
       {
-        m_audioPlanes[i] += frames*m_srcFormat.m_frameSize/m_planes;
+        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;
       }
     }
     else
     {
-      memcpy(pBuffer, m_audioPlanes[0], *actualsize);
-      m_audioPlanes[0] += (*actualsize);
+      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);
+      m_audioFrame.data[0] += (*actualsize);
     }
     m_nDecodedLen -= nLen;
     return READ_SUCCESS;
   }
 
   m_nDecodedLen = 0;
-  int bytes = m_pAudioCodec->GetData(m_audioPlanes);
+  m_pAudioCodec->GetData(m_audioFrame);
+  int bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;
 
   if (!bytes)
   {
@@ -390,7 +391,8 @@ int VideoPlayerCodec::ReadPCM(unsigned char *pBuffer, int size, int *actualsize)
       return READ_ERROR;
     }
 
-    bytes = m_pAudioCodec->GetData(m_audioPlanes);
+    m_pAudioCodec->GetData(m_audioFrame);
+    bytes = m_audioFrame.nb_frames * m_audioFrame.framesize;
   }
 
   m_nDecodedLen = bytes;
@@ -405,16 +407,16 @@ int VideoPlayerCodec::ReadPCM(unsigned char *pBuffer, int size, int *actualsize)
     {
       int samples = *actualsize / (m_bitsPerSample>>3);
       int frames = samples / m_channels;
-      m_pResampler->Resample(&pBuffer, frames, m_audioPlanes, frames, 1.0);
+      m_pResampler->Resample(&pBuffer, frames, m_audioFrame.data, frames, 1.0);
       for (int i=0; i<m_planes; i++)
       {
-        m_audioPlanes[i] += frames*m_srcFormat.m_frameSize/m_planes;
+        m_audioFrame.data[i] += frames*m_srcFormat.m_frameSize/m_planes;
       }
     }
     else
     {
-      memcpy(pBuffer, m_audioPlanes[0], *actualsize);
-      m_audioPlanes[0] += *actualsize;
+      memcpy(pBuffer, m_audioFrame.data[0], *actualsize);
+      m_audioFrame.data[0] += *actualsize;
     }
     m_nDecodedLen -= *actualsize;
   }
diff --git a/xbmc/cores/paplayer/VideoPlayerCodec.h b/xbmc/cores/paplayer/VideoPlayerCodec.h
index a2f02a8d9fa4..43d3deca1056 100644
--- a/xbmc/cores/paplayer/VideoPlayerCodec.h
+++ b/xbmc/cores/paplayer/VideoPlayerCodec.h
@@ -68,7 +68,7 @@ class VideoPlayerCodec : public ICodec
   bool m_bCanSeek;
 
   ActiveAE::IAEResample *m_pResampler;
-  uint8_t *m_audioPlanes[8];
+  DVDAudioFrame m_audioFrame;
   int m_planes;
   bool m_needConvert;
   AEAudioFormat m_srcFormat;

From ed863844e8cb5631279855d5bd53a034d04b60e4 Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Wed, 16 May 2018 09:44:44 +0200
Subject: [PATCH 2/2] [Android] Dolby transcoder

---
 .../Audio/DVDAudioCodecAndroidMediaCodec.cpp       | 224 ++++++++++++++++-----
 .../Audio/DVDAudioCodecAndroidMediaCodec.h         |  17 +-
 .../DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp        |   7 +
 .../VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp      |   9 +-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |   6 +
 xbmc/windowing/android/WinSystemAndroid.cpp        |  12 ++
 6 files changed, 219 insertions(+), 56 deletions(-)

diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.cpp
index 60df5b8bb251..e86621a3ae68 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.cpp
@@ -30,9 +30,14 @@
 
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/DVDFactoryCodec.h"
+#include "DVDAudioCodecFFmpeg.h"
+#include "DVDAudioCodecPassthrough.h"
+
 #include "utils/log.h"
 #include "settings/AdvancedSettings.h"
+#include "cores/AudioEngine/Interfaces/AE.h"
 #include "cores/VideoPlayer/Interface/Addon/DemuxCrypto.h"
+#include "ServiceBroker.h"
 
 #include <androidjni/ByteBuffer.h>
 #include <androidjni/MediaCodec.h>
@@ -51,19 +56,35 @@
 
 static const AEChannel KnownChannels[] = { AE_CH_FL, AE_CH_FR, AE_CH_FC, AE_CH_LFE, AE_CH_SL, AE_CH_SR, AE_CH_BL, AE_CH_BR, AE_CH_BC, AE_CH_BLOC, AE_CH_BROC, AE_CH_NULL };
 
+static bool IsDownmixDecoder(const std::string &name)
+{
+  static const char *downmixDecoders[] = {
+    "OMX.dolby",
+    // End of Rockchip
+    NULL
+  };
+  for (const char **ptr = downmixDecoders; *ptr; ptr++)
+  {
+    if (!strnicmp(*ptr, name.c_str(), strlen(*ptr)))
+      return true;
+  }
+  return false;
+}
+
 /****************************/
 
 CDVDAudioCodecAndroidMediaCodec::CDVDAudioCodecAndroidMediaCodec(CProcessInfo &processInfo) :
   CDVDAudioCodec(processInfo),
   m_formatname("mediacodec"),
   m_opened(false),
+  m_resettable(false),
   m_samplerate(0),
   m_channels(0),
   m_buffer(NULL),
   m_bufferSize(0),
   m_bufferUsed(0),
   m_currentPts(DVD_NOPTS_VALUE),
-  m_crypto(0)
+  m_crypto(nullptr)
 {
 }
 
@@ -85,17 +106,37 @@ bool CDVDAudioCodecAndroidMediaCodec::Register()
 
 bool CDVDAudioCodecAndroidMediaCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
-  if (!hints.cryptoSession)
-    return false;
-
   m_hints = hints;
 
   CLog::Log(LOGDEBUG, "CDVDAudioCodecAndroidMediaCodec::Open codec(%d), profile(%d), tag(%d), extrasize(%d)", hints.codec, hints.profile, hints.codec_tag, hints.extrasize);
 
+  // First check if passthrough decoder is supported
+  CAEStreamInfo::DataType ptStreamType = CAEStreamInfo::STREAM_TYPE_NULL;
+  for (const auto &key : options.m_keys)
+    if (key.m_name == "ptstreamtype")
+    {
+      ptStreamType = static_cast<CAEStreamInfo::DataType>(atoi(key.m_value.c_str()));
+      break;
+    }
+
+  if (ptStreamType != CAEStreamInfo::STREAM_TYPE_NULL)
+  {
+    //Look if the PT decoder can be opened
+    m_decryptCodec = std::shared_ptr<CDVDAudioCodec>(new CDVDAudioCodecPassthrough(m_processInfo, ptStreamType));
+    if (m_decryptCodec->Open(hints, options))
+      goto PROCESSDECODER;
+  }
+
   switch(m_hints.codec)
   {
     case AV_CODEC_ID_AAC:
     case AV_CODEC_ID_AAC_LATM:
+      if (!m_hints.extrasize)
+      {
+        CLog::Log(LOGNOTICE, "CDVDAudioCodecAndroidMediaCodec: extradata required for aac decoder!");
+        return false;
+      }
+
       m_mime = "audio/mp4a-latm";
       m_formatname = "amc-aac";
       break;
@@ -148,11 +189,45 @@ bool CDVDAudioCodecAndroidMediaCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptio
       break;
 
     default:
-      CLog::Log(LOGNOTICE, "CDVDAudioCodecAndroidMediaCodec:: Unknown hints.codec(%d)", hints.codec);
+      CLog::Log(LOGNOTICE, "CDVDAudioCodecAndroidMediaCodec: Unknown hints.codec(%d)", hints.codec);
       return false;
       break;
   }
 
+  {
+    //StereoDownmixAllowed is true if the user has selected 2.0 Audio channels in settings
+    bool stereoDownmixAllowed = CServiceBroker::GetActiveAE()->HasStereoAudioChannelCount();
+    unsigned int num_codecs = CJNIMediaCodecList::getCodecCount();
+    std::vector<std::string> mimeTypes;
+
+    for (int i = 0; i < num_codecs; i++)
+    {
+      CJNIMediaCodecInfo codec_info = CJNIMediaCodecList::getCodecInfoAt(i);
+      if (codec_info.isEncoder())
+        continue;
+
+      std::string codecName = codec_info.getName();
+
+      if (m_hints.channels > 2 && !stereoDownmixAllowed && IsDownmixDecoder(codecName))
+        continue;
+
+      mimeTypes = codec_info.getSupportedTypes();
+      if (std::find(mimeTypes.begin(), mimeTypes.end(), m_mime) != mimeTypes.end())
+      {
+        m_codec = std::shared_ptr<CJNIMediaCodec>(new CJNIMediaCodec(CJNIMediaCodec::createByCodecName(codecName)));
+        if (xbmc_jnienv()->ExceptionCheck())
+        {
+          xbmc_jnienv()->ExceptionClear();
+          m_codec = NULL;
+          continue;
+        }
+        CLog::Log(LOGINFO, "CDVDAudioCodecAndroidMediaCodec: Selected audio decoder: %s", codecName.c_str());
+      }
+    }
+  }
+
+PROCESSDECODER:
+
   if (m_crypto)
     delete m_crypto;
 
@@ -184,18 +259,34 @@ bool CDVDAudioCodecAndroidMediaCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptio
   else
     m_crypto = new CJNIMediaCrypto(jni::jhobject(NULL));
 
-  m_codec = std::shared_ptr<CJNIMediaCodec>(new CJNIMediaCodec(CJNIMediaCodec::createDecoderByType(m_mime)));
-  if (xbmc_jnienv()->ExceptionCheck())
-  {
-    // Unsupported type?
-    xbmc_jnienv()->ExceptionClear();
-    m_codec = NULL;
-  }
-
   if (!m_codec)
   {
-    CLog::Log(LOGERROR, "CDVDAudioCodecAndroidMediaCodec:: Failed to create Android MediaCodec");
-    return false;
+    if (m_hints.cryptoSession)
+    {
+      m_mime = "audio/raw";
+      m_codec = std::shared_ptr<CJNIMediaCodec>(new CJNIMediaCodec(CJNIMediaCodec::createDecoderByType(m_mime)));
+      if (xbmc_jnienv()->ExceptionCheck())
+      {
+        xbmc_jnienv()->ExceptionClear();
+        CLog::Log(LOGERROR, "CDVDAudioCodecAndroidMediaCodec::Open Failed creating raw decoder");
+        return false;
+      }
+      if (!m_decryptCodec)
+      {
+        m_decryptCodec = std::shared_ptr<CDVDAudioCodec>(new CDVDAudioCodecFFmpeg(m_processInfo));
+        if (!m_decryptCodec->Open(hints, options))
+        {
+          CLog::Log(LOGERROR, "CDVDAudioCodecAndroidMediaCodec::Open() Failed opening FFmpeg decoder");
+          return false;
+        }
+      }
+      CLog::Log(LOGINFO, "CDVDAudioCodecAndroidMediaCodec Use raw decoder and decode using %s", m_decryptCodec->GetName());
+    }
+    else
+    {
+      CLog::Log(LOGINFO, "CDVDAudioCodecAndroidMediaCodec::Open() Use default handling for non encrypted stream");
+      return false;
+    }
   }
 
   if (!ConfigureMediaCodec())
@@ -204,11 +295,13 @@ bool CDVDAudioCodecAndroidMediaCodec::Open(CDVDStreamInfo &hints, CDVDCodecOptio
     return false;
   }
 
-  CLog::Log(LOGINFO, "CDVDAudioCodecAndroidMediaCodec:: Open Android MediaCodec %s", m_formatname.c_str());
+  CLog::Log(LOGINFO, "CDVDAudioCodecAndroidMediaCodec Open Android MediaCodec %s", m_formatname.c_str());
+  if (!m_decryptCodec)
+    m_processInfo.SetAudioDecoderName(m_formatname.c_str());
 
-  m_opened = true;
 
-  m_processInfo.SetAudioDecoderName(m_formatname.c_str());
+  m_opened = true;
+  m_resettable = false;
   m_currentPts = DVD_NOPTS_VALUE;
   return m_opened;
 }
@@ -234,6 +327,7 @@ void CDVDAudioCodecAndroidMediaCodec::Dispose()
     delete m_crypto;
     m_crypto = nullptr;
   }
+  m_decryptCodec = nullptr;
 }
 
 bool CDVDAudioCodecAndroidMediaCodec::AddData(const DemuxPacket &packet)
@@ -315,14 +409,32 @@ bool CDVDAudioCodecAndroidMediaCodec::AddData(const DemuxPacket &packet)
         xbmc_jnienv()->ExceptionDescribe();
         xbmc_jnienv()->ExceptionClear();
       }
+      m_resettable = true;
     }
   }
 
-  m_format.m_dataFormat = GetDataFormat();
-  m_format.m_channelLayout = GetChannelMap();
-  m_format.m_sampleRate = GetSampleRate();
-  m_format.m_frameSize = m_format.m_channelLayout.Count() * CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3;
-
+  if (m_decryptCodec)
+  {
+    DemuxPacket newPkt;
+    newPkt.iSize = GetData(&newPkt.pData);
+    newPkt.pts = m_currentPts;
+    newPkt.iStreamId = packet.iStreamId;
+    newPkt.demuxerId = packet.demuxerId;
+    newPkt.iGroupId = packet.iGroupId;
+    newPkt.pSideData = packet.pSideData;
+    newPkt.duration = packet.duration;
+    newPkt.dispTime = packet.dispTime;
+    newPkt.recoveryPoint = packet.recoveryPoint;
+    if (!packet.pData || newPkt.iSize)
+      m_decryptCodec->AddData(newPkt);
+  }
+  else
+  {
+    m_format.m_dataFormat = GetDataFormat();
+    m_format.m_channelLayout = GetChannelMap();
+    m_format.m_sampleRate = GetSampleRate();
+    m_format.m_frameSize = m_format.m_channelLayout.Count() * CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3;
+  }
   return true;
 }
 
@@ -331,7 +443,7 @@ void CDVDAudioCodecAndroidMediaCodec::Reset()
   if (!m_opened)
     return;
 
-  if (m_codec)
+  if (m_codec && m_resettable)
   {
     // now we can flush the actual MediaCodec object
     m_codec->flush();
@@ -341,9 +453,22 @@ void CDVDAudioCodecAndroidMediaCodec::Reset()
       xbmc_jnienv()->ExceptionClear();
     }
   }
+  m_resettable = false;
+
+  if (m_decryptCodec)
+    m_decryptCodec->Reset();
+
   m_currentPts = DVD_NOPTS_VALUE;
 }
 
+AEAudioFormat CDVDAudioCodecAndroidMediaCodec::GetFormat()
+{
+  if (m_decryptCodec)
+    return m_decryptCodec->GetFormat();
+
+  return m_format;
+}
+
 CAEChannelInfo CDVDAudioCodecAndroidMediaCodec::GetChannelMap()
 {
   CAEChannelInfo chaninfo;
@@ -358,27 +483,30 @@ bool CDVDAudioCodecAndroidMediaCodec::ConfigureMediaCodec(void)
 {
   // setup a MediaFormat to match the audio content,
   // used by codec during configure
-  CJNIMediaFormat mediaformat = CJNIMediaFormat::createAudioFormat(
-    m_mime.c_str(), m_hints.samplerate, m_hints.channels);
+  CJNIMediaFormat mediaformat(CJNIMediaFormat::createAudioFormat(
+    m_mime.c_str(), m_hints.samplerate, m_hints.channels));
 
-  // handle codec extradata
-  if (m_hints.extrasize)
-  {
-    size_t size = m_hints.extrasize;
-    void  *src_ptr = m_hints.extradata;
-    // Allocate a byte buffer via allocateDirect in java instead of NewDirectByteBuffer,
-    // since the latter doesn't allocate storage of its own, and we don't know how long
-    // the codec uses the buffer.
-    CJNIByteBuffer bytebuffer = CJNIByteBuffer::allocateDirect(size);
-    void *dts_ptr = xbmc_jnienv()->GetDirectBufferAddress(bytebuffer.get_raw());
-    memcpy(dts_ptr, src_ptr, size);
-    // codec will automatically handle buffers as extradata
-    // using entries with keys "csd-0", "csd-1", etc.
-    mediaformat.setByteBuffer("csd-0", bytebuffer);
-  }
-  else if (m_hints.codec == AV_CODEC_ID_AAC || m_hints.codec == AV_CODEC_ID_AAC_LATM)
+  if (!m_decryptCodec)
   {
-    mediaformat.setInteger(CJNIMediaFormat::KEY_IS_ADTS, 1);
+    // handle codec extradata
+    if (m_hints.extrasize)
+    {
+      size_t size = m_hints.extrasize;
+      void  *src_ptr = m_hints.extradata;
+      // Allocate a byte buffer via allocateDirect in java instead of NewDirectByteBuffer,
+      // since the latter doesn't allocate storage of its own, and we don't know how long
+      // the codec uses the buffer.
+      CJNIByteBuffer bytebuffer = CJNIByteBuffer::allocateDirect(size);
+      void *dts_ptr = xbmc_jnienv()->GetDirectBufferAddress(bytebuffer.get_raw());
+      memcpy(dts_ptr, src_ptr, size);
+      // codec will automatically handle buffers as extradata
+      // using entries with keys "csd-0", "csd-1", etc.
+      mediaformat.setByteBuffer("csd-0", bytebuffer);
+    }
+    else if (m_hints.codec == AV_CODEC_ID_AAC || m_hints.codec == AV_CODEC_ID_AAC_LATM)
+    {
+      mediaformat.setInteger(CJNIMediaFormat::KEY_IS_ADTS, 1);
+    }
   }
 
   // configure and start the codec.
@@ -398,7 +526,6 @@ bool CDVDAudioCodecAndroidMediaCodec::ConfigureMediaCodec(void)
     return false;
   }
 
-
   m_codec->start();
   // always, check/clear jni exceptions.
   if (xbmc_jnienv()->ExceptionCheck())
@@ -411,13 +538,20 @@ bool CDVDAudioCodecAndroidMediaCodec::ConfigureMediaCodec(void)
 
   // There is no guarantee we'll get an INFO_OUTPUT_FORMAT_CHANGED (up to Android 4.3)
   // Configure the output with defaults
-  ConfigureOutputFormat(&mediaformat);
+  if (!m_decryptCodec)
+    ConfigureOutputFormat(&mediaformat);
 
   return true;
 }
 
 void CDVDAudioCodecAndroidMediaCodec::GetData(DVDAudioFrame &frame)
 {
+  if (m_decryptCodec)
+  {
+    m_decryptCodec->GetData(frame);
+    return;
+  }
+
   frame.passthrough = false;
   frame.nb_frames = 0;
   frame.framesOut = 0;
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
index 3361889e6b81..83c743946f0c 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecAndroidMediaCodec.h
@@ -48,13 +48,13 @@ class CDVDAudioCodecAndroidMediaCodec : public CDVDAudioCodec
 
   // required overrides
 public:
-  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
-  virtual void Dispose() override;
-  virtual bool AddData(const DemuxPacket &packet) override;
-  virtual void GetData(DVDAudioFrame &frame) override;
-  virtual void Reset() override;
-  virtual AEAudioFormat GetFormat() override { return m_format; }
-  virtual const char* GetName() override { return "mediacodec"; }
+  bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options) override;
+  void Dispose() override;
+  bool AddData(const DemuxPacket &packet) override;
+  void GetData(DVDAudioFrame &frame) override;
+  void Reset() override;
+  AEAudioFormat GetFormat() override;
+  const char* GetName() override { return "mediacodec"; }
 
 protected:
   int GetData(uint8_t** dst);
@@ -72,7 +72,7 @@ class CDVDAudioCodecAndroidMediaCodec : public CDVDAudioCodec
   std::string m_mime;
   std::string m_codecname;
   std::string m_formatname;
-  bool m_opened;
+  bool m_opened, m_resettable;
   int m_samplerate;
   int m_channels;
   uint8_t* m_buffer;
@@ -83,4 +83,5 @@ class CDVDAudioCodecAndroidMediaCodec : public CDVDAudioCodec
 
   std::shared_ptr<CJNIMediaCodec> m_codec;
   CJNIMediaCrypto *m_crypto;
+  std::shared_ptr<CDVDAudioCodec> m_decryptCodec;
 };
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
index e60f38ba1964..2b195f1df92d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Audio/DVDAudioCodecFFmpeg.cpp
@@ -55,6 +55,12 @@ CDVDAudioCodecFFmpeg::~CDVDAudioCodecFFmpeg()
 
 bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
+  if (hints.cryptoSession)
+  {
+    CLog::Log(LOGERROR,"CDVDAudioCodecFFmpeg::Open() CryptoSessions unsuppoted!");
+    return false;
+  }
+
   AVCodec* pCodec = NULL;
   bool allowdtshddecode = true;
 
@@ -128,6 +134,7 @@ bool CDVDAudioCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options
   m_matrixEncoding = AV_MATRIX_ENCODING_NONE;
 
   m_processInfo.SetAudioDecoderName(m_pCodecContext->codec->name);
+  CLog::Log(LOGNOTICE,"CDVDAudioCodecFFmpeg::Open() Successful opened audio decoder %s", m_pCodecContext->codec->name);
   return true;
 }
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
index ec9e7deb868b..55c663b44c1d 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -185,6 +185,12 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec(CDVDStreamInfo &hint, CProces
   std::unique_ptr<CDVDAudioCodec> pCodec;
   CDVDCodecOptions options;
 
+  if (allowpassthrough && ptStreamType != CAEStreamInfo::STREAM_TYPE_NULL)
+    options.m_keys.push_back(CDVDCodecOption("ptstreamtype", StringUtils::SizeToString(ptStreamType)));
+
+  if (!allowdtshddecode)
+    options.m_keys.push_back(CDVDCodecOption("allowdtshddecode", "0"));
+
   // platform specifig audio decoders
   for (auto &codec : m_hwAudioCodecs)
   {
@@ -195,9 +201,6 @@ CDVDAudioCodec* CDVDFactoryCodec::CreateAudioCodec(CDVDStreamInfo &hint, CProces
     }
   }
 
-  if (!allowdtshddecode)
-    options.m_keys.push_back(CDVDCodecOption("allowdtshddecode", "0"));
-
   // we don't use passthrough if "sync playback to display" is enabled
   if (allowpassthrough && ptStreamType != CAEStreamInfo::STREAM_TYPE_NULL)
   {
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index c3ceb01bc707..69af154f5200 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -353,6 +353,12 @@ CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
 
 bool CDVDVideoCodecFFmpeg::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
 {
+  if (hints.cryptoSession)
+  {
+    CLog::Log(LOGERROR,"CDVDVideoCodecFFmpeg::Open() CryptoSessions unsuppoted!");
+    return false;
+  }
+
   m_hints = hints;
   m_options = options;
 
diff --git a/xbmc/windowing/android/WinSystemAndroid.cpp b/xbmc/windowing/android/WinSystemAndroid.cpp
index b9ee4aac8ef8..368c68cfa0fe 100644
--- a/xbmc/windowing/android/WinSystemAndroid.cpp
+++ b/xbmc/windowing/android/WinSystemAndroid.cpp
@@ -43,6 +43,7 @@
 #include "platform/android/powermanagement/AndroidPowerSyscall.h"
 #include "addons/interfaces/platform/android/System.h"
 #include "platform/android/drm/MediaDrmCryptoSession.h"
+#include <androidjni/MediaCodecList.h>
 
 #include <EGL/egl.h>
 #include <EGL/eglplatform.h>
@@ -237,6 +238,17 @@ void CWinSystemAndroid::UpdateResolutions()
     CDisplaySettings::GetInstance().GetResolutionInfo(RES_DESKTOP) = CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop);
     CDisplaySettings::GetInstance().GetResolutionInfo(ResDesktop) = desktop;
   }
+
+  unsigned int num_codecs = CJNIMediaCodecList::getCodecCount();
+  for (int i = 0; i < num_codecs; i++)
+  {
+    CJNIMediaCodecInfo codec_info = CJNIMediaCodecList::getCodecInfoAt(i);
+    if (codec_info.isEncoder())
+      continue;
+
+    std::string codecname = codec_info.getName();
+    CLog::Log(LOGNOTICE, "Mediacodec: %s", codecname.c_str());
+  }
 }
 
 bool CWinSystemAndroid::Hide()
