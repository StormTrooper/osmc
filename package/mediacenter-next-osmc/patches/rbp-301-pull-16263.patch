From 4181e251b7e63176181acc8bf6d7de031e1d94df Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Thu, 5 Mar 2020 09:33:09 -0800
Subject: [PATCH 1/2] [depends] libcdio-gplv3: add patch to remove glob
 reference

This patch can be removed with android api 28
---
 .../01-fix-glob-on-android.patch              | 41 +++++++++++++++++++
 tools/depends/target/libcdio-gplv3/Makefile   |  3 +-
 2 files changed, 43 insertions(+), 1 deletion(-)
 create mode 100644 tools/depends/target/libcdio-gplv3/01-fix-glob-on-android.patch

diff --git a/tools/depends/target/libcdio-gplv3/01-fix-glob-on-android.patch b/tools/depends/target/libcdio-gplv3/01-fix-glob-on-android.patch
new file mode 100644
index 000000000000..669871ff0536
--- /dev/null
+++ b/tools/depends/target/libcdio-gplv3/01-fix-glob-on-android.patch
@@ -0,0 +1,41 @@
+diff -Naur a/lib/driver/image/bincue.c b/lib/driver/image/bincue.c
+--- a/lib/driver/image/bincue.c	2018-12-30 15:44:21.000000000 -0800
++++ b/lib/driver/image/bincue.c	2020-03-05 09:27:25.906767475 -0800
+@@ -1,3 +1,4 @@
++
+ /*
+   Copyright (C) 2002-2006, 2008, 2011-2012, 2014, 2017
+     Rocky Bernstein <rocky@gnu.org>
+@@ -1045,7 +1046,7 @@
+ {
+   char **drives = NULL;
+   unsigned int num_files=0;
+-#ifdef HAVE_GLOB_H
++#if defined(HAVE_GLOB_H) && !defined(__ANDROID__)
+   unsigned int i;
+   glob_t globbuf;
+   globbuf.gl_offs = 0;
+diff -Naur a/lib/driver/image/cdrdao.c b/lib/driver/image/cdrdao.c
+--- a/lib/driver/image/cdrdao.c	2018-08-12 09:33:48.000000000 -0700
++++ b/lib/driver/image/cdrdao.c	2020-03-05 09:28:25.873265269 -0800
+@@ -1149,7 +1149,7 @@
+ {
+   char **drives = NULL;
+   unsigned int num_files=0;
+-#ifdef HAVE_GLOB_H
++#if defined(HAVE_GLOB_H) && !defined(__ANDROID__)
+   unsigned int i;
+   glob_t globbuf;
+   globbuf.gl_offs = 0;
+diff -Naur a/lib/driver/image/nrg.c b/lib/driver/image/nrg.c
+--- a/lib/driver/image/nrg.c	2018-08-12 09:33:48.000000000 -0700
++++ b/lib/driver/image/nrg.c	2020-03-05 09:27:59.899482793 -0800
+@@ -1167,7 +1167,7 @@
+ {
+   char **drives = NULL;
+   unsigned int num_files=0;
+-#ifdef HAVE_GLOB_H
++#if defined(HAVE_GLOB_H) && !defined(__ANDROID__)
+   unsigned int i;
+   glob_t globbuf;
+   globbuf.gl_offs = 0;
diff --git a/tools/depends/target/libcdio-gplv3/Makefile b/tools/depends/target/libcdio-gplv3/Makefile
index dce31596a7c3..a7ac2116736c 100644
--- a/tools/depends/target/libcdio-gplv3/Makefile
+++ b/tools/depends/target/libcdio-gplv3/Makefile
@@ -1,5 +1,5 @@
 include ../../Makefile.include
-DEPS= ../../Makefile.include Makefile osx.patch
+DEPS= ../../Makefile.include Makefile osx.patch 01-fix-glob-on-android.patch
 
 # lib name, version
 LIBNAME=libcdio
@@ -24,6 +24,7 @@ $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM)/*; mkdir -p $(PLATFORM)
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
 	cd $(PLATFORM); patch -p1 -i ../osx.patch
+	cd $(PLATFORM); patch -p1 -i ../01-fix-glob-on-android.patch
 	cd $(PLATFORM); $(AUTORECONF) -vif
 	cd $(PLATFORM); $(CONFIGURE)
 

From 558b54a79eff717237919afe453ec09e0851d3a5 Mon Sep 17 00:00:00 2001
From: Lukas Rusak <lorusak@gmail.com>
Date: Fri, 31 May 2019 21:19:03 -0700
Subject: [PATCH 2/2] udf: rework IFile and IFileDirectory implementation

This change allows using libcdio's libudf
---
 CMakeLists.txt                           |    1 +
 cmake/modules/FindUdf.cmake              |   36 +
 xbmc/filesystem/CMakeLists.txt           |   13 +-
 xbmc/filesystem/DirectoryFactory.cpp     |    4 +
 xbmc/filesystem/FileDirectoryFactory.cpp |    8 +
 xbmc/filesystem/FileFactory.cpp          |    7 +-
 xbmc/filesystem/UDFDirectory.cpp         |   73 +-
 xbmc/filesystem/UDFDirectory.h           |   10 +-
 xbmc/filesystem/UDFFile.cpp              |  172 +--
 xbmc/filesystem/UDFFile.h                |   44 +-
 xbmc/filesystem/udf25.cpp                | 1251 ----------------------
 xbmc/filesystem/udf25.h                  |  214 ----
 12 files changed, 225 insertions(+), 1608 deletions(-)
 create mode 100644 cmake/modules/FindUdf.cmake
 delete mode 100644 xbmc/filesystem/udf25.cpp
 delete mode 100644 xbmc/filesystem/udf25.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 85d81aea15d6..f9022119f96d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -154,6 +154,7 @@ set(optional_deps Alsa
                   SmbClient
                   Sndio
                   UDEV
+                  Udf
                   XSLT
                   ${PLATFORM_OPTIONAL_DEPS})
 
diff --git a/cmake/modules/FindUdf.cmake b/cmake/modules/FindUdf.cmake
new file mode 100644
index 000000000000..3b08dc213fbf
--- /dev/null
+++ b/cmake/modules/FindUdf.cmake
@@ -0,0 +1,36 @@
+#.rst:
+# FindUdf
+# --------
+# Finds the udf library
+#
+# This will define the following variables::
+#
+# UDF_FOUND - system has udf
+# UDF_INCLUDE_DIRS - the udf include directory
+# UDF_LIBRARIES - the udf libraries
+# UDF_DEFINITIONS - the udf definitions
+
+if(PKG_CONFIG_FOUND)
+  pkg_check_modules(PC_UDF libudf>=0.94 QUIET)
+endif()
+
+find_path(UDF_INCLUDE_DIR NAMES cdio/udf.h
+                          PATHS ${PC_UDF_INCLUDEDIR})
+
+find_library(UDF_LIBRARY NAMES udf libudf
+                         PATHS ${PC_UDF_LIBDIR})
+
+set(UDF_VERSION ${PC_UDF_VERSION})
+
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(Udf
+                                  REQUIRED_VARS UDF_LIBRARY UDF_INCLUDE_DIR
+                                  VERSION_VAR UDF_VERSION)
+
+if(UDF_FOUND)
+  set(UDF_LIBRARIES ${UDF_LIBRARY})
+  set(UDF_INCLUDE_DIRS ${UDF_INCLUDE_DIR})
+  set(UDF_DEFINITIONS -DHAS_UDF=1)
+endif()
+
+mark_as_advanced(UDF_INCLUDE_DIR UDF_LIBRARY)
diff --git a/xbmc/filesystem/CMakeLists.txt b/xbmc/filesystem/CMakeLists.txt
index 711ffaaee8d1..c83cfad43772 100644
--- a/xbmc/filesystem/CMakeLists.txt
+++ b/xbmc/filesystem/CMakeLists.txt
@@ -49,9 +49,6 @@ set(SOURCES AddonsDirectory.cpp
             SpecialProtocolDirectory.cpp
             SpecialProtocolFile.cpp
             StackDirectory.cpp
-            udf25.cpp
-            UDFDirectory.cpp
-            UDFFile.cpp
             VideoDatabaseDirectory.cpp
             VideoDatabaseFile.cpp
             VirtualDirectory.cpp
@@ -116,9 +113,6 @@ set(HEADERS AddonsDirectory.h
             SpecialProtocolDirectory.h
             SpecialProtocolFile.h
             StackDirectory.h
-            udf25.h
-            UDFDirectory.h
-            UDFFile.h
             VideoDatabaseDirectory.h
             VirtualDirectory.h
             XbtDirectory.h
@@ -136,6 +130,13 @@ if(ISO9660PP_FOUND)
                       ISO9660File.h)
 endif()
 
+if(UDF_FOUND)
+  list(APPEND SOURCES UDFDirectory.cpp
+                      UDFFile.cpp)
+  list(APPEND HEADERS UDFDirectory.h
+                      UDFFile.h)
+endif()
+
 if(BLURAY_FOUND)
   list(APPEND SOURCES BlurayCallback.cpp
                       BlurayDirectory.cpp
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 98228e0c6b10..ac2fbc4a814a 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -25,7 +25,9 @@
 #include "FTPDirectory.h"
 #include "HTTPDirectory.h"
 #include "DAVDirectory.h"
+#if defined(HAS_UDF)
 #include "UDFDirectory.h"
+#endif
 #include "utils/log.h"
 #include "network/WakeOnAccess.h"
 
@@ -133,7 +135,9 @@ IDirectory* CDirectoryFactory::Create(const CURL& url)
 #if defined(HAS_ISO9660PP)
   if (url.IsProtocol("iso9660")) return new CISO9660Directory();
 #endif
+#if defined(HAS_UDF)
   if (url.IsProtocol("udf")) return new CUDFDirectory();
+#endif
   if (url.IsProtocol("plugin")) return new CPluginDirectory();
 #if defined(TARGET_ANDROID)
   if (url.IsProtocol("apk")) return new CAPKDirectory();
diff --git a/xbmc/filesystem/FileDirectoryFactory.cpp b/xbmc/filesystem/FileDirectoryFactory.cpp
index 35e51987e4cc..9b9d700b418e 100644
--- a/xbmc/filesystem/FileDirectoryFactory.cpp
+++ b/xbmc/filesystem/FileDirectoryFactory.cpp
@@ -11,6 +11,9 @@
 #if defined(HAS_ISO9660PP)
 #include "ISO9660Directory.h"
 #endif
+#if defined(HAS_UDF)
+#include "UDFDirectory.h"
+#endif
 #include "RSSDirectory.h"
 #include "UDFDirectory.h"
 #include "utils/URIUtils.h"
@@ -116,6 +119,7 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
   if (pItem->IsRSS())
     return new CRSSDirectory();
 
+
   if (pItem->IsDiscImage())
   {
 #if defined(HAS_ISO9660PP)
@@ -126,7 +130,11 @@ IFileDirectory* CFileDirectoryFactory::Create(const CURL& url, CFileItem* pItem,
     delete iso;
 #endif
 
+#if defined(HAS_UDF)
     return new CUDFDirectory();
+#endif
+
+    return nullptr;
   }
 
 #if defined(TARGET_ANDROID)
diff --git a/xbmc/filesystem/FileFactory.cpp b/xbmc/filesystem/FileFactory.cpp
index 5ba238d72c53..73d544dd8534 100644
--- a/xbmc/filesystem/FileFactory.cpp
+++ b/xbmc/filesystem/FileFactory.cpp
@@ -56,7 +56,9 @@
 #include "PluginFile.h"
 #include "SpecialProtocolFile.h"
 #include "MultiPathFile.h"
+#if defined(HAS_UDF)
 #include "UDFFile.h"
+#endif
 #include "ImageFile.h"
 #include "ResourceFile.h"
 #include "URL.h"
@@ -134,7 +136,10 @@ IFile* CFileFactory::CreateLoader(const CURL& url)
   else if (url.IsProtocol("iso9660"))
     return new CISO9660File();
 #endif
-  else if(url.IsProtocol("udf")) return new CUDFFile();
+#if defined(HAS_UDF)
+  else if(url.IsProtocol("udf"))
+    return new CUDFFile();
+#endif
 #if defined(TARGET_ANDROID)
   else if (url.IsProtocol("androidapp")) return new CFileAndroidApp();
 #endif
diff --git a/xbmc/filesystem/UDFDirectory.cpp b/xbmc/filesystem/UDFDirectory.cpp
index 015075fae7cf..ccecd1849b0d 100644
--- a/xbmc/filesystem/UDFDirectory.cpp
+++ b/xbmc/filesystem/UDFDirectory.cpp
@@ -8,56 +8,68 @@
  *  SPDX-License-Identifier: GPL-2.0-or-later
  *  See LICENSES/README.md for more information.
  */
+
 #include "UDFDirectory.h"
 
 #include "FileItem.h"
 #include "URL.h"
 #include "Util.h"
-#include "udf25.h"
 #include "utils/URIUtils.h"
 
-using namespace XFILE;
-
-CUDFDirectory::CUDFDirectory(void) = default;
+#include <cdio/udf.h>
 
-CUDFDirectory::~CUDFDirectory(void) = default;
+using namespace XFILE;
 
-bool CUDFDirectory::GetDirectory(const CURL& url,
-                                 CFileItemList &items)
+bool CUDFDirectory::GetDirectory(const CURL& url, CFileItemList& items)
 {
-  std::string strRoot, strSub;
   CURL url2(url);
   if (!url2.IsProtocol("udf"))
-  { // path to an image
+  {
     url2.Reset();
     url2.SetProtocol("udf");
     url2.SetHostName(url.Get());
   }
-  strRoot  = url2.Get();
-  strSub   = url2.GetFileName();
+
+  std::string strRoot(url2.Get());
+  std::string strSub(url2.GetFileName());
 
   URIUtils::AddSlashAtEnd(strRoot);
   URIUtils::AddSlashAtEnd(strSub);
 
-  udf25 udfIsoReader;
-  if(!udfIsoReader.Open(url2.GetHostName().c_str()))
-     return false;
+  udf_t* udf = udf_open(url2.GetHostName().c_str());
+
+  if (!udf)
+    return false;
 
-  udf_dir_t *dirp = udfIsoReader.OpenDir(strSub.c_str());
+  udf_dirent_t* root = udf_get_root(udf, true, 0);
 
-  if (dirp == NULL)
+  if (!root)
+  {
+    udf_close(udf);
     return false;
+  }
+
+  udf_dirent_t* path = udf_fopen(root, strSub.c_str());
+
+  if (!path)
+  {
+    udf_dirent_free(root);
+    udf_close(udf);
+    return false;
+  }
 
-  udf_dirent_t *dp = NULL;
-  while ((dp = udfIsoReader.ReadDir(dirp)) != NULL)
+  while (udf_readdir(path))
   {
-    if (dp->d_type == DVD_DT_DIR)
+    if (path->b_parent)
+      continue;
+
+    if (udf_is_dir(path))
     {
-      std::string strDir = (char*)dp->d_name;
-      if (strDir != "." && strDir != "..")
+      std::string filename = udf_get_filename(path);
+      if (filename != "." && filename != "..")
       {
-        CFileItemPtr pItem(new CFileItem((char*)dp->d_name));
-        strDir = strRoot + (char*)dp->d_name;
+        CFileItemPtr pItem(new CFileItem(filename));
+        std::string strDir(strRoot + filename);
         URIUtils::AddSlashAtEnd(strDir);
         pItem->SetPath(strDir);
         pItem->m_bIsFolder = true;
@@ -67,16 +79,18 @@ bool CUDFDirectory::GetDirectory(const CURL& url,
     }
     else
     {
-      CFileItemPtr pItem(new CFileItem((char*)dp->d_name));
-      pItem->SetPath(strRoot + (char*)dp->d_name);
+      std::string filename = udf_get_filename(path);
+      CFileItemPtr pItem(new CFileItem(filename));
+      pItem->SetPath(strRoot + filename);
       pItem->m_bIsFolder = false;
-      pItem->m_dwSize = dp->d_filesize;
+      pItem->m_dwSize = udf_get_file_length(path);
 
       items.Add(pItem);
     }
   }
 
-  udfIsoReader.CloseDir(dirp);
+  udf_dirent_free(root);
+  udf_close(udf);
 
   return true;
 }
@@ -84,8 +98,5 @@ bool CUDFDirectory::GetDirectory(const CURL& url,
 bool CUDFDirectory::Exists(const CURL& url)
 {
   CFileItemList items;
-  if (GetDirectory(url, items))
-    return true;
-
-  return false;
+  return GetDirectory(url, items);
 }
diff --git a/xbmc/filesystem/UDFDirectory.h b/xbmc/filesystem/UDFDirectory.h
index c449ea8a2a61..ea4487a40a2e 100644
--- a/xbmc/filesystem/UDFDirectory.h
+++ b/xbmc/filesystem/UDFDirectory.h
@@ -15,13 +15,13 @@
 
 namespace XFILE
 {
-class CUDFDirectory :
-      public IFileDirectory
+
+class CUDFDirectory : public IFileDirectory
 {
 public:
-  CUDFDirectory(void);
-  ~CUDFDirectory(void) override;
-  bool GetDirectory(const CURL& url, CFileItemList &items) override;
+  CUDFDirectory() = default;
+  ~CUDFDirectory() = default;
+  bool GetDirectory(const CURL& url, CFileItemList& items) override;
   bool Exists(const CURL& url) override;
   bool ContainsFiles(const CURL& url) override { return true; }
 };
diff --git a/xbmc/filesystem/UDFFile.cpp b/xbmc/filesystem/UDFFile.cpp
index 1fa6f96ef791..c4e43215ccc2 100644
--- a/xbmc/filesystem/UDFFile.cpp
+++ b/xbmc/filesystem/UDFFile.cpp
@@ -1,136 +1,144 @@
 /*
- *  Copyright (C) 2010 Team Boxee
- *      http://www.boxee.tv
- *
- *  Copyright (C) 2010-2018 Team Kodi
+ *  Copyright (C) 2005-2018 Team Kodi
  *  This file is part of Kodi - https://kodi.tv
  *
  *  SPDX-License-Identifier: GPL-2.0-or-later
  *  See LICENSES/README.md for more information.
  */
+
 #include "UDFFile.h"
 
 #include "URL.h"
+#include "utils/log.h"
 
-#include <errno.h>
-#include <limits.h>
+#include <cmath>
 
+#include <cdio/udf.h>
 #include <sys/stat.h>
 
 using namespace XFILE;
 
-//////////////////////////////////////////////////////////////////////
-// Construction/Destruction
-//////////////////////////////////////////////////////////////////////
-//*********************************************************************************************
-CUDFFile::CUDFFile()
-  : m_hFile(INVALID_HANDLE_VALUE)
+bool CUDFFile::Open(const CURL& url)
 {
-}
+  if (m_udf && m_path)
+    return true;
 
-//*********************************************************************************************
-CUDFFile::~CUDFFile()
-{
-  if (m_bOpened)
+  m_udf = udf_open(url.GetHostName().c_str());
+
+  if (!m_udf)
+    return false;
+
+  udf_dirent_t* root = udf_get_root(m_udf, true, 0);
+
+  if (!root)
   {
     Close();
+    return false;
   }
-}
-//*********************************************************************************************
-bool CUDFFile::Open(const CURL& url)
-{
-  if(!m_udfIsoReaderLocal.Open(url.GetHostName().c_str()) || url.GetFileName().empty())
-     return false;
 
-  m_hFile = m_udfIsoReaderLocal.OpenFile(url.GetFileName().c_str());
-  if (m_hFile == INVALID_HANDLE_VALUE)
+  m_path = udf_fopen(root, url.GetFileName().c_str());
+
+  udf_dirent_free(root);
+
+  if (!m_path)
   {
-    m_bOpened = false;
+    Close();
     return false;
   }
 
-  m_bOpened = true;
+  m_current = 0;
+
   return true;
 }
 
-//*********************************************************************************************
-ssize_t CUDFFile::Read(void *lpBuf, size_t uiBufSize)
+void CUDFFile::Close()
 {
-  if (uiBufSize > SSIZE_MAX)
-    uiBufSize = SSIZE_MAX;
-  if (uiBufSize > LONG_MAX)
-    uiBufSize = LONG_MAX;
+  if (m_path)
+  {
+    udf_dirent_free(m_path);
+    m_path = nullptr;
+  }
+
+  if (m_udf)
+  {
+    udf_close(m_udf);
+    m_udf = nullptr;
+  }
+}
 
-  if (!m_bOpened)
+int CUDFFile::Stat(const CURL& url, struct __stat64* buffer)
+{
+  if (!m_udf || !m_path)
     return -1;
-  char *pData = (char *)lpBuf;
 
-  return m_udfIsoReaderLocal.ReadFile( m_hFile, (unsigned char*)pData, (long)uiBufSize);
+  buffer = {};
+  buffer->st_size = GetLength();
+
+  if (m_path->b_dir)
+  {
+    buffer->st_mode = S_IFDIR;
+  }
+  else
+  {
+    buffer->st_mode = S_IFREG;
+  }
+
+  return 0;
 }
 
-//*********************************************************************************************
-void CUDFFile::Close()
+ssize_t CUDFFile::Read(void* buffer, size_t size)
 {
-  if (!m_bOpened) return ;
-  m_udfIsoReaderLocal.CloseFile( m_hFile);
-  m_bOpened = false;
+  const int maxSize = std::min(size, static_cast<size_t>(GetLength()));
+  const int blocks = std::ceil(maxSize / UDF_BLOCKSIZE);
+
+  if (m_current > std::ceil(GetLength() / UDF_BLOCKSIZE))
+  {
+    return -1;
+  }
+
+  auto read = udf_read_block(m_path, buffer, blocks);
+
+  m_current += blocks;
+
+  return read;
 }
 
-//*********************************************************************************************
-int64_t CUDFFile::Seek(int64_t iFilePosition, int iWhence)
+int64_t CUDFFile::Seek(int64_t filePosition, int whence)
 {
-  if (!m_bOpened) return -1;
-  int64_t lNewPos = m_udfIsoReaderLocal.Seek(m_hFile, iFilePosition, iWhence);
-  return lNewPos;
+  int block = std::floor(filePosition / UDF_BLOCKSIZE);
+
+  switch (whence)
+  {
+    case SEEK_SET:
+      m_current = block;
+      break;
+    case SEEK_CUR:
+      m_current += block;
+      break;
+    case SEEK_END:
+      m_current = std::ceil(GetLength() / UDF_BLOCKSIZE) + block;
+      break;
+  }
+
+  return m_current * UDF_BLOCKSIZE;
 }
 
-//*********************************************************************************************
 int64_t CUDFFile::GetLength()
 {
-  if (!m_bOpened) return -1;
-  return m_udfIsoReaderLocal.GetFileSize(m_hFile);
+  return udf_get_file_length(m_path);
 }
 
-//*********************************************************************************************
 int64_t CUDFFile::GetPosition()
 {
-  if (!m_bOpened) return -1;
-  return m_udfIsoReaderLocal.GetFilePosition(m_hFile);
+  return m_current * UDF_BLOCKSIZE;
 }
 
 bool CUDFFile::Exists(const CURL& url)
 {
-  if(!m_udfIsoReaderLocal.Open(url.GetHostName().c_str()))
-     return false;
-
-  m_hFile = m_udfIsoReaderLocal.OpenFile(url.GetFileName().c_str());
-  if (m_hFile == INVALID_HANDLE_VALUE)
-    return false;
-
-  m_udfIsoReaderLocal.CloseFile(m_hFile);
-  m_hFile = INVALID_HANDLE_VALUE;
-  return true;
+  return Open(url);
 }
 
-int CUDFFile::Stat(const CURL& url, struct __stat64* buffer)
+int CUDFFile::GetChunkSize()
 {
-  if(!m_udfIsoReaderLocal.Open(url.GetHostName().c_str()))
-     return -1;
-
-  if (url.GetFileName().empty())
-  {
-    buffer->st_mode = _S_IFDIR;
-    return 0;
-  }
-
-  m_hFile = m_udfIsoReaderLocal.OpenFile(url.GetFileName().c_str());
-  if (m_hFile != INVALID_HANDLE_VALUE)
-  {
-    buffer->st_size = m_udfIsoReaderLocal.GetFileSize(m_hFile);
-    buffer->st_mode = _S_IFREG;
-    m_udfIsoReaderLocal.CloseFile(m_hFile);
-    return 0;
-  }
-  errno = ENOENT;
-  return -1;
+  return UDF_BLOCKSIZE;
 }
diff --git a/xbmc/filesystem/UDFFile.h b/xbmc/filesystem/UDFFile.h
index 292df3832874..be51b91d908b 100644
--- a/xbmc/filesystem/UDFFile.h
+++ b/xbmc/filesystem/UDFFile.h
@@ -1,8 +1,5 @@
 /*
- *  Copyright (C) 2010 Team Boxee
- *      http://www.boxee.tv
- *
- *  Copyright (C) 2010-2018 Team Kodi
+ *  Copyright (C) 2005-2018 Team Kodi
  *  This file is part of Kodi - https://kodi.tv
  *
  *  SPDX-License-Identifier: GPL-2.0-or-later
@@ -12,7 +9,9 @@
 #pragma once
 
 #include "IFile.h"
-#include "udf25.h"
+
+typedef struct udf_s udf_t;
+typedef struct udf_dirent_s udf_dirent_t;
 
 namespace XFILE
 {
@@ -20,20 +19,29 @@ namespace XFILE
 class CUDFFile : public IFile
 {
 public:
-  CUDFFile();
-  ~CUDFFile() override;
-  int64_t GetPosition() override;
-  int64_t GetLength() override;
+  CUDFFile() = default;
+  ~CUDFFile() override = default;
+
   bool Open(const CURL& url) override;
-  bool Exists(const CURL& url) override;
-  int Stat(const CURL& url, struct __stat64* buffer) override;
-  ssize_t Read(void* lpBuf, size_t uiBufSize) override;
-  int64_t Seek(int64_t iFilePosition, int iWhence = SEEK_SET) override;
   void Close() override;
-protected:
-  bool m_bOpened = false;
-  HANDLE m_hFile;
-  udf25 m_udfIsoReaderLocal;
+
+  int Stat(const CURL& url, struct __stat64* buffer) override;
+
+  ssize_t Read(void* buffer, size_t size) override;
+  int64_t Seek(int64_t filePosition, int whence) override;
+
+  int64_t GetLength() override;
+  int64_t GetPosition() override;
+
+  bool Exists(const CURL& url) override;
+
+  int GetChunkSize() override;
+
+private:
+  udf_t* m_udf{nullptr};
+  udf_dirent_t* m_path{nullptr};
+
+  uint32_t m_current;
 };
-}
 
+} // namespace XFILE
diff --git a/xbmc/filesystem/udf25.cpp b/xbmc/filesystem/udf25.cpp
deleted file mode 100644
index 169e21bf079e..000000000000
--- a/xbmc/filesystem/udf25.cpp
+++ /dev/null
@@ -1,1251 +0,0 @@
-/*
- *  Copyright (C) 2010 Team Boxee
- *      http://www.boxee.tv
- *
- *  Copyright (C) 2010-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-#include "udf25.h"
-
-#include "File.h"
-#include "utils/log.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-/* For direct data access, LSB first */
-#define GETN1(p) ((uint8_t)data[p])
-#define GETN2(p) ((uint16_t)data[p] | ((uint16_t)data[(p) + 1] << 8))
-#define GETN3(p) ((uint32_t)data[p] | ((uint32_t)data[(p) + 1] << 8)    \
-                  | ((uint32_t)data[(p) + 2] << 16))
-#define GETN4(p) ((uint32_t)data[p]                     \
-                  | ((uint32_t)data[(p) + 1] << 8)      \
-                  | ((uint32_t)data[(p) + 2] << 16)     \
-                  | ((uint32_t)data[(p) + 3] << 24))
-#define GETN8(p) ((uint64_t)data[p]                 \
-                  | ((uint64_t)data[(p) + 1] << 8)  \
-                  | ((uint64_t)data[(p) + 2] << 16) \
-                  | ((uint64_t)data[(p) + 3] << 24) \
-                  | ((uint64_t)data[(p) + 4] << 32) \
-                  | ((uint64_t)data[(p) + 5] << 40) \
-                  | ((uint64_t)data[(p) + 6] << 48) \
-                  | ((uint64_t)data[(p) + 7] << 56))
-
-/* This is wrong with regard to endianness */
-#define GETN(p, n, target) memcpy(target, &data[p], n)
-
-using namespace XFILE;
-
-static int Unicodedecode( uint8_t *data, int len, char *target )
-{
-  int p = 1, i = 0;
-
-  if( ( data[ 0 ] == 8 ) || ( data[ 0 ] == 16 ) ) do {
-    if( data[ 0 ] == 16 ) p++;  /* Ignore MSB of unicode16 */
-    if( p < len ) {
-      target[ i++ ] = data[ p++ ];
-    }
-  } while( p < len );
-
-  target[ i ] = '\0';
-  return 0;
-}
-
-static int UDFExtentAD( uint8_t *data, uint32_t *Length, uint32_t *Location )
-{
-  *Length   = GETN4(0);
-  *Location = GETN4(4);
-  return 0;
-}
-
-static int UDFShortAD( uint8_t *data, struct AD *ad )
-{
-  ad->Length = GETN4(0);
-  ad->Flags = ad->Length >> 30;
-  ad->Length &= 0x3FFFFFFF;
-  ad->Location = GETN4(4);
-  return 0;
-}
-
-static int UDFLongAD( uint8_t *data, struct AD *ad )
-{
-  ad->Length = GETN4(0);
-  ad->Flags = ad->Length >> 30;
-  ad->Length &= 0x3FFFFFFF;
-  ad->Location = GETN4(4);
-  ad->Partition = GETN2(8);
-  /* GETN(10, 6, Use); */
-  return 0;
-}
-
-static int UDFExtAD( uint8_t *data, struct AD *ad )
-{
-  ad->Length = GETN4(0);
-  ad->Flags = ad->Length >> 30;
-  ad->Length &= 0x3FFFFFFF;
-  ad->Location = GETN4(12);
-  ad->Partition = GETN2(16);
-  /* GETN(10, 6, Use); */
-  return 0;
-}
-
-static int UDFAD( uint8_t *ptr, uint32_t len, struct FileAD *fad)
-{
-  struct AD *ad;
-
-  if (fad->num_AD  >= UDF_MAX_AD_CHAINS)
-    return len;
-
-  ad =  &fad->AD_chain[fad->num_AD];
-  ad->Partition = fad->Partition;
-  ad->Flags     = 0;
-  fad->num_AD++;
-
-  switch( fad->Flags & 0x0007 ) {
-    case 0:
-      UDFShortAD( ptr, ad );
-      return 8;
-    case 1:
-      UDFLongAD( ptr, ad );
-      return 16;
-    case 2:
-      UDFExtAD( ptr, ad );
-      return 20;
-    case 3:
-      switch( len ) {
-        case 8:
-          UDFShortAD( ptr, ad );
-          break;
-        case 16:
-          UDFLongAD( ptr,  ad );
-          break;
-        case 20:
-          UDFExtAD( ptr, ad );
-          break;
-      }
-      break;
-    default:
-      break;
-  }
-
-  return len;
-}
-
-static int UDFICB( uint8_t *data, uint8_t *FileType, uint16_t *Flags )
-{
-  *FileType = GETN1(11);
-  *Flags = GETN2(18);
-  return 0;
-}
-
-static int UDFPartition( uint8_t *data, uint16_t *Flags, uint16_t *Number,
-                         char *Contents, uint32_t *Start, uint32_t *Length )
-{
-  *Flags = GETN2(20);
-  *Number = GETN2(22);
-  GETN(24, 32, Contents);
-  *Start = GETN4(188);
-  *Length = GETN4(192);
-  return 0;
-}
-
-static int UDFLogVolume( uint8_t *data, char *VolumeDescriptor )
-{
-  uint32_t lbsize;
-  Unicodedecode(&data[84], 128, VolumeDescriptor);
-  lbsize = GETN4(212);  /* should be 2048 */
-  if (lbsize != DVD_VIDEO_LB_LEN) return 1;
-  return 0;
-}
-
-static int UDFAdEntry( uint8_t *data, struct FileAD *fad )
-{
-  uint32_t L_AD;
-  unsigned int p;
-
-  L_AD = GETN4(20);
-  p = 24;
-  while( p < 24 + L_AD ) {
-    p += UDFAD( &data[ p ], L_AD, fad );
-  }
-  return 0;
-}
-
-static int UDFExtFileEntry( uint8_t *data, struct FileAD *fad )
-{
-  uint32_t L_EA, L_AD;
-  unsigned int p;
-
-  UDFICB( &data[ 16 ], &fad->Type, &fad->Flags );
-
-  /* Init ad for an empty file (i.e. there isn't a AD, L_AD == 0 ) */
-  fad->Length = GETN8(56); // 64-bit.
-
-  L_EA = GETN4( 208);
-  L_AD = GETN4( 212);
-  p = 216 + L_EA;
-  fad->num_AD = 0;
-  while( p < 216 + L_EA + L_AD ) {
-    p += UDFAD( &data[ p ], L_AD, fad );
-  }
-  return 0;
-
-}
-
-/* TagID 266
- * The differences in ExtFile are indicated below:
- * struct extfile_entry {
- *         struct desc_tag         tag;
- *         struct icb_tag          icbtag;
- *         uint32_t                uid;
- *         uint32_t                gid;
- *         uint32_t                perm;
- *         uint16_t                link_cnt;
- *         uint8_t                 rec_format;
- *         uint8_t                 rec_disp_attr;
- *         uint32_t                rec_len;
- *         uint64_t                inf_len;
- *         uint64_t                obj_size;        // NEW
- *         uint64_t                logblks_rec;
- *         struct timestamp        atime;
- *         struct timestamp        mtime;
- *         struct timestamp        ctime;           // NEW
- *         struct timestamp        attrtime;
- *         uint32_t                ckpoint;
- *         uint32_t                reserved1;       // NEW
- *         struct long_ad          ex_attr_icb;
- *         struct long_ad          streamdir_icb;   // NEW
- *         struct regid            imp_id;
- *         uint64_t                unique_id;
- *         uint32_t                l_ea;
- *         uint32_t                l_ad;
- *         uint8_t                 data[1];
- * } __packed;
- *
- * So old "l_ea" is now +216
- *
- * Lund
- */
-
-static int UDFFileEntry( uint8_t *data, struct FileAD *fad )
-{
-  uint32_t L_EA, L_AD;
-  unsigned int p;
-
-  UDFICB( &data[ 16 ], &fad->Type, &fad->Flags );
-
-  fad->Length = GETN8( 56 ); /* Was 4 bytes at 60, changed for 64bit. */
-
-  L_EA = GETN4( 168 );
-  L_AD = GETN4( 172 );
-
-  if (176 + L_EA + L_AD > DVD_VIDEO_LB_LEN)
-    return 0;
-
-  p = 176 + L_EA;
-  fad->num_AD = 0;
-  while( p < 176 + L_EA + L_AD ) {
-      p += UDFAD( &data[ p ], L_AD, fad );
-  }
-  return 0;
-}
-
-uint32_t UDFFilePos(struct FileAD *File, uint64_t pos, uint64_t *res)
-{
-  uint32_t i;
-
-  for (i = 0; i < File->num_AD; i++) {
-
-    if (pos < File->AD_chain[i].Length)
-      break;
-
-    pos -= File->AD_chain[i].Length;
-  }
-
-  if (i == File->num_AD)
-    return 0;
-
-  *res = (uint64_t)(File->Partition_Start + File->AD_chain[i].Location) * DVD_VIDEO_LB_LEN + pos;
-  return File->AD_chain[i].Length - (uint32_t)pos;
-}
-
-uint32_t UDFFileBlockPos(struct FileAD *File, uint32_t lb)
-{
-  uint64_t res;
-  uint32_t rem;
-  rem = UDFFilePos(File, lb * DVD_VIDEO_LB_LEN, &res);
-  if(rem > 0)
-    return (uint32_t)(res / DVD_VIDEO_LB_LEN);
-  else
-    return 0;
-}
-
-static int UDFFileIdentifier( uint8_t *data, uint8_t *FileCharacteristics,
-                              char *FileName, struct AD *FileICB )
-{
-  uint8_t L_FI;
-  uint16_t L_IU;
-
-  *FileCharacteristics = GETN1(18);
-  L_FI = GETN1(19);
-  UDFLongAD(&data[20], FileICB);
-  L_IU = GETN2(36);
-  if (L_FI) Unicodedecode(&data[38 + L_IU], L_FI, FileName);
-  else FileName[0] = '\0';
-  return 4 * ((38 + L_FI + L_IU + 3) / 4);
-}
-
-static int UDFDescriptor( uint8_t *data, uint16_t *TagID )
-{
-  *TagID = GETN2(0);
-  //! @todo check CRC 'n stuff
-  return 0;
-}
-
-int udf25::UDFScanDirX( udf_dir_t *dirp )
-{
-  char filename[ MAX_UDF_FILE_NAME_LEN ];
-  uint8_t directory_base[ 2 * DVD_VIDEO_LB_LEN + 2048];
-  uint8_t *directory = (uint8_t *)(((uintptr_t)directory_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum;
-  uint16_t TagID;
-  uint8_t filechar;
-  unsigned int p;
-  struct AD FileICB;
-  struct FileAD File;
-  struct Partition partition;
-
-  if(!(GetUDFCache(PartitionCache, 0, &partition))) {
-    if(!UDFFindPartition(0, &partition))
-      return 0;
-  }
-
-  /* Scan dir for ICB of file */
-  lbnum = dirp->dir_current;
-
-  // I have cut out the caching part of the original UDFScanDir() function
-  // one day we should probably bring it back.
-  memset(&File, 0, sizeof(File));
-
-  if( DVDReadLBUDF( lbnum, 2, directory, 0 ) <= 0 ) {
-    return 0;
-  }
-
-
-  p = dirp->current_p;
-  while( p < dirp->dir_length ) {
-    if( p > DVD_VIDEO_LB_LEN ) {
-      ++lbnum;
-      p -= DVD_VIDEO_LB_LEN;
-
-      //Dir.Length -= DVD_VIDEO_LB_LEN;
-      if (dirp->dir_length >= DVD_VIDEO_LB_LEN)
-        dirp->dir_length -= DVD_VIDEO_LB_LEN;
-      else
-        dirp->dir_length = 0;
-
-      if( DVDReadLBUDF( lbnum, 2, directory, 0 ) <= 0 ) {
-        return 0;
-      }
-    }
-    UDFDescriptor( &directory[ p ], &TagID );
-
-    if( TagID == 257 ) {
-
-      p += UDFFileIdentifier( &directory[ p ], &filechar,
-                              filename, &FileICB );
-
-      dirp->current_p = p;
-      dirp->dir_current = lbnum;
-
-      if (!*filename)  // No filename, simulate "." dirname
-        strcpy((char *)dirp->entry.d_name, ".");
-      else {
-        // Bah, MSVC don't have strlcpy()
-        strncpy((char *)dirp->entry.d_name, filename,
-                sizeof(dirp->entry.d_name)-1);
-        dirp->entry.d_name[ sizeof(dirp->entry.d_name) - 1 ] = 0;
-      }
-
-
-      // Look up the Filedata
-      if( !UDFMapICB( FileICB, &partition, &File))
-        return 0;
-      if (File.Type == 4)
-        dirp->entry.d_type = DVD_DT_DIR;
-      else
-        dirp->entry.d_type = DVD_DT_REG; // Add more types?
-
-      dirp->entry.d_filesize = File.Length;
-
-      return 1;
-
-    } else {
-      // Not TagID 257
-      return 0;
-    }
-  }
-  // End of DIR
-  return 0;
-}
-
-int udf25::SetUDFCache(UDFCacheType type, uint32_t nr, void *data)
-{
-  int n;
-  struct udf_cache *c;
-  void *tmp;
-
-  if(DVDUDFCacheLevel(-1) <= 0)
-    return 0;
-
-  c = (struct udf_cache *)GetUDFCacheHandle();
-
-  if(c == NULL) {
-    c = (struct udf_cache *)calloc(1, sizeof(struct udf_cache));
-    /* fprintf(stderr, "calloc: %d\n", sizeof(struct udf_cache)); */
-    if(c == NULL)
-      return 0;
-    SetUDFCacheHandle(c);
-  }
-
-
-  switch(type) {
-  case AVDPCache:
-    c->avdp = *(struct avdp_t *)data;
-    c->avdp_valid = 1;
-    break;
-  case PVDCache:
-    c->pvd = *(struct pvd_t *)data;
-    c->pvd_valid = 1;
-    break;
-  case PartitionCache:
-    c->partition = *(struct Partition *)data;
-    c->partition_valid = 1;
-    break;
-  case RootICBCache:
-    c->rooticb = *(struct AD *)data;
-    c->rooticb_valid = 1;
-    break;
-  case LBUDFCache:
-    for(n = 0; n < c->lb_num; n++) {
-      if(c->lbs[n].lb == nr) {
-        /* replace with new data */
-        c->lbs[n].data_base = ((uint8_t **)data)[0];
-        c->lbs[n].data = ((uint8_t **)data)[1];
-        c->lbs[n].lb = nr;
-        return 1;
-      }
-    }
-    c->lb_num++;
-    tmp = realloc(c->lbs, c->lb_num * sizeof(struct lbudf));
-    /*
-    fprintf(stderr, "realloc lb: %d * %d = %d\n",
-    c->lb_num, sizeof(struct lbudf),
-    c->lb_num * sizeof(struct lbudf));
-    */
-    if(tmp == NULL) {
-      if(c->lbs) free(c->lbs);
-      c->lb_num = 0;
-      return 0;
-    }
-    c->lbs = (struct lbudf *)tmp;
-    c->lbs[n].data_base = ((uint8_t **)data)[0];
-    c->lbs[n].data = ((uint8_t **)data)[1];
-    c->lbs[n].lb = nr;
-    break;
-  case MapCache:
-    for(n = 0; n < c->map_num; n++) {
-      if(c->maps[n].lbn == nr) {
-        /* replace with new data */
-        c->maps[n] = *(struct icbmap *)data;
-        c->maps[n].lbn = nr;
-        return 1;
-      }
-    }
-    c->map_num++;
-    tmp = realloc(c->maps, c->map_num * sizeof(struct icbmap));
-    /*
-    fprintf(stderr, "realloc maps: %d * %d = %d\n",
-      c->map_num, sizeof(struct icbmap),
-      c->map_num * sizeof(struct icbmap));
-    */
-    if(tmp == NULL) {
-      if(c->maps) free(c->maps);
-      c->map_num = 0;
-      return 0;
-    }
-    c->maps = (struct icbmap *)tmp;
-    c->maps[n] = *(struct icbmap *)data;
-    c->maps[n].lbn = nr;
-    break;
-  default:
-    return 0;
-  }
-
-  return 1;
-}
-
-int udf25::DVDUDFCacheLevel(int level)
-{
-  if(level > 0) {
-    level = 1;
-  } else if(level < 0) {
-    return m_udfcache_level;
-  }
-
-  m_udfcache_level = level;
-
-  return level;
-}
-
-void *udf25::GetUDFCacheHandle()
-{
-  return m_udfcache;
-}
-
-void udf25::SetUDFCacheHandle(void *cache)
-{
-  m_udfcache = cache;
-}
-
-int udf25::GetUDFCache(UDFCacheType type, uint32_t nr, void *data)
-{
-  int n;
-  struct udf_cache *c;
-
-  if(DVDUDFCacheLevel(-1) <= 0)
-    return 0;
-
-  c = (struct udf_cache *)GetUDFCacheHandle();
-
-  if(c == NULL)
-    return 0;
-
-  switch(type) {
-  case AVDPCache:
-    if(c->avdp_valid) {
-      *(struct avdp_t *)data = c->avdp;
-      return 1;
-    }
-    break;
-  case PVDCache:
-    if(c->pvd_valid) {
-      *(struct pvd_t *)data = c->pvd;
-      return 1;
-    }
-    break;
-  case PartitionCache:
-    if(c->partition_valid) {
-      *(struct Partition *)data = c->partition;
-      return 1;
-    }
-    break;
-  case RootICBCache:
-    if(c->rooticb_valid) {
-      *(struct AD *)data = c->rooticb;
-      return 1;
-    }
-    break;
-  case LBUDFCache:
-    for(n = 0; n < c->lb_num; n++) {
-      if(c->lbs[n].lb == nr) {
-        *(uint8_t **)data = c->lbs[n].data;
-        return 1;
-      }
-    }
-    break;
-  case MapCache:
-    for(n = 0; n < c->map_num; n++) {
-      if(c->maps[n].lbn == nr) {
-        *(struct icbmap *)data = c->maps[n];
-        return 1;
-      }
-    }
-    break;
-  default:
-    break;
-  }
-
-  return 0;
-}
-
-int udf25::ReadAt( int64_t pos, size_t len, unsigned char *data )
-{
-  if (m_fp->Seek(pos, SEEK_SET) != pos)
-    return -1;
-
-  ssize_t ret = m_fp->Read(data, len);
-  if ( ret > 0 && static_cast<size_t>(ret) < len)
-  {
-    CLog::Log(LOGERROR, "udf25::ReadFile - less data than requested available!" );
-    return (int)ret;
-  }
-  return (int)ret;
-}
-
-int udf25::DVDReadLBUDF( uint32_t lb_number, size_t block_count, unsigned char *data, int encrypted )
-{
-  int ret;
-  size_t  len = block_count * DVD_VIDEO_LB_LEN;
-  int64_t pos = lb_number   * (int64_t)DVD_VIDEO_LB_LEN;
-
-  ret = ReadAt(pos, len, data);
-  if(ret < 0)
-    return ret;
-
-  if((unsigned int)ret < len)
-  {
-    CLog::Log(LOGERROR, "udf25::DVDReadLBUDF -  Block was not complete, setting to wanted %u (got %u)", (unsigned int)len, (unsigned int)ret);
-    memset(&data[ret], 0, len - ret);
-  }
-
-  return len / DVD_VIDEO_LB_LEN;
-}
-
-int udf25::UDFGetAVDP( struct avdp_t *avdp)
-{
-  uint8_t Anchor_base[ DVD_VIDEO_LB_LEN + 2048 ];
-  uint8_t *Anchor = (uint8_t *)(((uintptr_t)Anchor_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum, MVDS_location, MVDS_length;
-  uint16_t TagID;
-  uint32_t lastsector;
-  int terminate;
-  struct avdp_t;
-
-  if(GetUDFCache(AVDPCache, 0, avdp))
-    return 1;
-
-  /* Find Anchor */
-  lastsector = 0;
-  lbnum = 256;   /* Try #1, prime anchor */
-  terminate = 0;
-
-  for(;;) {
-    if( DVDReadLBUDF( lbnum, 1, Anchor, 0 ) > 0 ) {
-      UDFDescriptor( Anchor, &TagID );
-    } else {
-      TagID = 0;
-    }
-    if (TagID != 2) {
-      /* Not an anchor */
-      if( terminate ) return 0; /* Final try failed */
-
-      if( lastsector ) {
-        /* We already found the last sector.  Try #3, alternative
-         * backup anchor.  If that fails, don't try again.
-         */
-        lbnum = lastsector;
-        terminate = 1;
-      } else {
-        //! @todo Find last sector of the disc (this is optional).
-        if( lastsector )
-          /* Try #2, backup anchor */
-          lbnum = lastsector - 256;
-        else
-          /* Unable to find last sector */
-          return 0;
-      }
-    } else
-      /* It's an anchor! We can leave */
-      break;
-  }
-  /* Main volume descriptor */
-  UDFExtentAD( &Anchor[ 16 ], &MVDS_length, &MVDS_location );
-  avdp->mvds.location = MVDS_location;
-  avdp->mvds.length = MVDS_length;
-
-  /* Backup volume descriptor */
-  UDFExtentAD( &Anchor[ 24 ], &MVDS_length, &MVDS_location );
-  avdp->rvds.location = MVDS_location;
-  avdp->rvds.length = MVDS_length;
-
-  SetUDFCache(AVDPCache, 0, avdp);
-
-  return 1;
-}
-
-int udf25::UDFFindPartition( int partnum, struct Partition *part )
-{
-  uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
-  uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum, MVDS_location, MVDS_length;
-  uint16_t TagID;
-  int i, volvalid;
-  struct avdp_t avdp;
-
-  if(!UDFGetAVDP(&avdp))
-    return 0;
-
-  /* Main volume descriptor */
-  MVDS_location = avdp.mvds.location;
-  MVDS_length = avdp.mvds.length;
-
-  part->valid = 0;
-  volvalid = 0;
-  part->VolumeDesc[ 0 ] = '\0';
-  i = 1;
-  do {
-    /* Find Volume Descriptor */
-    lbnum = MVDS_location;
-    do {
-
-      if( DVDReadLBUDF( lbnum++, 1, LogBlock, 0 ) <= 0 )
-        TagID = 0;
-      else
-        UDFDescriptor( LogBlock, &TagID );
-
-      if( ( TagID == 5 ) && ( !part->valid ) ) {
-        /* Partition Descriptor */
-        UDFPartition( LogBlock, &part->Flags, &part->Number,
-                      part->Contents, &part->Start, &part->Length );
-        part->Start_Correction = 0;
-        part->valid = ( partnum == part->Number );
-      } else if( ( TagID == 6 ) && ( !volvalid ) ) {
-        /* Logical Volume Descriptor */
-        if( UDFLogVolume( LogBlock, part->VolumeDesc ) ) {
-          //! @todo sector size wrong!
-        } else
-          volvalid = 1;
-      }
-
-    } while( ( lbnum <= MVDS_location + ( MVDS_length - 1 )
-               / DVD_VIDEO_LB_LEN ) && ( TagID != 8 )
-             && ( ( !part->valid ) || ( !volvalid ) ) );
-
-    if( ( !part->valid) || ( !volvalid ) ) {
-      /* Backup volume descriptor */
-      MVDS_location = avdp.mvds.location;
-      MVDS_length = avdp.mvds.length;
-    }
-  } while( i-- && ( ( !part->valid ) || ( !volvalid ) ) );
-
-  /* Look for a metadata partition */
-  lbnum = part->Start;
-  do {
-    if( DVDReadLBUDF( lbnum++, 1, LogBlock, 0 ) <= 0 )
-      TagID = 0;
-    else
-      UDFDescriptor( LogBlock, &TagID );
-
-    /*
-     * It seems that someone added a FileType of 250, which seems to be
-     * a "redirect" style file entry. If we discover such an entry, we
-     * add on the "location" to partition->Start, and try again.
-     * Who added this? Is there any official guide somewhere?
-     * 2008/09/17 lundman
-     * Should we handle 261(250) as well? FileEntry+redirect
-     */
-    if( TagID == 266 ) {
-      struct FileAD File;
-      File.Partition       = part->Number;
-      File.Partition_Start = part->Start;
-
-      UDFExtFileEntry( LogBlock, &File );
-      if (File.Type == 250) {
-        part->Start  += File.AD_chain[0].Location;
-        // we need to remember this correction because read positions are relative to the non-indirected partition start
-        part->Start_Correction = File.AD_chain[0].Location;
-        part->Length  = File.AD_chain[0].Length;
-        break;
-      }
-    }
-
-  } while( ( lbnum < part->Start + part->Length )
-          && ( TagID != 8 ) && ( TagID != 256 ) );
-
-  /* We only care for the partition, not the volume */
-  return part->valid;
-}
-
-int udf25::UDFMapICB( struct AD ICB, struct Partition *partition, struct FileAD *File )
-{
-  uint8_t LogBlock_base[DVD_VIDEO_LB_LEN + 2048];
-  uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum;
-  uint16_t TagID;
-  struct icbmap tmpmap;
-
-  lbnum = partition->Start + ICB.Location;
-  tmpmap.lbn = lbnum;
-  if(GetUDFCache(MapCache, lbnum, &tmpmap)) {
-    memcpy(File, &tmpmap.file, sizeof(tmpmap.file));
-    return 1;
-  }
-
-  memset(File, 0, sizeof(*File));
-  File->Partition       = partition->Number;
-  File->Partition_Start = partition->Start;
-  File->Partition_Start_Correction = partition->Start_Correction;
-
-  do {
-    if( DVDReadLBUDF( lbnum++, 1, LogBlock, 0 ) <= 0 )
-      TagID = 0;
-    else
-      UDFDescriptor( LogBlock, &TagID );
-
-    if( TagID == 261 ) {
-      UDFFileEntry( LogBlock, File );
-      break;
-    };
-
-    /* ExtendedFileInfo */
-    if( TagID == 266 ) {
-      UDFExtFileEntry( LogBlock, File );
-      break;
-    }
-
-
-  } while( lbnum <= partition->Start + ICB.Location + ( ICB.Length - 1 )
-             / DVD_VIDEO_LB_LEN );
-
-
-  if(File->Type) {
-
-    /* check if ad chain continues elsewhere */
-    while(File->num_AD && File->AD_chain[File->num_AD-1].Flags == 3) {
-      struct AD* ad = &File->AD_chain[File->num_AD-1];
-
-      /* remove the forward pointer from the list */
-      File->num_AD--;
-
-      if( DVDReadLBUDF( File->Partition_Start + ad->Location, 1, LogBlock, 0 ) <= 0 )
-        TagID = 0;
-      else
-        UDFDescriptor( LogBlock, &TagID );
-
-      if( TagID == 258 ) {
-        /* add all additional entries */
-        UDFAdEntry( LogBlock, File );
-      } else {
-        return 0;
-      }
-    }
-
-    memcpy(&tmpmap.file, File, sizeof(tmpmap.file));
-    SetUDFCache(MapCache, tmpmap.lbn, &tmpmap);
-
-    return 1;
-  }
-
-  return 0;
-}
-
-int udf25::UDFScanDir(const struct FileAD& Dir, char *FileName, struct Partition *partition, struct AD *FileICB, int cache_file_info)
-{
-  char filename[ MAX_UDF_FILE_NAME_LEN ];
-  uint8_t directory_base[ 2 * DVD_VIDEO_LB_LEN + 2048];
-  uint8_t *directory = (uint8_t *)(((uintptr_t)directory_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum;
-  uint16_t TagID;
-  uint8_t filechar;
-  unsigned int p;
-  uint8_t *cached_dir_base = NULL, *cached_dir;
-  uint32_t dir_lba;
-  struct AD tmpICB;
-  int found = 0;
-  int in_cache = 0;
-
-  /* Scan dir for ICB of file */
-  lbnum = partition->Start + Dir.AD_chain[0].Location;
-
-  if(DVDUDFCacheLevel(-1) > 0) {
-    /* caching */
-
-    if(!GetUDFCache(LBUDFCache, lbnum, &cached_dir)) {
-      dir_lba = (Dir.AD_chain[0].Length + DVD_VIDEO_LB_LEN) / DVD_VIDEO_LB_LEN;
-      if((cached_dir_base = (uint8_t *)malloc(dir_lba * DVD_VIDEO_LB_LEN + 2048)) == NULL)
-        return 0;
-      cached_dir = (uint8_t *)(((uintptr_t)cached_dir_base & ~((uintptr_t)2047)) + 2048);
-      if( DVDReadLBUDF( lbnum, dir_lba, cached_dir, 0) <= 0 ) {
-        free(cached_dir_base);
-        cached_dir_base = NULL;
-        cached_dir = NULL;
-      }
-      /*
-      if(cached_dir) {
-        fprintf(stderr, "malloc dir: %d\n",  dir_lba * DVD_VIDEO_LB_LEN);
-      }
-      */
-      {
-        uint8_t *data[2];
-        data[0] = cached_dir_base;
-        data[1] = cached_dir;
-        SetUDFCache(LBUDFCache, lbnum, data);
-      }
-    } else
-      in_cache = 1;
-
-    if(cached_dir == NULL)
-      return 0;
-
-    p = 0;
-
-    while( p < Dir.AD_chain[0].Length ) {  /* Assuming dirs don't use chains? */
-      UDFDescriptor( &cached_dir[ p ], &TagID );
-      if( TagID == 257 ) {
-        p += UDFFileIdentifier( &cached_dir[ p ], &filechar,
-                                filename, &tmpICB );
-        if(cache_file_info && !in_cache) {
-          struct FileAD tmpFile;
-
-          memset(&tmpFile, 0, sizeof(tmpFile));
-
-          if( !strcasecmp( FileName, filename ) ) {
-            memcpy(FileICB, &tmpICB, sizeof(tmpICB));
-            found = 1;
-          }
-          UDFMapICB(tmpICB, partition, &tmpFile);
-        } else {
-          if( !strcasecmp( FileName, filename ) ) {
-            memcpy(FileICB, &tmpICB, sizeof(tmpICB));
-            return 1;
-          }
-        }
-      } else {
-        if(cache_file_info && (!in_cache) && found)
-          return 1;
-        return 0;
-      }
-    }
-    if(cache_file_info && (!in_cache) && found)
-      return 1;
-    return 0;
-  }
-
-  if( DVDReadLBUDF( lbnum, 2, directory, 0 ) <= 0 )
-    return 0;
-
-  p = 0;
-  uint32_t l = Dir.AD_chain[0].Length;
-  while (p < l) {
-    if( p > DVD_VIDEO_LB_LEN ) {
-      ++lbnum;
-      p -= DVD_VIDEO_LB_LEN;
-      l -= DVD_VIDEO_LB_LEN;
-      if( DVDReadLBUDF( lbnum, 2, directory, 0 ) <= 0 ) {
-        return 0;
-      }
-    }
-    UDFDescriptor( &directory[ p ], &TagID );
-    if( TagID == 257 ) {
-      p += UDFFileIdentifier( &directory[ p ], &filechar,
-                              filename, FileICB );
-      if( !strcasecmp( FileName, filename ) ) {
-        return 1;
-      }
-    } else
-      return 0;
-  }
-
-  return 0;
-}
-
-udf25::udf25( )
-{
-  m_fp = NULL;
-  m_udfcache_level = 1;
-  m_udfcache = NULL;
-}
-
-udf25::~udf25( )
-{
-  delete m_fp;
-
-  struct udf_cache * cache = (struct udf_cache *) m_udfcache;
-
-  if (!cache)
-    return;
-
-  if (cache->lbs)
-  {
-    for (int n = 0; n < cache->lb_num; n++)
-    {
-      free(cache->lbs[n].data_base);
-    }
-    free(cache->lbs);
-  }
-
-  free(cache->maps);
-  free(cache);
-}
-
-UDF_FILE udf25::UDFFindFile( const char* filename, uint64_t *filesize )
-{
-  uint8_t LogBlock_base[ DVD_VIDEO_LB_LEN + 2048 ];
-  uint8_t *LogBlock = (uint8_t *)(((uintptr_t)LogBlock_base & ~((uintptr_t)2047)) + 2048);
-  uint32_t lbnum;
-  uint16_t TagID;
-  struct Partition partition;
-  struct AD RootICB, ICB;
-  struct FileAD File;
-  char tokenline[ MAX_UDF_FILE_NAME_LEN ];
-  char *token;
-  struct FileAD *result;
-
-  *filesize = 0;
-  tokenline[0] = '\0';
-  strncat(tokenline, filename, MAX_UDF_FILE_NAME_LEN - 1);
-  memset(&ICB, 0, sizeof(ICB));
-  memset(&File, 0, sizeof(File));
-
-  if(!(GetUDFCache(PartitionCache, 0, &partition) &&
-       GetUDFCache(RootICBCache, 0, &RootICB))) {
-    /* Find partition, 0 is the standard location for DVD Video.*/
-    if( !UDFFindPartition(0, &partition ) ) return 0;
-    SetUDFCache(PartitionCache, 0, &partition);
-
-    /* Find root dir ICB */
-    lbnum = partition.Start;
-    do {
-      if( DVDReadLBUDF( lbnum++, 1, LogBlock, 0 ) <= 0 )
-        TagID = 0;
-      else
-        UDFDescriptor( LogBlock, &TagID );
-
-      /* File Set Descriptor */
-      if( TagID == 256 )  /* File Set Descriptor */
-        UDFLongAD( &LogBlock[ 400 ], &RootICB );
-    } while( ( lbnum < partition.Start + partition.Length )
-             && ( TagID != 8 ) && ( TagID != 256 ) );
-
-    /* Sanity checks. */
-    if( TagID != 256 )
-      return NULL;
-    /* This following test will fail under UDF2.50 images, as it is no longer
-     * valid */
-    /*if( RootICB.Partition != 0 )
-      return 0;*/
-    SetUDFCache(RootICBCache, 0, &RootICB);
-  }
-
-  /* Find root dir */
-  if( !UDFMapICB( RootICB, &partition, &File ) )
-    return NULL;
-  if( File.Type != 4 )
-    return NULL;  /* Root dir should be dir */
-  {
-    int cache_file_info = 0;
-    /* Tokenize filepath */
-    token = strtok(tokenline, "/");
-
-    while( token != NULL ) {
-      if( !UDFScanDir( File, token, &partition, &ICB,
-                       cache_file_info))
-        return NULL;
-      if( !UDFMapICB( ICB, &partition, &File ) )
-        return NULL;
-      if(!strcmp(token, "index.bdmv"))
-        cache_file_info = 1;
-      token = strtok( NULL, "/" );
-    }
-  }
-
-  /* Sanity check. */
-  if( File.AD_chain[0].Partition != 0 )
-    return 0;
-  *filesize = File.Length;
-  /* Hack to not return partition.Start for empty files. */
-  if( !File.AD_chain[0].Location )
-    return NULL;
-
-  /* Allocate a new UDF_FILE and return it. */
-  result = (struct FileAD *) malloc(sizeof(*result));
-  if (!result) return NULL;
-
-  memcpy(result, &File, sizeof(*result));
-  return result;
-}
-
-bool udf25::Open(const char *isofile)
-{
-  m_fp = new CFile();
-
-  if(!m_fp->Open(isofile))
-  {
-    CLog::Log(LOGERROR,"file_open - Could not open input");
-    delete m_fp;
-    m_fp = NULL;
-    return false;
-  }
-  return true;
-}
-
-HANDLE udf25::OpenFile( const char* filename )
-{
-  uint64_t filesize;
-  UDF_FILE file = NULL;
-  BD_FILE bdfile = NULL;
-
-  if(!m_fp)
-    return INVALID_HANDLE_VALUE;
-
-  file = UDFFindFile(filename, &filesize);
-  if(!file)
-    return INVALID_HANDLE_VALUE;
-
-  bdfile = (BD_FILE)calloc(1, sizeof(*bdfile));
-
-  bdfile->file     = file;
-  bdfile->filesize = filesize;
-  return reinterpret_cast<HANDLE>(bdfile);
-}
-
-
-long udf25::ReadFile(HANDLE hFile, unsigned char *pBuffer, long lSize)
-{
-  BD_FILE bdfile = (BD_FILE)hFile;
-  long    len_origin;
-  uint64_t pos;
-  uint32_t len;
-  int      ret;
-
-  /* Check arguments. */
-  if( bdfile == NULL || pBuffer == NULL )
-    return -1;
-
-  len_origin = lSize;
-  while(lSize > 0)
-  {
-    len = UDFFilePos(bdfile->file, bdfile->seek_pos, &pos);
-    if(len == 0)
-      break;
-
-    // correct for partition indirection if applicable
-    pos -= bdfile->file->Partition_Start_Correction * DVD_VIDEO_LB_LEN;
-
-    if((uint32_t)lSize < len)
-      len = lSize;
-
-    ret = ReadAt(pos, len, pBuffer);
-    if(ret < 0)
-    {
-      CLog::Log(LOGERROR, "udf25::ReadFile - error during read" );
-      return ret;
-    }
-
-    if(ret == 0)
-      break;
-
-    bdfile->seek_pos += ret;
-    pBuffer          += ret;
-    lSize            -= ret;
-  }
-
-  return len_origin - lSize;
-}
-
-void udf25::CloseFile(HANDLE hFile)
-{
-  if(hFile == INVALID_HANDLE_VALUE)
-    return;
-
-  BD_FILE bdfile = (BD_FILE)hFile;
-  if(bdfile)
-  {
-    free(bdfile->file);
-    free(bdfile);
-  }
-}
-
-int64_t udf25::Seek(HANDLE hFile, int64_t lOffset, int whence)
-{
-  BD_FILE bdfile = (BD_FILE)hFile;
-
-  if(bdfile == NULL)
-    return -1;
-
-  int64_t seek_pos = bdfile->seek_pos;
-  switch (whence)
-  {
-  case SEEK_SET:
-    // cur = pos
-    bdfile->seek_pos = lOffset;
-    break;
-
-  case SEEK_CUR:
-    // cur += pos
-    bdfile->seek_pos += lOffset;
-    break;
-  case SEEK_END:
-    // end += pos
-    bdfile->seek_pos = bdfile->filesize + lOffset;
-    break;
-  }
-
-  if (bdfile->seek_pos > bdfile->filesize)
-  {
-    bdfile->seek_pos = seek_pos;
-    return bdfile->seek_pos;
-  }
-
-  return bdfile->seek_pos;
-}
-
-int64_t udf25::GetFileSize(HANDLE hFile)
-{
-  BD_FILE bdfile = (BD_FILE)hFile;
-
-  if(bdfile == NULL)
-    return -1;
-
-  return bdfile->filesize;
-}
-
-int64_t udf25::GetFilePosition(HANDLE hFile)
-{
-  BD_FILE bdfile = (BD_FILE)hFile;
-
-  if(bdfile == NULL)
-    return -1;
-
-  return bdfile->seek_pos;
-}
-
-udf_dir_t *udf25::OpenDir( const char *subdir )
-{
-  udf_dir_t *result;
-  BD_FILE bd_file;
-
-  bd_file = (BD_FILE)OpenFile(subdir);
-
-  if (bd_file == (BD_FILE)INVALID_HANDLE_VALUE)
-    return NULL;
-
-  result = (udf_dir_t *)calloc(1, sizeof(udf_dir_t));
-  if (!result) {
-    CloseFile(reinterpret_cast<HANDLE>(bd_file));
-    return NULL;
-  }
-
-  result->dir_location = UDFFileBlockPos(bd_file->file, 0);
-  result->dir_current  = UDFFileBlockPos(bd_file->file, 0);
-  result->dir_length   = (uint32_t) bd_file->filesize;
-  CloseFile(reinterpret_cast<HANDLE>(bd_file));
-
-  return result;
-}
-
-udf_dirent_t *udf25::ReadDir( udf_dir_t *dirp )
-{
-  if (!UDFScanDirX(dirp)) {
-    dirp->current_p = 0;
-    dirp->dir_current = dirp->dir_location; // this is a rewind, wanted?
-    return NULL;
-  }
-
-  return &dirp->entry;
-}
-
-int udf25::CloseDir( udf_dir_t *dirp )
-{
-  if (!dirp) return 0;
-
-  free(dirp);
-
-  CloseFile(NULL);
-
-  return 0;
-}
diff --git a/xbmc/filesystem/udf25.h b/xbmc/filesystem/udf25.h
deleted file mode 100644
index 31727abb77a3..000000000000
--- a/xbmc/filesystem/udf25.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- *  Copyright (C) 2010 Team Boxee
- *      http://www.boxee.tv
- *
- *  Copyright (C) 2010-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#pragma once
-
-#include "File.h"
-
-/**
- * The length of one Logical Block of a DVD.
- */
-#define DVD_VIDEO_LB_LEN 2048
-
-/**
- * Maximum length of filenames allowed in UDF.
- */
-#define MAX_UDF_FILE_NAME_LEN 2048
-
-struct Partition {
-  int valid;
-  char VolumeDesc[128];
-  uint16_t Flags;
-  uint16_t Number;
-  char Contents[32];
-  uint32_t AccessType;
-  uint32_t Start;
-  uint32_t Length;
-  uint32_t Start_Correction;
-};
-
-struct AD {
-  uint32_t Location;
-  uint32_t Length;
-  uint8_t  Flags;
-  uint16_t Partition;
-};
-
-/* Previously dvdread would assume files only had one AD chain, and since they
- * are 1GB or less, this is most probably true. However, now we handle chains
- * for large files. ECMA_167 does not specify the maximum number of chains, is
- * it as many as can fit in a 2048 block (minus ID 266 size), or some other
- * limit. For now, I have assumed that;
- * a 4.4GB file uses 5 AD chains. A BluRay disk can store 50GB of data, so the
- * largest file should be 50 GB. So the maximum number of chains should be
- * around 62.
- *
- * However, with AD chain extensions there has been examples of chains up to
- * around 1600 entries.
- */
-
-#define UDF_MAX_AD_CHAINS 2000
-
-struct FileAD {
-    uint64_t Length;
-    uint32_t num_AD;
-    uint16_t Partition;
-    uint32_t Partition_Start;
-    uint32_t Partition_Start_Correction;
-    uint8_t  Type;
-    uint16_t Flags;
-    struct AD AD_chain[UDF_MAX_AD_CHAINS];
-};
-
-struct extent_ad {
-  uint32_t location;
-  uint32_t length;
-};
-
-struct avdp_t {
-  struct extent_ad mvds;
-  struct extent_ad rvds;
-};
-
-struct pvd_t {
-  uint8_t VolumeIdentifier[32];
-  uint8_t VolumeSetIdentifier[128];
-};
-
-struct lbudf {
-  uint32_t lb;
-  uint8_t *data;
-  /* needed for proper freeing */
-  uint8_t *data_base;
-};
-
-struct icbmap {
-  uint32_t lbn;
-  struct FileAD  file;
-};
-
-struct udf_cache {
-  int avdp_valid;
-  struct avdp_t avdp;
-  int pvd_valid;
-  struct pvd_t pvd;
-  int partition_valid;
-  struct Partition partition;
-  int rooticb_valid;
-  struct AD rooticb;
-  int lb_num;
-  struct lbudf *lbs;
-  int map_num;
-  struct icbmap *maps;
-};
-
-typedef enum {
-  PartitionCache, RootICBCache, LBUDFCache, MapCache, AVDPCache, PVDCache
-} UDFCacheType;
-
-/*
- * DVDReaddir entry types.
- */
-typedef enum {
-  DVD_DT_UNKNOWN = 0,
-  DVD_DT_FIFO,
-  DVD_DT_CHR,
-  DVD_DT_DIR,
-  DVD_DT_BLK,
-  DVD_DT_REG,
-  DVD_DT_LNK,
-  DVD_DT_SOCK,
-  DVD_DT_WHT
-} udf_dir_type_t;
-
-/*
- * DVDReaddir structure.
- * Extended a little from POSIX to also return filesize.
- */
-typedef struct {
-  unsigned char  d_name[MAX_UDF_FILE_NAME_LEN];
-  // "Shall not exceed 1023; Ecma-167 page 123"
-  udf_dir_type_t d_type;       // DT_REG, DT_DIR
-  unsigned int   d_namlen;
-  uint64_t       d_filesize;
-} udf_dirent_t;
-
-
-/*
- * DVDOpendir DIR* structure
- */
-typedef struct {
-  uint32_t dir_location;
-  uint32_t dir_length;
-  uint32_t dir_current;   // Separate to _location should we one day want to
-                          // implement dir_rewind()
-  unsigned int current_p; // Internal implementation specific. UDFScanDirX
-  udf_dirent_t entry;
-} udf_dir_t;
-
-
-
-typedef struct FileAD *UDF_FILE;
-
-typedef struct _BD_FILE
-{
-  UDF_FILE file;
-  uint64_t seek_pos;  // in bytes
-  uint64_t filesize;  // in bytes
-
-} *BD_FILE;
-
-
-class udf25
-{
-
-public:
-  udf25( );
-  virtual ~udf25( );
-
-  DWORD SetFilePointer(HANDLE hFile, long lDistanceToMove, long* lpDistanceToMoveHigh, DWORD dwMoveMethod );
-  int64_t GetFileSize(HANDLE hFile);
-  int64_t GetFilePosition(HANDLE hFile);
-  int64_t Seek(HANDLE hFile, int64_t lOffset, int whence);
-  bool   Open(const char *isofile);
-  HANDLE OpenFile( const char* filename );
-  long ReadFile(HANDLE fd, unsigned char *pBuffer, long lSize);
-  void CloseFile(HANDLE hFile);
-
-  udf_dir_t *OpenDir( const char *subdir );
-  udf_dirent_t *ReadDir( udf_dir_t *dirp );
-  int CloseDir( udf_dir_t *dirp );
-
-  void Reset();
-  void Scan();
-  bool IsScanned();
-
-private:
-  UDF_FILE UDFFindFile( const char* filename, uint64_t *filesize );
-  int UDFScanDirX( udf_dir_t *dirp );
-  int DVDUDFCacheLevel(int level);
-  void* GetUDFCacheHandle();
-  void SetUDFCacheHandle(void *cache);
-  int GetUDFCache(UDFCacheType type,uint32_t nr, void *data);
-  int UDFFindPartition( int partnum, struct Partition *part );
-  int UDFGetAVDP( struct avdp_t *avdp);
-  int DVDReadLBUDF( uint32_t lb_number, size_t block_count, unsigned char *data, int encrypted );
-  int ReadAt( int64_t pos, size_t len, unsigned char *data );
-  int UDFMapICB( struct AD ICB, struct Partition *partition, struct FileAD *File );
-  int UDFScanDir( const struct FileAD& Dir, char *FileName, struct Partition *partition, struct AD *FileICB, int cache_file_info);
-  int SetUDFCache(UDFCacheType type, uint32_t nr, void *data);
-protected:
-    /* Filesystem cache */
-  int m_udfcache_level; /* 0 - turned off, 1 - on */
-  void *m_udfcache;
-  XFILE::CFile* m_fp;
-};
-
