From 38ec53e767f4ad465856b0af198aa4dbf1b878cc Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Sun, 14 Jun 2020 16:51:43 +0100
Subject: [PATCH] Better artist discography matching to albums in library by
 using Musicbrainz release group id (providing scraper provides it)

---
 xbmc/addons/Scraper.cpp      |   7 ++-
 xbmc/music/Artist.cpp        |  31 ++++------
 xbmc/music/Artist.h          |  10 ++-
 xbmc/music/MusicDatabase.cpp | 116 ++++++++++++++++++++++++-----------
 xbmc/music/MusicDatabase.h   |   2 +-
 5 files changed, 108 insertions(+), 58 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index d585d0e25614..958d189259d8 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -796,8 +796,11 @@ void DetailsFromFileItem<CArtist>(const CFileItem &item, CArtist &artist)
   {
     std::stringstream prefix;
     prefix << "artist.album" << i + 1;
-    artist.discography.emplace_back(FromString(item, prefix.str() + ".title"),
-                                    FromString(item, prefix.str() + ".year"));
+    CDiscoAlbum discoAlbum;
+    discoAlbum.strAlbum = FromString(item, prefix.str() + ".title");
+    discoAlbum.strYear = FromString(item, prefix.str() + ".year");
+    discoAlbum.strReleaseGroupMBID = FromString(item, prefix.str() + ".musicbrainzreleasegroupid");
+    artist.discography.emplace_back(discoAlbum);
   }
 
   int nThumbs = item.GetProperty("artist.thumbs").asInteger32();
diff --git a/xbmc/music/Artist.cpp b/xbmc/music/Artist.cpp
index 3b692a941f57..4a787cf8124e 100644
--- a/xbmc/music/Artist.cpp
+++ b/xbmc/music/Artist.cpp
@@ -118,17 +118,17 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
 
   // Discography
   const TiXmlElement* node = artist->FirstChildElement("album");
+  if (node)
+    discography.clear();
   while (node)
   {
-    const TiXmlNode* title = node->FirstChild("title");
-    if (title && title->FirstChild())
+    if (node->FirstChild())
     {
-      std::string strTitle = title->FirstChild()->Value();
-      std::string strYear;
-      const TiXmlNode* year = node->FirstChild("year");
-      if (year && year->FirstChild())
-        strYear = year->FirstChild()->Value();
-      discography.emplace_back(strTitle, strYear);
+      CDiscoAlbum album;
+      XMLUtils::GetString(node, "title", album.strAlbum);
+      XMLUtils::GetString(node, "year", album.strYear);
+      XMLUtils::GetString(node, "musicbrainzreleasegroupid", album.strReleaseGroupMBID);
+      discography.push_back(album);
     }
     node = node->NextSiblingElement("album");
   }
@@ -215,16 +215,11 @@ bool CArtist::Save(TiXmlNode *node, const std::string &tag, const std::string& s
   for (const auto& it : discography)
   {
     // add a <album> tag
-    TiXmlElement cast("album");
-    TiXmlNode *node = artist->InsertEndChild(cast);
-    TiXmlElement title("title");
-    TiXmlNode *titleNode = node->InsertEndChild(title);
-    TiXmlText name(it.first);
-    titleNode->InsertEndChild(name);
-    TiXmlElement year("year");
-    TiXmlNode *yearNode = node->InsertEndChild(year);
-    TiXmlText name2(it.second);
-    yearNode->InsertEndChild(name2);
+    TiXmlElement discoElement("album");
+    TiXmlNode* node = artist->InsertEndChild(discoElement);
+    XMLUtils::SetString(node, "title", it.strAlbum);
+    XMLUtils::SetString(node, "year", it.strYear);
+    XMLUtils::SetString(node, "musicbrainzreleasegroupid", it.strReleaseGroupMBID);
   }
 
   return true;
diff --git a/xbmc/music/Artist.h b/xbmc/music/Artist.h
index d5e71186a4a8..9bb617bdd6b8 100644
--- a/xbmc/music/Artist.h
+++ b/xbmc/music/Artist.h
@@ -22,6 +22,14 @@ class TiXmlNode;
 class CAlbum;
 class CMusicDatabase;
 
+class CDiscoAlbum
+{
+public:
+  std::string strAlbum;
+  std::string strYear;
+  std::string strReleaseGroupMBID;
+};
+
 class CArtist
 {
 public:
@@ -105,7 +113,7 @@ class CArtist
   CScraperUrl thumbURL; // Data for available thumbs
   CFanart fanart;  // Data for available fanart, urls etc.
   std::map<std::string, std::string> art;  // Current artwork - thumb, fanart etc.
-  std::vector<std::pair<std::string,std::string> > discography;
+  std::vector<CDiscoAlbum> discography;
   CDateTime dateAdded; // From related file creation or modification times, or when (re-)scanned
   CDateTime dateUpdated; // Time db record Last modified
   CDateTime dateNew;  // Time db record created
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index ac8266c30511..338c8df5e746 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -212,7 +212,8 @@ void CMusicDatabase::CreateTables()
   m_pDS->exec("CREATE TABLE infosetting (idSetting INTEGER PRIMARY KEY, strScraperPath TEXT, strSettings TEXT)");
 
   CLog::Log(LOGINFO, "create discography table");
-  m_pDS->exec("CREATE TABLE discography (idArtist integer, strAlbum text, strYear text)");
+  m_pDS->exec("CREATE TABLE discography (idArtist integer, strAlbum text, strYear text, "
+              "strReleaseGroupMBID TEXT)");
 
   CLog::Log(LOGINFO, "create art table");
   m_pDS->exec("CREATE TABLE art(art_id INTEGER PRIMARY KEY, media_id INTEGER, media_type TEXT, type TEXT, url TEXT)");
@@ -1604,7 +1605,7 @@ bool CMusicDatabase::UpdateArtist(const CArtist& artist)
   DeleteArtistDiscography(artist.idArtist);
   for (const auto &disc : artist.discography)
   {
-    AddArtistDiscography(artist.idArtist, disc.first, disc.second);
+    AddArtistDiscography(artist.idArtist, disc);
   }
 
   // Set current artwork (held in art table)
@@ -1871,8 +1872,10 @@ bool CMusicDatabase::GetArtist(int idArtist, CArtist &artist, bool fetchAll /* =
       while (!m_pDS->eof())
       {
         const dbiplus::sql_record* const record = m_pDS->get_sql_record();
-
-        artist.discography.emplace_back(record->at(discographyOffset + 1).get_asString(), record->at(discographyOffset + 2).get_asString());
+        CDiscoAlbum discoAlbum;
+        discoAlbum.strAlbum = record->at(discographyOffset + 1).get_asString();
+        discoAlbum.strYear = record->at(discographyOffset + 2).get_asString();
+        discoAlbum.strReleaseGroupMBID = record->at(discographyOffset + 3).get_asString();
         m_pDS->next();
       }
     }
@@ -1938,12 +1941,13 @@ bool CMusicDatabase::ClearArtistLastScrapedTime(int idArtist)
   return ExecuteQuery(strSQL);
 }
 
-int CMusicDatabase::AddArtistDiscography(int idArtist, const std::string& strAlbum, const std::string& strYear)
+int CMusicDatabase::AddArtistDiscography(int idArtist, const CDiscoAlbum& discoAlbum)
 {
-  std::string strSQL=PrepareSQL("INSERT INTO discography (idArtist, strAlbum, strYear) values(%i, '%s', '%s')",
-                               idArtist,
-                               strAlbum.c_str(),
-                               strYear.c_str());
+  std::string strSQL = PrepareSQL("INSERT INTO discography "
+                                  "(idArtist, strAlbum, strYear, strReleaseGroupMBID) "
+                                  "VALUES(%i, '%s', '%s', '%s')",
+                                  idArtist, discoAlbum.strAlbum.c_str(), discoAlbum.strYear.c_str(),
+                                  discoAlbum.strReleaseGroupMBID.c_str());
   return ExecuteQuery(strSQL);
 }
 
@@ -1962,19 +1966,64 @@ bool CMusicDatabase::GetArtistDiscography(int idArtist, CFileItemList& items)
     if (nullptr == m_pDS)
       return false;
 
-    // Combine entries from discography and album tables
-    // When title in both, album entry will be before disco entry
+    /* Combine entries from discography and album tables
+       Can not use CREATE TEMPORARY TABLE as MySQL does not support updates of table using
+       correlated subqueries to a temp table. An updatable join to temp table would work in MySQL
+       but SQLite not support updatable joins.
+    */
+    m_pDS->exec("CREATE TABLE tempDisco "
+                "(strAlbum TEXT, iYear INTEGER, mbid TEXT, idAlbum INTEGER)");
+
     std::string strSQL;
-    strSQL = PrepareSQL("SELECT strAlbum, "
-      "CAST(discography.strYear AS INTEGER) AS iYear, -1 AS idAlbum "
-      "FROM discography "
-      "WHERE discography.idArtist = %i "
-      "UNION "
-      "SELECT strAlbum, CAST(strReleaseDate AS INTEGER) AS iYear, album.idAlbum "
-      "FROM album JOIN album_artist ON album_artist.idAlbum = album.idAlbum "
-      "WHERE album_artist.idArtist = %i "
-      "ORDER BY iYear, strAlbum, idAlbum DESC",
-      idArtist, idArtist);
+    strSQL = PrepareSQL("INSERT INTO tempDisco(strAlbum, iYear, mbid, idAlbum) "
+                        "SELECT strAlbum, CAST(discography.strYear AS INTEGER) AS iYear, "
+                        "strReleaseGroupMBID, NULL "
+                        "FROM discography WHERE idArtist = %i",
+                        idArtist);
+    m_pDS->exec(strSQL);
+
+    // Match albums on release group mbid, if multi-releases then first used
+    strSQL = "UPDATE tempDisco SET idAlbum = (SELECT album.idAlbum FROM album "
+             "WHERE album.strReleaseGroupMBID = tempDisco.mbid "
+             "AND album.strReleaseGroupMBID IS NOT NULL)";
+    m_pDS->exec(strSQL);
+    // Match remaining to albums by artist on title and year
+    strSQL = PrepareSQL("UPDATE tempDisco SET idAlbum = (SELECT album.idAlbum FROM album "
+                        "JOIN album_artist ON album_artist.idAlbum = album.idAlbum "
+                        "WHERE album_artist.idArtist = %i "
+                        "AND NOT EXISTS(SELECT 1 FROM tempDisco AS td "
+                        "WHERE td.idAlbum = album.idAlbum) "
+                        "AND CAST(strOrigReleaseDate AS INTEGER) = tempDisco.iYear "
+                        "AND album.strAlbum = tempDisco.strAlbum) "
+                        "WHERE tempDisco.idAlbum is NULL",
+                        idArtist);
+    m_pDS->exec(strSQL);
+    // Match remaining to albums by artist on title only
+    strSQL = PrepareSQL("UPDATE tempDisco SET idAlbum = (SELECT album.idAlbum FROM album "
+                        "JOIN album_artist ON album_artist.idAlbum = album.idAlbum "
+                        "WHERE album_artist.idArtist = %i "
+                        "AND NOT EXISTS(SELECT 1 FROM tempDisco AS td "
+                        "WHERE td.idAlbum = album.idAlbum) "
+                        "AND album.strAlbum = tempDisco.strAlbum) "
+                        "WHERE tempDisco.idAlbum is NULL",
+                        idArtist);
+    m_pDS->exec(strSQL);
+    // Use year from album table, when matched by name only it could be different
+    strSQL = PrepareSQL("UPDATE tempDisco "
+                        "SET iYear = (SELECT CAST(album.strOrigReleaseDate AS INTEGER) FROM album "
+                        "WHERE album.idAlbum = tempDisco.idAlbum) "
+                        "WHERE tempDisco.idAlbum > 0");
+    m_pDS->exec(strSQL);
+
+    // Combine distinctly with albums by artist that are not in discography
+    strSQL =
+        PrepareSQL("SELECT strAlbum, iYear, idAlbum FROM tempDisco "
+                   "UNION "
+                   "SELECT strAlbum, CAST(strOrigReleaseDate AS INTEGER) AS iYear, album.idAlbum "
+                   "FROM album JOIN album_artist ON album_artist.idAlbum = album.idAlbum "
+                   "WHERE album_artist.idArtist = %i "
+                   "ORDER BY iYear, strAlbum, idAlbum",
+                   idArtist);
 
     if (!m_pDS->query(strSQL))
       return false;
@@ -1985,40 +2034,31 @@ bool CMusicDatabase::GetArtistDiscography(int idArtist, CFileItemList& items)
       return true;
     }
 
-    std::string strAlbum;
-    std::string strLastAlbum;
-    int iLastID = -1;
     while (!m_pDS->eof())
     {
       int idAlbum = m_pDS->fv("idAlbum").get_asInt();
-      strAlbum = m_pDS->fv("strAlbum").get_asString();
+      if (idAlbum == 0)
+        idAlbum = -1;
+      std::string strAlbum = m_pDS->fv("strAlbum").get_asString();
       if (!strAlbum.empty())
       {
-        if (strAlbum.compare(strLastAlbum) != 0)
-        { // Save new title (from album or discography)
           CFileItemPtr pItem(new CFileItem(strAlbum));
           pItem->SetLabel2(m_pDS->fv("iYear").get_asString());
           pItem->GetMusicInfoTag()->SetDatabaseId(idAlbum, MediaTypeAlbum);
-
           items.Add(pItem);
-          strLastAlbum = strAlbum;
-          iLastID = idAlbum;
-        }
-        else if (idAlbum > 0 && iLastID < 0)
-        { // Amend previously saved discography item to set album ID
-          items[items.Size() - 1]->GetMusicInfoTag()->SetDatabaseId(idAlbum, MediaTypeAlbum);
-        }
       }
       m_pDS->next();
     }
 
     // cleanup
     m_pDS->close();
+    m_pDS->exec("DROP TABLE tempDisco");
 
     return true;
   }
   catch (...)
   {
+    m_pDS->exec("DROP TABLE tempDisco");
     CLog::Log(LOGERROR, "%s failed", __FUNCTION__);
   }
   return false;
@@ -8452,6 +8492,10 @@ void CMusicDatabase::UpdateTables(int version)
     m_pDS->exec(PrepareSQL("UPDATE artist SET dateNew = '%s'", strUTCNow.c_str()));
     m_pDS->exec("UPDATE artist SET dateModified = dateNew");
   }
+  if (version < 79)
+  {
+    m_pDS->exec("ALTER TABLE discography ADD strReleaseGroupMBID TEXT");
+  }
 
   // Set the verion of tag scanning required.
   // Not every schema change requires the tags to be rescanned, set to the highest schema version
@@ -8473,7 +8517,7 @@ void CMusicDatabase::UpdateTables(int version)
 
 int CMusicDatabase::GetSchemaVersion() const
 {
-  return 78;
+  return 79;
 }
 
 int CMusicDatabase::GetMusicNeedsTagScan()
diff --git a/xbmc/music/MusicDatabase.h b/xbmc/music/MusicDatabase.h
index 8fada1a898da..260cee53330e 100644
--- a/xbmc/music/MusicDatabase.h
+++ b/xbmc/music/MusicDatabase.h
@@ -343,7 +343,7 @@ class CMusicDatabase : public CDatabase
   void SetTranslateBlankArtist(bool translate) { m_translateBlankArtist = translate; }
   bool HasArtistBeenScraped(int idArtist);
   bool ClearArtistLastScrapedTime(int idArtist);
-  int  AddArtistDiscography(int idArtist, const std::string& strAlbum, const std::string& strYear);
+  int AddArtistDiscography(int idArtist, const CDiscoAlbum& discoAlbum);
   bool DeleteArtistDiscography(int idArtist);
   bool GetArtistDiscography(int idArtist, CFileItemList& items);
 
