From 890f5ac64c6c689ad85f249297cb83909a3fd07f Mon Sep 17 00:00:00 2001
From: Markus Pfau <pfau@peak3d.de>
Date: Mon, 16 Jul 2018 13:56:47 +0200
Subject: [PATCH] Revert "Reusepython"

---
 addons/xbmc.addon/metadata.xsd                |   1 -
 xbmc/addons/addoninfo/AddonInfoBuilder.cpp    |   5 -
 xbmc/filesystem/PluginDirectory.cpp           |  19 +-
 xbmc/filesystem/PluginDirectory.h             |   2 -
 .../generic/ILanguageInvocationHandler.h      |   2 +-
 xbmc/interfaces/generic/ILanguageInvoker.cpp  |   6 +-
 xbmc/interfaces/generic/ILanguageInvoker.h    |   4 +-
 .../generic/LanguageInvokerThread.cpp         |  49 +--
 .../generic/LanguageInvokerThread.h           |  15 +-
 .../generic/ScriptInvocationManager.cpp       | 101 +----
 .../generic/ScriptInvocationManager.h         |  38 +-
 xbmc/interfaces/python/PythonInvoker.cpp      | 362 ++++++++----------
 xbmc/interfaces/python/PythonInvoker.h        |  10 +-
 xbmc/interfaces/python/XBPython.cpp           |   6 +-
 xbmc/interfaces/python/XBPython.h             |   2 +-
 15 files changed, 212 insertions(+), 410 deletions(-)

diff --git a/addons/xbmc.addon/metadata.xsd b/addons/xbmc.addon/metadata.xsd
index 89058e9e4702..03fbf241f5db 100644
--- a/addons/xbmc.addon/metadata.xsd
+++ b/addons/xbmc.addon/metadata.xsd
@@ -16,7 +16,6 @@
         <xs:element name="email" type="xs:string" minOccurs="0" maxOccurs="1"/>
         <xs:element name="broken" type="xs:string" minOccurs="0" maxOccurs="1"/>
         <xs:element name="news" type="xs:string" minOccurs="0" maxOccurs="1"/>
-        <xs:element name="reuselanguageinvoker" type="xs:boolean" minOccurs="0" maxOccurs="1"/>
         <xs:element name="assets" type="assetsList" minOccurs="0" maxOccurs="1"/>
       </xs:choice>
       <xs:attribute name="point" type="xs:string" use="required"/>
diff --git a/xbmc/addons/addoninfo/AddonInfoBuilder.cpp b/xbmc/addons/addoninfo/AddonInfoBuilder.cpp
index 233789587d96..ef80cb513d3e 100644
--- a/xbmc/addons/addoninfo/AddonInfoBuilder.cpp
+++ b/xbmc/addons/addoninfo/AddonInfoBuilder.cpp
@@ -318,11 +318,6 @@ bool CAddonInfoBuilder::ParseXML(const AddonInfoPtr& addon, const TiXmlElement*
       if (element && element->GetText() != nullptr)
         addon->AddExtraInfo("language", element->GetText());
 
-      /* Parse addon.xml "<reuselanguageinvoker">...</reuselanguageinvoker>" */
-      element = child->FirstChildElement("reuselanguageinvoker");
-      if (element && element->GetText() != nullptr)
-        addon->AddExtraInfo("reuselanguageinvoker", element->GetText());
-
       /* Parse addon.xml "<noicon">...</noicon>" */
       if (addon->m_icon.empty())
       {
diff --git a/xbmc/filesystem/PluginDirectory.cpp b/xbmc/filesystem/PluginDirectory.cpp
index 6766f86bbc7f..aaa4b94d301d 100644
--- a/xbmc/filesystem/PluginDirectory.cpp
+++ b/xbmc/filesystem/PluginDirectory.cpp
@@ -86,12 +86,6 @@ int CPluginDirectory::getNewHandle(CPluginDirectory *cp)
   return handle;
 }
 
-void CPluginDirectory::reuseHandle(int handle, CPluginDirectory *cp)
-{
-  CSingleLock lock(m_handleLock);
-  globalHandles[handle] = cp;
-}
-
 void CPluginDirectory::removeHandle(int handle)
 {
   CSingleLock lock(m_handleLock);
@@ -130,12 +124,7 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDi
   std::string basePath(url.Get());
   // reset our wait event, and grab a new handle
   m_fetchComplete.Reset();
-  int handle = CScriptInvocationManager::GetInstance().GetReusablePluginHandle(m_addon->LibPath());
-
-  if (handle < 0)
-    handle = getNewHandle(this);
-  else
-    reuseHandle(handle, this);
+  int handle = getNewHandle(this);
 
   // clear out our status variables
   m_fileResult->Reset();
@@ -162,11 +151,7 @@ bool CPluginDirectory::StartScript(const std::string& strPath, bool retrievingDi
   CLog::Log(LOGDEBUG, "%s - calling plugin %s('%s','%s','%s','%s')", __FUNCTION__, m_addon->Name().c_str(), argv[0].c_str(), argv[1].c_str(), argv[2].c_str(), argv[3].c_str());
   bool success = false;
   std::string file = m_addon->LibPath();
-  bool reuseLanguageInvoker = false;
-  if (m_addon->ExtraInfo().find("reuselanguageinvoker") != m_addon->ExtraInfo().end())
-    reuseLanguageInvoker = m_addon->ExtraInfo().at("reuselanguageinvoker") == "true";
-
-  int id = CScriptInvocationManager::GetInstance().ExecuteAsync(file, m_addon, argv, reuseLanguageInvoker, handle);
+  int id = CScriptInvocationManager::GetInstance().ExecuteAsync(file, m_addon, argv);
   if (id >= 0)
   { // wait for our script to finish
     std::string scriptName = m_addon->Name();
diff --git a/xbmc/filesystem/PluginDirectory.h b/xbmc/filesystem/PluginDirectory.h
index 039c29d52a39..3eb8bfaf48e9 100644
--- a/xbmc/filesystem/PluginDirectory.h
+++ b/xbmc/filesystem/PluginDirectory.h
@@ -75,8 +75,6 @@ class CPluginDirectory : public IDirectory
 
   static std::map<int,CPluginDirectory*> globalHandles;
   static int getNewHandle(CPluginDirectory *cp);
-  static void reuseHandle(int handle, CPluginDirectory *cp);
-
   static void removeHandle(int handle);
   static CPluginDirectory *dirFromHandle(int handle);
   static CCriticalSection m_handleLock;
diff --git a/xbmc/interfaces/generic/ILanguageInvocationHandler.h b/xbmc/interfaces/generic/ILanguageInvocationHandler.h
index e3912355caef..3057132cfbdc 100644
--- a/xbmc/interfaces/generic/ILanguageInvocationHandler.h
+++ b/xbmc/interfaces/generic/ILanguageInvocationHandler.h
@@ -24,7 +24,7 @@ class ILanguageInvocationHandler
   virtual bool OnScriptInitialized(ILanguageInvoker *invoker) { return true; }
   virtual void OnScriptStarted(ILanguageInvoker *invoker) { }
   virtual void OnScriptAbortRequested(ILanguageInvoker *invoker) { }
-  virtual void OnExecutionEnded(ILanguageInvoker *invoker) { }
+  virtual void OnScriptEnded(ILanguageInvoker *invoker) { }
   virtual void OnScriptFinalized(ILanguageInvoker *invoker) { }
 
   virtual ILanguageInvoker* CreateInvoker() = 0;
diff --git a/xbmc/interfaces/generic/ILanguageInvoker.cpp b/xbmc/interfaces/generic/ILanguageInvoker.cpp
index 9918c583ac5e..0578c759782b 100644
--- a/xbmc/interfaces/generic/ILanguageInvoker.cpp
+++ b/xbmc/interfaces/generic/ILanguageInvoker.cpp
@@ -36,7 +36,7 @@ bool ILanguageInvoker::Stop(bool abort /* = false */)
 
 bool ILanguageInvoker::IsActive() const
 {
-  return GetState() > InvokerStateUninitialized && GetState() < InvokerStateScriptDone;
+  return GetState() > InvokerStateUninitialized && GetState() < InvokerStateDone;
 }
 
 bool ILanguageInvoker::IsRunning() const
@@ -72,13 +72,13 @@ void ILanguageInvoker::onAbortRequested()
 void ILanguageInvoker::onExecutionFailed()
 {
   if (m_invocationHandler)
-    m_invocationHandler->OnExecutionEnded(this);
+    m_invocationHandler->OnScriptEnded(this);
 }
 
 void ILanguageInvoker::onExecutionDone()
 {
   if (m_invocationHandler)
-    m_invocationHandler->OnExecutionEnded(this);
+    m_invocationHandler->OnScriptEnded(this);
 }
 
 void ILanguageInvoker::onExecutionFinalized()
diff --git a/xbmc/interfaces/generic/ILanguageInvoker.h b/xbmc/interfaces/generic/ILanguageInvoker.h
index 29cc422793a7..3a8f6819fce3 100644
--- a/xbmc/interfaces/generic/ILanguageInvoker.h
+++ b/xbmc/interfaces/generic/ILanguageInvoker.h
@@ -22,8 +22,7 @@ typedef enum {
   InvokerStateInitialized,
   InvokerStateRunning,
   InvokerStateStopping,
-  InvokerStateScriptDone,
-  InvokerStateExecutionDone,
+  InvokerStateDone,
   InvokerStateFailed
 } InvokerState;
 
@@ -44,7 +43,6 @@ class ILanguageInvoker
   InvokerState GetState() const { return m_state; }
   bool IsActive() const;
   bool IsRunning() const;
-  void Reset() { m_state = InvokerStateUninitialized; };
 
 protected:
   friend class CLanguageInvokerThread;
diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.cpp b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
index 87359b00c4cb..81c923ec6125 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.cpp
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
@@ -10,12 +10,11 @@
 
 #include "ScriptInvocationManager.h"
 
-CLanguageInvokerThread::CLanguageInvokerThread(LanguageInvokerPtr invoker, CScriptInvocationManager *invocationManager, bool reuseable)
+CLanguageInvokerThread::CLanguageInvokerThread(LanguageInvokerPtr invoker, CScriptInvocationManager* invocationManager)
   : ILanguageInvoker(NULL),
     CThread("LanguageInvoker"),
     m_invoker(invoker),
-    m_invocationManager(invocationManager),
-    m_reusable(reuseable)
+    m_invocationManager(invocationManager)
 { }
 
 CLanguageInvokerThread::~CLanguageInvokerThread()
@@ -23,7 +22,7 @@ CLanguageInvokerThread::~CLanguageInvokerThread()
   Stop(true);
 }
 
-InvokerState CLanguageInvokerThread::GetState() const
+InvokerState CLanguageInvokerThread::GetState()
 {
   if (m_invoker == NULL)
     return InvokerStateFailed;
@@ -31,12 +30,6 @@ InvokerState CLanguageInvokerThread::GetState() const
   return m_invoker->GetState();
 }
 
-void CLanguageInvokerThread::Release()
-{
-  m_bStop = true;
-  m_condition.notify_one();
-}
-
 bool CLanguageInvokerThread::execute(const std::string &script, const std::vector<std::string> &arguments)
 {
   if (m_invoker == NULL || script.empty())
@@ -45,17 +38,7 @@ bool CLanguageInvokerThread::execute(const std::string &script, const std::vecto
   m_script = script;
   m_args = arguments;
 
-  if (CThread::IsRunning())
-  {
-    std::unique_lock<std::mutex> lck(m_mutex);
-    m_restart = true;
-    m_condition.notify_one();
-  }
-  else
-    Create();
-
-  //Todo wait until running
-
+  Create();
   return true;
 }
 
@@ -67,16 +50,14 @@ bool CLanguageInvokerThread::stop(bool wait)
   if (!CThread::IsRunning())
     return false;
 
-  Release();
-
   bool result = true;
-  if (m_invoker->GetState() < InvokerStateExecutionDone)
+  if (m_invoker->GetState() < InvokerStateDone)
   {
     // stop the language-specific invoker
     result = m_invoker->Stop(wait);
+    // stop the thread
+    CThread::StopThread(wait);
   }
-  // stop the thread
-  CThread::StopThread(wait);
 
   return result;
 }
@@ -96,17 +77,7 @@ void CLanguageInvokerThread::Process()
   if (m_invoker == NULL)
     return;
 
-  std::unique_lock<std::mutex> lckdl(m_mutex);
-  do {
-    m_restart = false;
-    m_invoker->Execute(m_script, m_args);
-
-    if (m_invoker->GetState() != InvokerStateScriptDone)
-      m_reusable = false;
-
-    m_condition.wait(lckdl, [this] {return m_bStop || m_restart || !m_reusable; });
-
-  } while (m_reusable && !m_bStop);
+  m_invoker->Execute(m_script, m_args);
 }
 
 void CLanguageInvokerThread::OnExit()
@@ -115,7 +86,7 @@ void CLanguageInvokerThread::OnExit()
     return;
 
   m_invoker->onExecutionDone();
-  m_invocationManager->OnExecutionDone(GetId());
+  m_invocationManager->OnScriptEnded(GetId());
 }
 
 void CLanguageInvokerThread::OnException()
@@ -124,5 +95,5 @@ void CLanguageInvokerThread::OnException()
     return;
 
   m_invoker->onExecutionFailed();
-  m_invocationManager->OnExecutionDone(GetId());
+  m_invocationManager->OnScriptEnded(GetId());
 }
\ No newline at end of file
diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.h b/xbmc/interfaces/generic/LanguageInvokerThread.h
index 81e4915ff5f4..5bd1b60098fb 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.h
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.h
@@ -19,15 +19,10 @@ class CScriptInvocationManager;
 class CLanguageInvokerThread : public ILanguageInvoker, protected CThread
 {
 public:
-  CLanguageInvokerThread(LanguageInvokerPtr invoker, CScriptInvocationManager *invocationManager, bool reuseable);
+  CLanguageInvokerThread(LanguageInvokerPtr invoker, CScriptInvocationManager* invocationManager);
   ~CLanguageInvokerThread() override;
 
-  virtual InvokerState GetState() const;
-
-  const std::string &GetScript() const { return m_script; };
-  LanguageInvokerPtr GetInvoker() const { return m_invoker; };
-  bool Reuseable(const std::string &script) const { return !m_bStop && m_reusable && GetState() == InvokerStateScriptDone && m_script == script; };
-  virtual void Release();
+  virtual InvokerState GetState();
 
 protected:
   bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
@@ -43,10 +38,4 @@ class CLanguageInvokerThread : public ILanguageInvoker, protected CThread
   CScriptInvocationManager *m_invocationManager;
   std::string m_script;
   std::vector<std::string> m_args;
-
-  std::mutex m_mutex;
-  std::condition_variable m_condition;
-  bool m_restart = false;
-  bool m_reusable = false;
 };
-
diff --git a/xbmc/interfaces/generic/ScriptInvocationManager.cpp b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
index 373aaeb91142..22945b682fae 100644
--- a/xbmc/interfaces/generic/ScriptInvocationManager.cpp
+++ b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
@@ -77,9 +77,6 @@ void CScriptInvocationManager::Uninitialize()
   // execute Process() once more to handle the remaining scripts
   Process();
 
-  // it is safe to relese early, thread must be in m_scripts too
-  m_lastInvokerThread = nullptr;
-
   // make sure all scripts are done
   std::vector<LanguageInvokerThread> tempList;
   for (const auto& script : m_scripts)
@@ -99,11 +96,9 @@ void CScriptInvocationManager::Uninitialize()
     if (!it.done)
       it.thread->Stop(true);
   }
-
-  lock.Enter();
-
   tempList.clear();
 
+  lock.Enter();
   // uninitialize all invocation handlers and then remove them
   for (auto& it : m_invocationHandlers)
     it.second->Uninitialize();
@@ -180,39 +175,12 @@ bool CScriptInvocationManager::HasLanguageInvoker(const std::string &script) con
   return it != m_invocationHandlers.end() && it->second != NULL;
 }
 
-int CScriptInvocationManager::GetReusablePluginHandle(const std::string &script)
+LanguageInvokerPtr CScriptInvocationManager::GetLanguageInvoker(const std::string& script) const
 {
-  CSingleLock lock(m_critSection);
-
-  if (m_lastInvokerThread)
-  {
-    if (m_lastInvokerThread->Reuseable(script))
-      return m_lastPluginHandle;
-    m_lastInvokerThread->Release();
-    m_lastInvokerThread = nullptr;
-  }
-  return -1;
-}
-
-LanguageInvokerPtr CScriptInvocationManager::GetLanguageInvoker(const std::string &script)
-{
-  CSingleLock lock(m_critSection);
-
-  if (m_lastInvokerThread)
-  {
-    if (m_lastInvokerThread->Reuseable(script))
-    {
-      CLog::Log(LOGDEBUG, "%s - Reusing LanguageInvokerThread %d for script %s", __FUNCTION__, m_lastInvokerThread->GetId(), script.c_str());
-      m_lastInvokerThread->GetInvoker()->Reset();
-      return m_lastInvokerThread->GetInvoker();
-    }
-    m_lastInvokerThread->Release();
-    m_lastInvokerThread = nullptr;
-  }
-
   std::string extension = URIUtils::GetExtension(script);
   StringUtils::ToLower(extension);
 
+  CSingleLock lock(m_critSection);
   std::map<std::string, ILanguageInvocationHandler*>::const_iterator it = m_invocationHandlers.find(extension);
   if (it != m_invocationHandlers.end() && it->second != NULL)
     return LanguageInvokerPtr(it->second->CreateInvoker());
@@ -220,11 +188,7 @@ LanguageInvokerPtr CScriptInvocationManager::GetLanguageInvoker(const std::strin
   return LanguageInvokerPtr();
 }
 
-int CScriptInvocationManager::ExecuteAsync(const std::string &script,
-  const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */,
-  const std::vector<std::string> &arguments /* = std::vector<std::string>() */,
-  bool reuseable /* = false */,
-  int pluginHandle /* = -1 */)
+int CScriptInvocationManager::ExecuteAsync(const std::string &script, const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */, const std::vector<std::string> &arguments /* = std::vector<std::string>() */)
 {
   if (script.empty())
     return -1;
@@ -236,15 +200,10 @@ int CScriptInvocationManager::ExecuteAsync(const std::string &script,
   }
 
   LanguageInvokerPtr invoker = GetLanguageInvoker(script);
-  return ExecuteAsync(script, invoker, addon, arguments, reuseable, pluginHandle);
+  return ExecuteAsync(script, invoker, addon, arguments);
 }
 
-int CScriptInvocationManager::ExecuteAsync(const std::string &script,
-  LanguageInvokerPtr languageInvoker,
-  const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */,
-  const std::vector<std::string> &arguments /* = std::vector<std::string>() */,
-  bool reuseable /* = false */,
-  int pluginHandle /* = -1 */)
+int CScriptInvocationManager::ExecuteAsync(const std::string &script, LanguageInvokerPtr languageInvoker, const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */, const std::vector<std::string> &arguments /* = std::vector<std::string>() */)
 {
   if (script.empty() || languageInvoker == NULL)
     return -1;
@@ -255,47 +214,26 @@ int CScriptInvocationManager::ExecuteAsync(const std::string &script,
     return -1;
   }
 
-  CSingleLock lock(m_critSection);
-
-  if (m_lastInvokerThread && m_lastInvokerThread->GetInvoker() == languageInvoker)
-  {
-    if (addon != NULL)
-      m_lastInvokerThread->SetAddon(addon);
-
-    // After we leave the lock, m_lastInvokerThread can be released -> copy!
-    CLanguageInvokerThreadPtr invokerThread = m_lastInvokerThread;
-    lock.Leave();
-    invokerThread->Execute(script, arguments);
-
-    return invokerThread->GetId();
-  }
-
-  m_lastInvokerThread = CLanguageInvokerThreadPtr(new CLanguageInvokerThread(languageInvoker, this, reuseable));
-  if (m_lastInvokerThread == NULL)
+  CLanguageInvokerThreadPtr invokerThread = CLanguageInvokerThreadPtr(new CLanguageInvokerThread(languageInvoker, this));
+  if (invokerThread == NULL)
     return -1;
 
   if (addon != NULL)
-    m_lastInvokerThread->SetAddon(addon);
+    invokerThread->SetAddon(addon);
 
-  m_lastInvokerThread->SetId(m_nextId++);
-  m_lastPluginHandle = pluginHandle;
+  CSingleLock lock(m_critSection);
+  invokerThread->SetId(m_nextId++);
 
-  LanguageInvokerThread thread = { m_lastInvokerThread, script, false };
-  m_scripts.insert(std::make_pair(m_lastInvokerThread->GetId(), thread));
-  m_scriptPaths.insert(std::make_pair(script, m_lastInvokerThread->GetId()));
-  // After we leave the lock, m_lastInvokerThread can be released -> copy!
-  CLanguageInvokerThreadPtr invokerThread = m_lastInvokerThread;
+  LanguageInvokerThread thread = {invokerThread, script, false};
+  m_scripts.insert(std::make_pair(invokerThread->GetId(), thread));
+  m_scriptPaths.insert(std::make_pair(script, invokerThread->GetId()));
   lock.Leave();
   invokerThread->Execute(script, arguments);
 
   return invokerThread->GetId();
 }
 
-int CScriptInvocationManager::ExecuteSync(const std::string &script,
-  const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */,
-  const std::vector<std::string> &arguments /* = std::vector<std::string>() */,
-  uint32_t timeoutMs /* = 0 */,
-  bool waitShutdown /* = false */)
+int CScriptInvocationManager::ExecuteSync(const std::string &script, const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */, const std::vector<std::string> &arguments /* = std::vector<std::string>() */, uint32_t timeoutMs /* = 0 */, bool waitShutdown /* = false */)
 {
   if (script.empty())
     return -1;
@@ -310,12 +248,7 @@ int CScriptInvocationManager::ExecuteSync(const std::string &script,
   return ExecuteSync(script, invoker, addon, arguments, timeoutMs, waitShutdown);
 }
 
-int CScriptInvocationManager::ExecuteSync(const std::string &script,
-  LanguageInvokerPtr languageInvoker,
-  const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */,
-  const std::vector<std::string> &arguments /* = std::vector<std::string>() */,
-  uint32_t timeoutMs /* = 0 */,
-  bool waitShutdown /* = false */)
+int CScriptInvocationManager::ExecuteSync(const std::string &script, LanguageInvokerPtr languageInvoker, const ADDON::AddonPtr &addon /* = ADDON::AddonPtr() */, const std::vector<std::string> &arguments /* = std::vector<std::string>() */, uint32_t timeoutMs /* = 0 */, bool waitShutdown /* = false */)
 {
   int scriptId = ExecuteAsync(script, languageInvoker, addon, arguments);
   if (scriptId < 0)
@@ -389,7 +322,7 @@ bool CScriptInvocationManager::IsRunning(const std::string& scriptPath) const
   return IsRunning(it->second);
 }
 
-void CScriptInvocationManager::OnExecutionDone(int scriptId)
+void CScriptInvocationManager::OnScriptEnded(int scriptId)
 {
   if (scriptId < 0)
     return;
diff --git a/xbmc/interfaces/generic/ScriptInvocationManager.h b/xbmc/interfaces/generic/ScriptInvocationManager.h
index cf87d1383fc7..ac1fec79ecf9 100644
--- a/xbmc/interfaces/generic/ScriptInvocationManager.h
+++ b/xbmc/interfaces/generic/ScriptInvocationManager.h
@@ -32,12 +32,7 @@ class CScriptInvocationManager
   void RegisterLanguageInvocationHandler(ILanguageInvocationHandler *invocationHandler, const std::set<std::string> &extensions);
   void UnregisterLanguageInvocationHandler(ILanguageInvocationHandler *invocationHandler);
   bool HasLanguageInvoker(const std::string &script) const;
-  LanguageInvokerPtr GetLanguageInvoker(const std::string &script);
-
-  /*!
-  * \brief Returns addon_handle if last reusable invoker is ready to use.
-  */
-  int GetReusablePluginHandle(const std::string &script);
+  LanguageInvokerPtr GetLanguageInvoker(const std::string& script) const;
 
   /*!
    * \brief Executes the given script asynchronously in a separate thread.
@@ -47,11 +42,7 @@ class CScriptInvocationManager
    * \param arguments (Optional) List of arguments passed to the script
    * \return -1 if an error occurred, otherwise the ID of the script
    */
-  int ExecuteAsync(const std::string &script,
-    const ADDON::AddonPtr &addon = ADDON::AddonPtr(),
-    const std::vector<std::string> &arguments = std::vector<std::string>(),
-    bool reuseable = false,
-    int pluginHandle = -1);
+  int ExecuteAsync(const std::string &script, const ADDON::AddonPtr &addon = ADDON::AddonPtr(), const std::vector<std::string> &arguments = std::vector<std::string>());
   /*!
   * \brief Executes the given script asynchronously in a separate thread.
   *
@@ -61,12 +52,7 @@ class CScriptInvocationManager
   * \param arguments (Optional) List of arguments passed to the script
   * \return -1 if an error occurred, otherwise the ID of the script
   */
-  int ExecuteAsync(const std::string &script,
-    LanguageInvokerPtr languageInvoker,
-    const ADDON::AddonPtr &addon = ADDON::AddonPtr(),
-    const std::vector<std::string> &arguments = std::vector<std::string>(),
-    bool reuseable = false,
-    int pluginHandle = -1);
+  int ExecuteAsync(const std::string &script, LanguageInvokerPtr languageInvoker, const ADDON::AddonPtr &addon = ADDON::AddonPtr(), const std::vector<std::string> &arguments = std::vector<std::string>());
 
   /*!
   * \brief Executes the given script synchronously.
@@ -84,11 +70,7 @@ class CScriptInvocationManager
   * \param waitShutdown (Optional) Whether to wait when having to forcefully stop the script's execution or not.
   * \return -1 if an error occurred, 0 if the script terminated or ETIMEDOUT if the given timeout expired
   */
-  int ExecuteSync(const std::string &script,
-    const ADDON::AddonPtr &addon = ADDON::AddonPtr(),
-    const std::vector<std::string> &arguments = std::vector<std::string>(),
-    uint32_t timeoutMs = 0,
-    bool waitShutdown = false);
+  int ExecuteSync(const std::string &script, const ADDON::AddonPtr &addon = ADDON::AddonPtr(), const std::vector<std::string> &arguments = std::vector<std::string>(), uint32_t timeoutMs = 0, bool waitShutdown = false);
   /*!
   * \brief Executes the given script synchronously.
   *
@@ -106,12 +88,7 @@ class CScriptInvocationManager
   * \param waitShutdown (Optional) Whether to wait when having to forcefully stop the script's execution or not.
   * \return -1 if an error occurred, 0 if the script terminated or ETIMEDOUT if the given timeout expired
   */
-  int ExecuteSync(const std::string &script,
-    LanguageInvokerPtr languageInvoker,
-    const ADDON::AddonPtr &addon = ADDON::AddonPtr(),
-    const std::vector<std::string> &arguments = std::vector<std::string>(),
-    uint32_t timeoutMs = 0,
-    bool waitShutdown = false);
+  int ExecuteSync(const std::string &script, LanguageInvokerPtr languageInvoker, const ADDON::AddonPtr &addon = ADDON::AddonPtr(), const std::vector<std::string> &arguments = std::vector<std::string>(), uint32_t timeoutMs = 0, bool waitShutdown = false);
   bool Stop(int scriptId, bool wait = false);
   bool Stop(const std::string &scriptPath, bool wait = false);
 
@@ -121,7 +98,7 @@ class CScriptInvocationManager
 protected:
   friend class CLanguageInvokerThread;
 
-  void OnExecutionDone(int scriptId);
+  void OnScriptEnded(int scriptId);
 
 private:
   CScriptInvocationManager() = default;
@@ -141,9 +118,6 @@ class CScriptInvocationManager
 
   LanguageInvocationHandlerMap m_invocationHandlers;
   LanguageInvokerThreadMap m_scripts;
-  CLanguageInvokerThreadPtr m_lastInvokerThread;
-  int m_lastPluginHandle;
-
   std::map<std::string, int> m_scriptPaths;
   int m_nextId = 0;
   mutable CCriticalSection m_critSection;
diff --git a/xbmc/interfaces/python/PythonInvoker.cpp b/xbmc/interfaces/python/PythonInvoker.cpp
index 968faef3bcc8..c07daf3d05f4 100644
--- a/xbmc/interfaces/python/PythonInvoker.cpp
+++ b/xbmc/interfaces/python/PythonInvoker.cpp
@@ -23,6 +23,8 @@
 #include "windowing/GraphicContext.h"
 #include "guilib/GUIWindowManager.h"
 #include "guilib/LocalizeStrings.h"
+#include "interfaces/legacy/Addon.h"
+#include "interfaces/python/LanguageHook.h"
 #include "interfaces/python/PyContext.h"
 #include "interfaces/python/pythreadstate.h"
 #include "interfaces/python/swig.h"
@@ -116,7 +118,7 @@ CPythonInvoker::~CPythonInvoker()
   if (GetId() < 0)
     return;
 
-  if (GetState() < InvokerStateExecutionDone)
+  if (GetState() < InvokerStateDone)
     CLog::Log(LOGDEBUG, "CPythonInvoker(%d): waiting for python thread \"%s\" to stop",
       GetId(), (!m_sourceFile.empty() ? m_sourceFile.c_str() : "unknown script"));
   Stop(true);
@@ -146,7 +148,6 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
 {
   // copy the code/script into a local string buffer
   m_sourceFile = script;
-  m_pythonPath.clear();
 
   // copy the arguments into a local buffer
   unsigned int argc = arguments.size();
@@ -155,121 +156,115 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
 
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): start processing", GetId(), m_sourceFile.c_str());
 
-  std::string realFilename(CSpecialProtocol::TranslatePath(m_sourceFile));
-  std::string scriptDir = URIUtils::GetDirectory(realFilename);
-  URIUtils::RemoveSlashAtEnd(scriptDir);
-
   // get the global lock
   PyEval_AcquireLock();
-  if (!m_threadState)
+  PyThreadState* state = Py_NewInterpreter();
+  if (state == NULL)
   {
-    m_threadState = Py_NewInterpreter();
-    if (m_threadState == NULL)
-    {
-      PyEval_ReleaseLock();
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): FAILED to get thread m_threadState!", GetId(), m_sourceFile.c_str());
-      return false;
-    }
-    // swap in my thread m_threadState
-    PyThreadState_Swap(m_threadState);
+    PyEval_ReleaseLock();
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): FAILED to get thread state!", GetId(), m_sourceFile.c_str());
+    return false;
+  }
+  // swap in my thread state
+  PyThreadState_Swap(state);
 
-    m_languageHook = new XBMCAddon::Python::PythonLanguageHook(m_threadState->interp);
-    m_languageHook->RegisterMe();
+  XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> languageHook(new XBMCAddon::Python::PythonLanguageHook(state->interp));
+  languageHook->RegisterMe();
 
-    onInitialization();
-    setState(InvokerStateInitialized);
+  onInitialization();
+  setState(InvokerStateInitialized);
 
-    if (realFilename == m_sourceFile)
-      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\"", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
-    else
-      CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\" (\"%s\")", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), realFilename.c_str());
+  std::string realFilename(CSpecialProtocol::TranslatePath(m_sourceFile));
+  if (realFilename == m_sourceFile)
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\"", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str());
+  else
+    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): the source file to load is \"%s\" (\"%s\")", GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), realFilename.c_str());
 
-    // get path from script file name and add python path's
-    // this is used for python so it will search modules from script path first
-    addPath(scriptDir);
+  // get path from script file name and add python path's
+  // this is used for python so it will search modules from script path first
+  std::string scriptDir = URIUtils::GetDirectory(realFilename);
+  URIUtils::RemoveSlashAtEnd(scriptDir);
+  addPath(scriptDir);
 
-    // add all addon module dependencies to path
-    if (m_addon)
-    {
-      std::set<std::string> paths;
-      getAddonModuleDeps(m_addon, paths);
-      for (const auto& it : paths)
-        addPath(it);
-    }
-    else
-    { // for backwards compatibility.
-      // we don't have any addon so just add all addon modules installed
-      CLog::Log(LOGWARNING, "CPythonInvoker(%d): Script invoked without an addon. Adding all addon "
+  // add all addon module dependencies to path
+  if (m_addon)
+  {
+    std::set<std::string> paths;
+    getAddonModuleDeps(m_addon, paths);
+    for (const auto& it : paths)
+      addPath(it);
+  }
+  else
+  { // for backwards compatibility.
+    // we don't have any addon so just add all addon modules installed
+    CLog::Log(LOGWARNING, "CPythonInvoker(%d): Script invoked without an addon. Adding all addon "
         "modules installed to python path as fallback. This behaviour will be removed in future "
         "version.", GetId());
-      ADDON::VECADDONS addons;
-      CServiceBroker::GetAddonMgr().GetAddons(addons, ADDON::ADDON_SCRIPT_MODULE);
-      for (unsigned int i = 0; i < addons.size(); ++i)
-        addPath(CSpecialProtocol::TranslatePath(addons[i]->LibPath()));
-    }
+    ADDON::VECADDONS addons;
+    CServiceBroker::GetAddonMgr().GetAddons(addons, ADDON::ADDON_SCRIPT_MODULE);
+    for (const auto& addon : addons)
+      addPath(CSpecialProtocol::TranslatePath(addon->LibPath()));
+  }
 
-    // we want to use sys.path so it includes site-packages
-    // if this fails, default to using Py_GetPath
-    PyObject *sysMod(PyImport_ImportModule("sys")); // must call Py_DECREF when finished
-    PyObject *sysModDict(PyModule_GetDict(sysMod)); // borrowed ref, no need to delete
-    PyObject *pathObj(PyDict_GetItemString(sysModDict, "path")); // borrowed ref, no need to delete
+  // we want to use sys.path so it includes site-packages
+  // if this fails, default to using Py_GetPath
+  PyObject* sysMod(PyImport_ImportModule("sys")); // must call Py_DECREF when finished
+  PyObject* sysModDict(PyModule_GetDict(sysMod)); // borrowed ref, no need to delete
+  PyObject* pathObj(PyDict_GetItemString(sysModDict, "path")); // borrowed ref, no need to delete
 
-    if (pathObj != NULL && PyList_Check(pathObj))
+  if (pathObj != NULL && PyList_Check(pathObj))
+  {
+    for (int i = 0; i < PyList_Size(pathObj); i++)
     {
-      for (int i = 0; i < PyList_Size(pathObj); i++)
-      {
-        PyObject *e = PyList_GetItem(pathObj, i); // borrowed ref, no need to delete
-        if (e != NULL && PyString_Check(e))
-          addNativePath(PyString_AsString(e)); // returns internal data, don't delete or modify
+      PyObject* e = PyList_GetItem(pathObj, i); // borrowed ref, no need to delete
+      if (e != NULL && PyString_Check(e))
+        addNativePath(PyString_AsString(e)); // returns internal data, don't delete or modify
 #ifdef TARGET_WINDOWS_STORE
-                                               // uwp python operates unicodes
-        else if (e != NULL && PyUnicode_Check(e))
-        {
-          PyObject *utf8 = PyUnicode_AsUTF8String(e);
-          addNativePath(PyString_AsString(utf8));
-          Py_DECREF(utf8);
-        }
-#endif
+      // uwp python operates unicodes
+      else if (e != NULL && PyUnicode_Check(e))
+      {
+        PyObject* utf8 = PyUnicode_AsUTF8String(e);
+        addNativePath(PyString_AsString(utf8));
+        Py_DECREF(utf8);
       }
+#endif
     }
-    else
-      addNativePath(Py_GetPath());
-
-    Py_DECREF(sysMod); // release ref to sysMod
-
-#ifdef TARGET_WINDOWS
-    std::string pyPathUtf8;
-    g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
-#else // ! TARGET_WINDOWS
-    CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
-#endif // ! TARGET_WINDOWS
-    //! @bug libpython < 3.0 isn't const correct
-    PySys_SetPath(const_cast<char*>(m_pythonPath.c_str()));
   }
   else
-    // swap in my thread m_threadState
-    PyThreadState_Swap(m_threadState);
+    addNativePath(Py_GetPath());
+
+  Py_DECREF(sysMod); // release ref to sysMod
 
   // set current directory and python's path.
   PySys_SetArgv(argc, &argv[0]);
 
+#ifdef TARGET_WINDOWS
+  std::string pyPathUtf8;
+  g_charsetConverter.systemToUtf8(m_pythonPath, pyPathUtf8, false);
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), pyPathUtf8.c_str());
+#else // ! TARGET_WINDOWS
+  CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): setting the Python path to %s", GetId(), m_sourceFile.c_str(), m_pythonPath.c_str());
+#endif // ! TARGET_WINDOWS
+  //! @bug libpython < 3.0 isn't const correct
+  PySys_SetPath(const_cast<char*>(m_pythonPath.c_str()));
+
   CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): entering source directory %s", GetId(), m_sourceFile.c_str(), scriptDir.c_str());
   PyObject* module = PyImport_AddModule("__main__");
   PyObject* moduleDict = PyModule_GetDict(module);
 
-  // when we are done initing we store thread m_threadState so we can be aborted
+  // when we are done initing we store thread state so we can be aborted
   PyThreadState_Swap(NULL);
   PyEval_ReleaseLock();
 
   // we need to check if we was asked to abort before we had inited
   bool stopping = false;
   { CSingleLock lock(m_critical);
+    m_threadState = state;
     stopping = m_stop;
   }
 
   PyEval_AcquireLock();
-  PyThreadState_Swap(m_threadState);
+  PyThreadState_Swap(state);
 
   bool failed = false;
   std::string exceptionType, exceptionValue, exceptionTraceback;
@@ -322,17 +317,17 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     }
   }
 
-  m_systemExitThrown = false;
+  bool systemExitThrown = false;
   InvokerState stateToSet;
   if (!failed && !PyErr_Occurred())
   {
     CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script successfully run", GetId(), m_sourceFile.c_str());
-    stateToSet = InvokerStateScriptDone;
+    stateToSet = InvokerStateDone;
     onSuccess();
   }
   else if (PyErr_ExceptionMatches(PyExc_SystemExit))
   {
-    m_systemExitThrown = true;
+    systemExitThrown = true;
     CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): script aborted", GetId(), m_sourceFile.c_str());
     stateToSet = InvokerStateFailed;
     onAbort();
@@ -357,7 +352,6 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     onError(exceptionType, exceptionValue, exceptionTraceback);
   }
 
-  CSingleLock lock(m_critical);
   // no need to do anything else because the script has already stopped
   if (failed)
   {
@@ -365,42 +359,76 @@ bool CPythonInvoker::execute(const std::string &script, const std::vector<std::s
     return true;
   }
 
-  if (m_threadState)
-  {
-    PyObject *m = PyImport_AddModule("xbmc");
-    if (m == NULL || PyObject_SetAttrString(m, "abortRequested", PyBool_FromLong(1)))
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
+  PyObject* m = PyImport_AddModule("xbmc");
+  if (m == NULL || PyObject_SetAttrString(m, "abortRequested", PyBool_FromLong(1)))
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
 
-    // make sure all sub threads have finished
-    for (PyThreadState *old = nullptr; m_threadState != nullptr;)
+  // make sure all sub threads have finished
+  for (PyThreadState* s = state->interp->tstate_head, *old = NULL; s;)
+  {
+    if (s == state)
+    {
+      s = s->next;
+      continue;
+    }
+    if (old != s)
     {
-      PyThreadState *s = m_threadState->interp->tstate_head;
-      for (; s && s == m_threadState;)
-        s = s->next;
+      CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): waiting on thread %" PRIu64, GetId(), m_sourceFile.c_str(), (uint64_t)s->thread_id);
+      old = s;
+    }
 
-      if (!s)
-        break;
+    CPyThreadState pyState;
+    Sleep(100);
+    pyState.Restore();
 
-      if (old != s)
-      {
-        CLog::Log(LOGINFO, "CPythonInvoker(%d, %s): waiting on thread %" PRIu64, GetId(), m_sourceFile.c_str(), (uint64_t)s->thread_id);
-        old = s;
-      }
-
-      lock.Leave();
-      CPyThreadState pyState;
-      Sleep(100);
-      pyState.Restore();
-      lock.Enter();
-    }
+    s = state->interp->tstate_head;
   }
 
   // pending calls must be cleared out
-  XBMCAddon::RetardedAsyncCallbackHandler::clearPendingCalls(m_threadState);
+  XBMCAddon::RetardedAsyncCallbackHandler::clearPendingCalls(state);
 
   PyThreadState_Swap(NULL);
   PyEval_ReleaseLock();
 
+  // set stopped event - this allows ::stop to run and kill remaining threads
+  // this event has to be fired without holding m_critical
+  // also the GIL (PyEval_AcquireLock) must not be held
+  // if not obeyed there is still no deadlock because ::stop waits with timeout (smart one!)
+  m_stoppedEvent.Set();
+
+  { CSingleLock lock(m_critical);
+    m_threadState = NULL;
+  }
+
+  PyEval_AcquireLock();
+  PyThreadState_Swap(state);
+
+  onDeinitialization();
+
+  // run the gc before finishing
+  //
+  // if the script exited by throwing a SystemExit exception then going back
+  // into the interpreter causes this python bug to get hit:
+  //    http://bugs.python.org/issue10582
+  // and that causes major failures. So we are not going to go back in
+  // to run the GC if that's the case.
+  if (!m_stop && languageHook->HasRegisteredAddonClasses() && !systemExitThrown &&
+      PyRun_SimpleString(GC_SCRIPT) == -1)
+    CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
+
+  Py_EndInterpreter(state);
+
+  // If we still have objects left around, produce an error message detailing what's been left behind
+  if (languageHook->HasRegisteredAddonClasses())
+    CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
+      "classes in memory that we couldn't clean up. The classes include: %s",
+      GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(languageHook).c_str());
+
+  // unregister the language hook
+  languageHook->UnregisterMe();
+
+  PyEval_ReleaseLock();
+
   setState(stateToSet);
 
   return true;
@@ -420,38 +448,28 @@ bool CPythonInvoker::stop(bool abort)
   CSingleLock lock(m_critical);
   m_stop = true;
 
-  if (!IsRunning() && !m_threadState)
+  if (!IsRunning())
     return false;
 
+  setState(InvokerStateStopping);
+
   if (m_threadState != NULL)
   {
-    if (IsRunning())
-    {
-      setState(InvokerStateStopping);
-
-      lock.Leave();
-
-      PyEval_AcquireLock();
-      PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
+    PyEval_AcquireLock();
+    PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
 
-      //tell xbmc.Monitor to call onAbortRequested()
-      if (m_addon)
-      {
-        CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): trigger Monitor abort request", GetId(), m_sourceFile.c_str());
-        onAbortRequested();
-      }
+    //tell xbmc.Monitor to call onAbortRequested()
+    if (m_addon != NULL)
+      onAbortRequested();
 
-      PyObject *m;
-      m = PyImport_AddModule("xbmc");
-      if (m == NULL || PyObject_SetAttrString(m, "abortRequested", PyBool_FromLong(1)))
-        CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
+    PyObject* m;
+    m = PyImport_AddModule("xbmc");
+    if (m == NULL || PyObject_SetAttrString(m, "abortRequested", PyBool_FromLong(1)))
+      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
 
-      PyThreadState_Swap(old);
-      PyEval_ReleaseLock();
-    }
-    else
-      //Release the lock while waiting for threads to finish
-      lock.Leave();
+    PyThreadState_Swap(old);
+    old = NULL;
+    PyEval_ReleaseLock();
 
     XbmcThreads::EndTime timeout(PYTHON_SCRIPT_TIMEOUT);
     while (!m_stoppedEvent.WaitMSec(15))
@@ -471,22 +489,22 @@ bool CPythonInvoker::stop(bool abort)
       }
     }
 
-    // grabbing the PyLock while holding the m_critical is asking for a deadlock
-    PyEval_AcquireLock();
-
-    lock.Enter();
-
-    setState(InvokerStateExecutionDone);
-
     // Useful for add-on performance metrics
     if (!timeout.IsTimePast())
       CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): script termination took %dms", GetId(), m_sourceFile.c_str(), PYTHON_SCRIPT_TIMEOUT - timeout.MillisLeft());
 
+    // everything which didn't exit by now gets killed
+    {
+      // grabbing the PyLock while holding the m_critical is asking for a deadlock
+      CSingleExit ex2(m_critical);
+      PyEval_AcquireLock();
+    }
+
     // Since we released the m_critical it's possible that the state is cleaned up
     // so we need to recheck for m_threadState == NULL
     if (m_threadState != NULL)
     {
-      PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
+      old = PyThreadState_Swap((PyThreadState*)m_threadState);
       for (PyThreadState* state = ((PyThreadState*)m_threadState)->interp->tstate_head; state; state = state->next)
       {
         // Raise a SystemExit exception in python threads
@@ -494,71 +512,21 @@ bool CPythonInvoker::stop(bool abort)
         state->async_exc = PyExc_SystemExit;
         Py_XINCREF(state->async_exc);
       }
-      PyThreadState_Swap(old);
 
       // If a dialog entered its doModal(), we need to wake it to see the exception
       pulseGlobalEvent();
-      m_threadState = nullptr;
     }
+
+    if (old != NULL)
+      PyThreadState_Swap(old);
+
     lock.Leave();
     PyEval_ReleaseLock();
-
-    setState(InvokerStateFailed);
   }
 
   return true;
 }
 
-// Always called from Invoker thread
-void CPythonInvoker::onExecutionDone()
-{
-  CSingleLock lock(m_critical);
-  if (m_threadState != NULL)
-  {
-    CLog::Log(LOGDEBUG, "%s(%d, %s)", __FUNCTION__, GetId(), m_sourceFile.c_str());
-
-    PyEval_AcquireLock();
-    PyThreadState_Swap(m_threadState);
-
-    onDeinitialization();
-
-    // run the gc before finishing
-    //
-    // if the script exited by throwing a SystemExit exception then going back
-    // into the interpreter causes this python bug to get hit:
-    //    http://bugs.python.org/issue10582
-    // and that causes major failures. So we are not going to go back in
-    // to run the GC if that's the case.
-    if (!m_stop && m_languageHook->HasRegisteredAddonClasses() && !m_systemExitThrown &&
-      PyRun_SimpleString(GC_SCRIPT) == -1)
-      CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to run the gc to clean up after running prior to shutting down the Interpreter", GetId(), m_sourceFile.c_str());
-
-    Py_EndInterpreter(m_threadState);
-
-    // If we still have objects left around, produce an error message detailing what's been left behind
-    if (m_languageHook->HasRegisteredAddonClasses())
-      CLog::Log(LOGWARNING, "CPythonInvoker(%d, %s): the python script \"%s\" has left several "
-        "classes in memory that we couldn't clean up. The classes include: %s",
-        GetId(), m_sourceFile.c_str(), m_sourceFile.c_str(), getListOfAddonClassesAsString(m_languageHook).c_str());
-
-    // unregister the language hook
-    m_languageHook->UnregisterMe();
-
-    PyEval_ReleaseLock();
-
-    // set stopped event - this allows ::stop to run and kill remaining threads
-    // this event has to be fired without holding m_critical
-    // also the GIL (PyEval_AcquireLock) must not be held
-    // if not obeyed there is still no deadlock because ::stop waits with timeout (smart one!)
-    m_stoppedEvent.Set();
-
-    m_threadState = nullptr;
-
-    setState(InvokerStateExecutionDone);
-  }
-  ILanguageInvoker::onExecutionDone();
-}
-
 void CPythonInvoker::onExecutionFailed()
 {
   PyThreadState_Swap(NULL);
diff --git a/xbmc/interfaces/python/PythonInvoker.h b/xbmc/interfaces/python/PythonInvoker.h
index 41b459c4f9fc..d6f003027423 100644
--- a/xbmc/interfaces/python/PythonInvoker.h
+++ b/xbmc/interfaces/python/PythonInvoker.h
@@ -9,8 +9,6 @@
 #pragma once
 
 #include "interfaces/generic/ILanguageInvoker.h"
-#include "interfaces/legacy/Addon.h"
-#include "interfaces/python/LanguageHook.h"
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
 
@@ -18,8 +16,6 @@
 #include <string>
 #include <vector>
 
-struct _ts;
-
 class CPythonInvoker : public ILanguageInvoker
 {
 public:
@@ -37,7 +33,6 @@ class CPythonInvoker : public ILanguageInvoker
   bool execute(const std::string &script, const std::vector<std::string> &arguments) override;
   virtual void executeScript(void *fp, const std::string &script, void *module, void *moduleDict);
   bool stop(bool abort) override;
-  void onExecutionDone() override;
   void onExecutionFailed() override;
 
   // custom virtual methods
@@ -63,12 +58,9 @@ class CPythonInvoker : public ILanguageInvoker
   void getAddonModuleDeps(const ADDON::AddonPtr& addon, std::set<std::string>& paths);
 
   std::string m_pythonPath;
-  _ts *m_threadState;
+  void* m_threadState;
   bool m_stop;
   CEvent m_stoppedEvent;
 
-  XBMCAddon::AddonClass::Ref<XBMCAddon::Python::PythonLanguageHook> m_languageHook;
-  bool m_systemExitThrown = false;
-
   static CCriticalSection s_critical;
 };
diff --git a/xbmc/interfaces/python/XBPython.cpp b/xbmc/interfaces/python/XBPython.cpp
index 1494363b473e..d411b1c57ef7 100644
--- a/xbmc/interfaces/python/XBPython.cpp
+++ b/xbmc/interfaces/python/XBPython.cpp
@@ -680,7 +680,7 @@ void XBPython::OnScriptAbortRequested(ILanguageInvoker *invoker)
   }
 }
 
-void XBPython::OnExecutionEnded(ILanguageInvoker *invoker)
+void XBPython::OnScriptEnded(ILanguageInvoker* invoker)
 {
   CSingleLock lock(m_vecPyList);
   PyList::iterator it = m_vecPyList.begin();
@@ -689,9 +689,9 @@ void XBPython::OnExecutionEnded(ILanguageInvoker *invoker)
     if (it->id == invoker->GetId())
     {
       if (it->pyThread->IsStopping())
-        CLog::Log(LOGINFO, "Python interpreter interrupted by user");
+        CLog::Log(LOGINFO, "Python script interrupted by user");
       else
-        CLog::Log(LOGINFO, "Python interpreter stopped");
+        CLog::Log(LOGINFO, "Python script stopped");
       it->bDone = true;
     }
     ++it;
diff --git a/xbmc/interfaces/python/XBPython.h b/xbmc/interfaces/python/XBPython.h
index 817ce13c3ea3..c14ff0b65ba0 100644
--- a/xbmc/interfaces/python/XBPython.h
+++ b/xbmc/interfaces/python/XBPython.h
@@ -91,7 +91,7 @@ class XBPython :
   bool OnScriptInitialized(ILanguageInvoker *invoker) override;
   void OnScriptStarted(ILanguageInvoker *invoker) override;
   void OnScriptAbortRequested(ILanguageInvoker *invoker) override;
-  void OnExecutionEnded(ILanguageInvoker *invoker) override;
+  void OnScriptEnded(ILanguageInvoker* invoker) override;
   void OnScriptFinalized(ILanguageInvoker *invoker) override;
   ILanguageInvoker* CreateInvoker() override;
 
