From 8c6114db86a32b8146c472cd8470f5fb4f4c8270 Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Sun, 24 May 2020 07:34:11 +0100
Subject: [PATCH 1/4] Add custom collation (SQLite only) to do natural number
 alphanumeric sorting same as item lists but working efficiently in raw UTF8
 encoded data

---
 xbmc/dbwrappers/mysqldataset.cpp  |   6 +
 xbmc/dbwrappers/sqlitedataset.cpp |  12 ++
 xbmc/music/MusicDatabase.cpp      |  27 ++--
 xbmc/utils/StringUtils.cpp        | 223 +++++++++++++++++++++++++++---
 xbmc/utils/StringUtils.h          |   1 +
 5 files changed, 242 insertions(+), 27 deletions(-)

diff --git a/xbmc/dbwrappers/mysqldataset.cpp b/xbmc/dbwrappers/mysqldataset.cpp
index 6e71add2ce1e..1c399c692fd4 100644
--- a/xbmc/dbwrappers/mysqldataset.cpp
+++ b/xbmc/dbwrappers/mysqldataset.cpp
@@ -612,6 +612,12 @@ std::string MysqlDatabase::vprepare(const char *format, va_list args)
   while ((pos = strResult.find(" COLLATE NOCASE", pos)) != std::string::npos)
     strResult.erase(pos++, 15);
 
+  // Remove COLLATE ALPHANUM the SQLite custom collation.
+  // No cutom collation defined for MySQL yet
+  pos = 0;
+  while ((pos = strResult.find(" COLLATE ALPHANUM", pos)) != std::string::npos)
+    strResult.erase(pos++, 15);
+
   return strResult;
 }
 
diff --git a/xbmc/dbwrappers/sqlitedataset.cpp b/xbmc/dbwrappers/sqlitedataset.cpp
index 0c69a5bedf5c..803c27fa5275 100644
--- a/xbmc/dbwrappers/sqlitedataset.cpp
+++ b/xbmc/dbwrappers/sqlitedataset.cpp
@@ -284,6 +284,12 @@ const char *SqliteDatabase::getErrorMsg() {
    return error.c_str();
 }
 
+static int AlphaNumericCollation(
+    void* not_used, int nKey1, const void* pKey1, int nKey2, const void* pKey2)
+{
+  return StringUtils::AlphaNumericCollation(nKey1, pKey1, nKey2, pKey2);
+}
+
 int SqliteDatabase::connect(bool create) {
   if (host.empty() || db.empty())
     return DB_CONNECTION_NONE;
@@ -318,6 +324,12 @@ int SqliteDatabase::connect(bool create) {
         CLog::Log(LOGFATAL, "SqliteDatabase: %s is read only", db_fullpath.c_str());
         throw std::runtime_error("SqliteDatabase: " + db_fullpath + " is read only");
       }
+      errorCode = sqlite3_create_collation(conn, "ALPHANUM", SQLITE_UTF8, 0, AlphaNumericCollation);
+      if (errorCode != SQLITE_OK)
+      {
+        CLog::Log(LOGFATAL, "SqliteDatabase: can not register collation");
+        throw std::runtime_error("SqliteDatabase: can not register collation " + db_fullpath);
+      }
       active = true;
       return DB_CONNECTION_OK;
     }
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index a553cda927b1..d35d3108c4f9 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -7175,18 +7175,29 @@ std::string CMusicDatabase::SortnameBuildSQL(const std::string& strAlias,
 std::string CMusicDatabase::AlphanumericSortSQL(const std::string& strField, const SortOrder& sortOrder)
 {
   /*
-  Make sort of initial numbers natural, and case insensitive in SQLite.
-  Collation NOCASE ould be more efficient done in table create.
-  MySQL uses case insensitive utf8_general_ci collation defined for tables.
-  Use PrepareSQL to adjust syntax removing NOCASE and add AS UNSIGNED INTEGER
+  Use custom collation ALPHANUM in SQLite instead of NOCASE. This handles
+  natural number order, case sensitivity and locale UFT-8 order for accents
+  Would more efficient done in table create than per query especially once
+  sorting at db is done for GUI results too.
+  MySQL does not have custom collation defined (yet), but all tables are defined
+  with case insensitive utf8_general_ci collation. Make sort of numbers natural 
+  in SQL. No need to PrepareSQL as syntax is specific to db type.
   */
   std::string DESC;
   if (sortOrder == SortOrderDescending)
     DESC = " DESC";
-  return PrepareSQL("CASE WHEN CAST(%s AS INTEGER) = 0 "
-    "THEN 100000000 ELSE CAST(%s AS INTEGER) END%s, "
-    "%s COLLATE NOCASE%s",
-    strField.c_str(), strField.c_str(), DESC.c_str(), strField.c_str(), DESC.c_str());
+  std::string strSort;
+
+  if (StringUtils::EqualsNoCase(
+          CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_databaseMusic.type,
+          "mysql"))
+    strSort = PrepareSQL("CASE WHEN CAST(%s AS UNSIGNED INTEGER) = 0 "
+                         "THEN 100000000 ELSE CAST(%s AS UNSIGNED INTEGER) END%s, %s%s",
+                         strField.c_str(), strField.c_str(), DESC.c_str(), strField.c_str(),
+                         DESC.c_str());
+  else
+    strSort = PrepareSQL("%s COLLATE ALPHANUM%s", strField.c_str(), DESC.c_str());
+  return strSort;
 }
 
 void CMusicDatabase::UpdateTables(int version)
diff --git a/xbmc/utils/StringUtils.cpp b/xbmc/utils/StringUtils.cpp
index d7b5ffa5ff05..a49d20f4b040 100644
--- a/xbmc/utils/StringUtils.cpp
+++ b/xbmc/utils/StringUtils.cpp
@@ -1009,7 +1009,7 @@ static const uint16_t* const planemap[256] = {
 
 static wchar_t GetCollationWeight(const wchar_t& r)
 {
-  // Lookup the "weight" of a UFT8 char, equivalent lowercase ascii letter, in the plane map,
+  // Lookup the "weight" of a UTF8 char, equivalent lowercase ascii letter, in the plane map,
   // the character comparison value used by using "accent folding" collation utf8_general_ci
   // in MySQL (AKA utf8mb3_general_ci in MariaDB 10)
   auto index = r >> 8;
@@ -1021,9 +1021,10 @@ static wchar_t GetCollationWeight(const wchar_t& r)
   return static_cast<wchar_t>(plane[r & 0xFF]);
 }
 
-// Compares separately the numeric and alphabetic parts of a string.
+// Compares separately the numeric and alphabetic parts of a wide string.
 // returns negative if left < right, positive if left > right
-// and 0 if they are identical
+// and 0 if they are identical.
+// See also the equivalent StringUtils::AlphaNumericCollation() for UFT8 data
 int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* right)
 {
   const wchar_t *l = left;
@@ -1038,14 +1039,14 @@ int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* rig
     if (*l >= L'0' && *l <= L'9' && *r >= L'0' && *r <= L'9')
     {
       ld = l;
-      lnum = 0;
+      lnum = *ld++ - L'0';
       while (*ld >= L'0' && *ld <= L'9' && ld < l + 15)
       { // compare only up to 15 digits
         lnum *= 10;
         lnum += *ld++ - L'0';
       }
       rd = r;
-      rnum = 0;
+      rnum = *rd++ - L'0';
       while (*rd >= L'0' && *rd <= L'9' && rd < r + 15)
       { // compare only up to 15 digits
         rnum *= 10;
@@ -1063,6 +1064,29 @@ int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* rig
 
     lc = *l;
     rc = *r;
+    // Put ascii punctuation and symbols e.g. !#$&()*+,-./:;<=>?@[\]^_ `{|}~ above the other
+    // alphanumeric ascii, rather than some being mixed between the numbers and letters, and
+    // above all other unicode letters, symbols and punctuation.
+    // (Locale collation of these chars varies across platforms)
+    lsym = (lc >= 32 && lc < L'0') || (lc > L'9' && lc < L'A') || 
+           (lc > L'Z' && lc < L'a') || (lc > L'z' && lc < 128);
+    rsym = (rc >= 32 && rc < L'0') || (rc > L'9' && rc < L'A') || 
+           (rc > L'Z' && rc < L'a') || (rc > L'z' && rc < 128);
+    if (lsym && !rsym)
+      return -1;
+    if (!lsym && rsym)
+      return 1;
+    if (lsym && rsym)
+    {
+      if (lc != rc)
+        return lc - rc;
+      else
+      { // Same symbol advance to next wchar
+        l++; 
+        r++;
+        continue;
+      }
+    }
     if (!g_langInfo.UseLocaleCollation())
     {
       // Apply case sensitive accent folding collation to non-ascii chars.
@@ -1078,20 +1102,9 @@ int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* rig
       lc += L'a' - L'A';
     if (rc >= L'A' && rc <= L'Z')
       rc += L'a' - L'A';
+
     if (lc != rc)
     {
-      // Put ascii punctuation and symbols e.g. !#$&()*+,-./:;<=>?@[\]^_ `{|}~ above the other
-      // alphanumeric ascii, rather than some being mixed between the numbers and letters, and
-      // above all other unicode letters, symbols and punctuation.
-      // (Locale collation of these chars varies across platforms)
-      lsym = lc < 128 && !(lc >= L'a' && lc <= L'z') && !(lc >= L'0' && lc <= L'9');
-      rsym = rc < 128 && !(rc >= L'a' && rc <= L'z') && !(rc >= L'0' && rc <= L'9');
-      if (lsym && !rsym)
-        return -1;
-      if (!lsym && rsym)
-        return 1;
-
-      // Either both or neither are ascii symbols or punctuation marks
       if (!g_langInfo.UseLocaleCollation())
       {
         // Compare unicode (having applied accent folding collation to non-ascii chars).
@@ -1104,8 +1117,7 @@ int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* rig
         // platforms this is not langauge specific but just compares unicode
         const std::collate<wchar_t>& coll =
             std::use_facet<std::collate<wchar_t>>(g_langInfo.GetSystemLocale());
-        int cmp_res = 0;
-        cmp_res = coll.compare(&lc, &lc + 1, &rc, &rc + 1);
+        int cmp_res = coll.compare(&lc, &lc + 1, &rc, &rc + 1);
         if (cmp_res != 0)
           return cmp_res;
       }
@@ -1123,6 +1135,179 @@ int64_t StringUtils::AlphaNumericCompare(const wchar_t* left, const wchar_t* rig
   return 0; // files are the same
 }
 
+/*
+  Convert the UTF8 character to which z points into a 31-bit Unicode point.
+  Return how many bytes (0 to 3) of UTF8 data encode the character.
+  This only works right if z points to a well-formed UTF8 string.
+  Byte-0    Byte-1    Byte-2    Byte-3     Value
+  0xxxxxxx                                 00000000 00000000 0xxxxxxx
+  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx
+  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx
+  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx
+*/
+static uint32_t UTF8ToUnicode(const unsigned char* z, int nKey, unsigned char& bytes)
+{
+  // Lookup table used decode the first byte of a multi-byte UTF8 character
+  // clang-format off
+  static const unsigned char utf8Trans1[] = {
+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+    0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
+  };
+  // clang-format on
+
+  uint32_t c;
+  bytes = 0;
+  c = z[0];
+  if (c >= 0xc0)
+  {
+    c = utf8Trans1[c - 0xc0];
+    int index = 1;
+    while (index < nKey && (z[index] & 0xc0) == 0x80)
+    {
+      c = (c << 6) + (0x3f & z[index]);
+      index++;
+    }
+    if (c < 0x80 || (c & 0xFFFFF800) == 0xD800 || (c & 0xFFFFFFFE) == 0xFFFE)
+      c = 0xFFFD;
+    bytes = static_cast<unsigned char>(index - 1);
+  }
+  return c;
+}
+
+/*
+  SQLite collating function, see sqlite3_create_collation
+  The equivalent of AlphaNumericCompare() but for comparing UTF8 encoded data
+
+  This only processes enough data to find a difference, and avoids expensive data conversions.
+  When sorting in memory item data is converted once to wstring in advance prior to sorting, the
+  SQLite callback function can not do that kind of preparation. Instead, in order to use
+  AlphaNumericCompare(), it would have to repeatedly convert the full input data to wstring for
+  every pair comparison made. That approach was found to be 10 times slower than using this
+  separate routine.
+*/
+int StringUtils::AlphaNumericCollation(int nKey1, const void* pKey1, int nKey2, const void* pKey2)
+{
+  // Get exact matches of shorter text to start of larger test fast
+  int n = std::min(nKey1, nKey2);
+  int r = memcmp(pKey1, pKey2, n);
+  if (r == 0)
+    return nKey1 - nKey2;
+
+  //Not a binary match, so process character at a time
+  const unsigned char* zA = static_cast<const unsigned char*>(pKey1);
+  const unsigned char* zB = static_cast<const unsigned char*>(pKey2);
+  wchar_t lc, rc;
+  unsigned char bytes;
+  int64_t lnum, rnum;
+  bool lsym, rsym;
+  int ld, rd;
+  int i = 0;
+  int j = 0;
+  // Looping Unicode point at a time through potentially 1 to 4 multi-byte encoded UTF8 data
+  while (i < nKey1 && j < nKey2)
+  {
+    // Check if we have numerical values, compare only up to 15 digits
+    if (isdigit(zA[i]) && isdigit(zB[j]))
+    {
+      lnum = zA[i] - '0';
+      ld = i + 1;
+      while (ld < nKey1 && isdigit(zA[ld]) && ld < i + 15)
+      {
+        lnum *= 10;
+        lnum += zA[ld] - '0';
+        ld++;
+      }
+      rnum = zB[j] - '0';
+      rd = j + 1;
+      while (rd < nKey2 && isdigit(zB[rd]) && rd < j + 15)
+      {
+        rnum *= 10;
+        rnum += zB[rd] - '0';
+        rd++;
+      }
+      // do we have numbers?
+      if (lnum != rnum)
+      { // yes - and they're different!
+        return lnum - rnum;
+      }
+      // Advance to after digits
+      i = ld;
+      j = rd;
+      continue;
+    }
+    // Put ascii punctuation and symbols e.g. !#$&()*+,-./:;<=>?@[\]^_ `{|}~ before the other
+    // alphanumeric ascii, rather than some being mixed between the numbers and letters, and
+    // above all other unicode letters, symbols and punctuation.
+    // (Locale collation of these chars varies across platforms)
+    lsym = (zA[i] >= 32 && zA[i] < '0') || (zA[i] > '9' && zA[i] < 'A') ||
+           (zA[i] > 'Z' && zA[i] < 'a') || (zA[i] > 'z' && zA[i] < 128);
+    rsym = (zB[j] >= 32 && zB[j] < '0') || (zB[j] > '9' && zB[j] < 'A') ||
+           (zB[j] > 'Z' && zB[j] < 'a') || (zB[j] > 'z' && zB[j] < 128);
+    if (lsym && !rsym)
+      return -1;
+    if (!lsym && rsym)
+      return 1;
+    if (lsym && rsym)
+    {
+      if (zA[i] != zB[j])
+        return zA[i] - zB[j];
+      else
+      { // Same symbol advance to next
+        i++;
+        j++;
+        continue;
+      }
+    }
+    //Decode single (1 to 4 bytes) UTF8 character to Unicode
+    lc = UTF8ToUnicode(&zA[i], nKey1 - i, bytes);
+    i += bytes;
+    rc = UTF8ToUnicode(&zB[j], nKey2 - j, bytes);
+    j += bytes;
+    if (!g_langInfo.UseLocaleCollation())
+    {
+      // Apply case sensitive accent folding collation to non-ascii chars.
+      // This mimics utf8_general_ci collation, and provides simple collation of LATIN-1 chars
+      // for any platform that doesn't have a language specific collate facet implemented
+      if (lc > 128)
+        lc = GetCollationWeight(lc);
+      if (rc > 128)
+        rc = GetCollationWeight(rc);
+    }
+    // Caseless comparison so convert ascii upper case to lower case
+    if (lc >= 'A' && lc <= 'Z')
+      lc += 'a' - 'A';
+    if (rc >= 'A' && rc <= 'Z')
+      rc += 'a' - 'A';
+
+    if (lc != rc)
+    {
+      if (!g_langInfo.UseLocaleCollation() || (lc <= 128 && rc <= 128))
+        // Compare unicode (having applied accent folding collation to non-ascii chars).
+        return lc - rc;
+      else
+      {
+        // Fetch collation facet from locale to do comparison of wide char although on some
+        // platforms this is not langauge specific but just compares unicode
+        const std::collate<wchar_t>& coll =
+            std::use_facet<std::collate<wchar_t>>(g_langInfo.GetSystemLocale());
+        int cmp_res = coll.compare(&lc, &lc + 1, &rc, &rc + 1);
+        if (cmp_res != 0)
+          return cmp_res;
+      }
+    }
+    i++;
+    j++;
+  }
+  // Compared characters of shortest are the same as longest, length determines order
+  return (nKey1 - nKey2);
+}
+
 int StringUtils::DateStringToYYYYMMDD(const std::string &dateString)
 {
   std::vector<std::string> days = StringUtils::Split(dateString, '-');
diff --git a/xbmc/utils/StringUtils.h b/xbmc/utils/StringUtils.h
index 4188af829145..6aab4cd1e6fe 100644
--- a/xbmc/utils/StringUtils.h
+++ b/xbmc/utils/StringUtils.h
@@ -245,6 +245,7 @@ class StringUtils
   static std::vector<std::string> SplitMulti(const std::vector<std::string> &input, const std::vector<std::string> &delimiters, unsigned int iMaxStrings = 0);
   static int FindNumber(const std::string& strInput, const std::string &strFind);
   static int64_t AlphaNumericCompare(const wchar_t *left, const wchar_t *right);
+  static int AlphaNumericCollation(int nKey1, const void* pKey1, int nKey2, const void* pKey2);
   static long TimeStringToSeconds(const std::string &timeString);
   static void RemoveCRLF(std::string& strLine);
 

From e2a731775d37d5adc481021372a1ba77b478093f Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Sat, 28 Mar 2020 17:20:26 +0000
Subject: [PATCH 2/4] Add native stored functions to do natural number sorting
 in MySQL. Bump to MyMusic76 for this.

---
 xbmc/dbwrappers/mysqldataset.cpp |  29 ++++++-
 xbmc/music/MusicDatabase.cpp     | 145 ++++++++++++++++++++++++++++---
 xbmc/music/MusicDatabase.h       |   1 +
 3 files changed, 159 insertions(+), 16 deletions(-)

diff --git a/xbmc/dbwrappers/mysqldataset.cpp b/xbmc/dbwrappers/mysqldataset.cpp
index 1c399c692fd4..b0ec34e001d8 100644
--- a/xbmc/dbwrappers/mysqldataset.cpp
+++ b/xbmc/dbwrappers/mysqldataset.cpp
@@ -435,7 +435,33 @@ int MysqlDatabase::drop_analytics(void) {
       if ( (ret=query_with_reconnect(sql)) != MYSQL_OK )
       {
         mysql_free_result(res);
-        throw DbErrors("Can't create trigger '%s'\nError: %d", row[0], ret);
+        throw DbErrors("Can't drop trigger '%s'\nError: %d", row[0], ret);
+      }
+    }
+    mysql_free_result(res);
+  }
+
+  // Native functions
+  sprintf(sql,
+          "SELECT routine_name "
+          "FROM information_schema.routines "
+          "WHERE routine_type = 'FUNCTION' and routine_schema = '%s'",
+          db.c_str());
+  if ((ret = query_with_reconnect(sql)) != MYSQL_OK)
+    throw DbErrors("Can't determine list of routines to drop.");
+
+  res = mysql_store_result(conn);
+
+  if (res)
+  {
+    while ((row = mysql_fetch_row(res)) != NULL)
+    {
+      sprintf(sql, "DROP FUNCTION `%s`.%s", db.c_str(), row[0]);
+
+      if ((ret = query_with_reconnect(sql)) != MYSQL_OK)
+      {
+        mysql_free_result(res);
+        throw DbErrors("Can't drop function '%s'\nError: %d", row[0], ret);
       }
     }
     mysql_free_result(res);
@@ -613,7 +639,6 @@ std::string MysqlDatabase::vprepare(const char *format, va_list args)
     strResult.erase(pos++, 15);
 
   // Remove COLLATE ALPHANUM the SQLite custom collation.
-  // No cutom collation defined for MySQL yet
   pos = 0;
   while ((pos = strResult.find(" COLLATE ALPHANUM", pos)) != std::string::npos)
     strResult.erase(pos++, 15);
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index d35d3108c4f9..0380f755aee0 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -191,7 +191,8 @@ void CMusicDatabase::CreateTables()
               " lastplayed varchar(20) default NULL, "
               " rating FLOAT NOT NULL DEFAULT 0, votes INTEGER NOT NULL DEFAULT 0, "
               " userrating INTEGER NOT NULL DEFAULT 0, "
-              " comment text, mood text, iBPM integer, iBitRate INTEGER NOT NULL DEFAULT 0, "
+              " comment text, mood text, iBPM INTEGER NOT NULL DEFAULT 0, "
+              " iBitRate INTEGER NOT NULL DEFAULT 0, "
               " iSampleRate INTEGER NOT NULL DEFAULT 0, iChannels INTEGER NOT NULL DEFAULT 0, "
               " strReplayGain text, dateAdded text)");
   CLog::Log(LOGINFO, "create song_artist table");
@@ -288,7 +289,10 @@ void CMusicDatabase::CreateAnalytics()
               "  DELETE FROM source_path WHERE source_path.idSource = old.idSource;"
               "  DELETE FROM album_source WHERE album_source.idSource = old.idSource;"
               " END");
-  
+
+  // Create native functions stored in DB (MySQL/MariaDB only)
+  CreateNativeDBFunctions();
+
   // we create views last to ensure all indexes are rolled in
   CreateViews();
 
@@ -414,6 +418,120 @@ void CMusicDatabase::CreateViews()
               "     song_artist.idRole = role.idRole");
 }
 
+void CMusicDatabase::CreateNativeDBFunctions()
+{
+  // Create native functions in MySQL/MariaDB database only
+  if (!StringUtils::EqualsNoCase(
+          CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_databaseMusic.type,
+          "mysql"))
+    return;
+  CLog::Log(LOGINFO, "Create native MySQL/MariaDB functions");
+  /* Functions to do the natural number sorting and all ascii symbol char at top adjustments to
+     default utf8_general_ci collation that SQLite does via a collation sequence callback
+     function to StringUtils::AlphaNumericCompare
+     !@todo: the video needs these defined too for sorting in DB, then creation can be made common
+  */
+  // clang-format off
+  // udfFirstNumberPos finds the position of the first digit in a string
+  m_pDS->exec("DROP FUNCTION IF EXISTS udfFirstNumberPos");
+  m_pDS->exec("CREATE FUNCTION udfFirstNumberPos (instring VARCHAR(256))\n"
+    "RETURNS int \n"
+    "LANGUAGE SQL \n"
+    "DETERMINISTIC \n"
+    "NO SQL \n"
+    "SQL SECURITY INVOKER \n"
+    "BEGIN \n"
+    "  DECLARE position int; \n"
+    "  DECLARE tmppos int; \n"
+    "  SET position = 1000; \n"
+    "  SET tmppos = LOCATE('0', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('1', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('2', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('3', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('4', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('5', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('6', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('7', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('8', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  SET tmppos = LOCATE('9', instring); IF(tmppos > 0 AND tmppos < position) THEN SET position = tmppos; END IF;\n"
+    "  IF(position = 1000) THEN RETURN 0; END IF;\n"
+    "  RETURN position; \n"
+    "END\n");
+
+  // udfSymbolShift adds "/" (the  last symbol before "0"), in front any of the chars input
+  m_pDS->exec("DROP FUNCTION IF EXISTS udfSymbolShift");
+  m_pDS->exec("CREATE FUNCTION udfSymbolShift(instring varchar(256), symbolChars char(25))\n"
+    "RETURNS varchar(256)\n"
+    "LANGUAGE SQL\n"
+    "DETERMINISTIC\n"
+    "NO SQL\n"
+    "SQL SECURITY INVOKER\n"
+    "BEGIN\n"
+    "  DECLARE sortString varchar(256);\n"
+    "  DECLARE i int;\n"
+    "  DECLARE symbolCharsLen int;\n"
+    "  DECLARE symbol char(1);\n"
+    "  SET sortString = instring;\n"
+    "  SET i = 1;\n"
+    "  SET symbolCharsLen = CHAR_LENGTH(symbolChars);\n"
+    "  WHILE(i <= symbolCharsLen) DO\n"
+    "    SET symbol = SUBSTRING(symbolChars, i, 1);\n"
+    "    SET sortString = REPLACE(sortString, symbol, CONCAT('/', symbol));\n"
+    "    SET i = i + 1;\n"
+    "  END WHILE;\n"
+    "  RETURN sortString;\n"
+    "END\n");
+
+  // udfNaturalSortFormat - provide natural number sorting and ascii symbols above numbers
+  m_pDS->exec("DROP FUNCTION IF EXISTS udfNaturalSortFormat");
+  m_pDS->exec("CREATE FUNCTION udfNaturalSortFormat(instring varchar(256), numberLength int, "
+    "sameOrderChars char(25))\n"
+    "RETURNS varchar(256)\n"
+    "LANGUAGE SQL\n"
+    "DETERMINISTIC\n"
+    "NO SQL\n"
+    "SQL SECURITY INVOKER\n"
+    "BEGIN\n"
+    "  DECLARE sortString varchar(256);\n"
+    "  DECLARE numStartIndex int; \n"
+    "  DECLARE numEndIndex int; \n"
+    "  DECLARE padLength int; \n"
+    "  DECLARE totalPadLength int; \n"
+    "  DECLARE i int; \n"
+    "  DECLARE sameOrderCharsLen int;\n"
+    "  SET totalPadLength = 0; \n"
+    "  SET instring = TRIM(instring); \n"
+    "  SET sortString = instring; \n"
+    "  SET numStartIndex = udfFirstNumberPos(instring); \n"
+    "  SET numEndIndex = 0; \n"
+    "  SET i = 1; \n"
+    "  SET sameOrderCharsLen = CHAR_LENGTH(sameOrderChars); \n"
+    "  WHILE(i <= sameOrderCharsLen) DO \n"
+    "    SET sortString = REPLACE(sortString, SUBSTRING(sameOrderChars, i, 1), ' '); \n"
+    "    SET i = i + 1; \n"
+    "  END WHILE; \n"
+    "  WHILE(numStartIndex <> 0) DO \n"
+    "    SET numStartIndex = numStartIndex + numEndIndex; \n"
+    "    SET numEndIndex = numStartIndex; \n"
+    "    WHILE(udfFirstNumberPos(SUBSTRING(instring, numEndIndex, 1)) = 1) DO \n"
+    "      SET numEndIndex = numEndIndex + 1; \n"
+    "    END WHILE; \n"
+    "    SET numEndIndex = numEndIndex - 1; \n"
+    "    SET padLength = numberLength - (numEndIndex + 1 - numStartIndex); \n"
+    "    IF padLength < 0 THEN \n"
+    "      SET padLength = 0; \n"
+    "    END IF; \n"
+    "    SET sortString = INSERT(sortString, numStartIndex + totalPadLength, 0, REPEAT('0', padLength)); \n"
+    "    SET totalPadLength = totalPadLength + padLength; \n"
+    "    SET numStartIndex = udfFirstNumberPos(RIGHT(instring, CHAR_LENGTH(instring) - numEndIndex)); \n"
+    "  END WHILE; \n"
+    // Shift ascii symbols :;<=>?@[\]^_ `{|}~ above 0, note "\" needs escaping
+    "  SET sortString = udfSymbolShift(sortString, ':;<=>?@[\\]^_`{|}~'); \n"
+    "  RETURN sortString; \n"
+    "END\n");
+  // clang-format on
+}
+
 void CMusicDatabase::SplitPath(const std::string& strFileNameAndPath, std::string& strPath, std::string& strFileName)
 {
   URIUtils::Split(strFileNameAndPath, strPath, strFileName);
@@ -7175,13 +7293,15 @@ std::string CMusicDatabase::SortnameBuildSQL(const std::string& strAlias,
 std::string CMusicDatabase::AlphanumericSortSQL(const std::string& strField, const SortOrder& sortOrder)
 {
   /*
-  Use custom collation ALPHANUM in SQLite instead of NOCASE. This handles
-  natural number order, case sensitivity and locale UFT-8 order for accents
-  Would more efficient done in table create than per query especially once
-  sorting at db is done for GUI results too.
-  MySQL does not have custom collation defined (yet), but all tables are defined
-  with case insensitive utf8_general_ci collation. Make sort of numbers natural 
-  in SQL. No need to PrepareSQL as syntax is specific to db type.
+  Use custom collation ALPHANUM in SQLite. This handles natural number order, case sensitivity
+  and locale UFT-8 order for accents using the same functionality as fileitem list sorting.
+  Natural number order is not significant for where clause comparison and use of calculated fields
+  means there is no advantage in defining as column defualt in table create than per query (which
+  also makes looking at the db with other tools difficult).
+
+  MySQL does not have callback collation, but all tables are defined with utf8_general_ci an
+  "ascii folding" case insensitive collation. Natural sorting is provided via native functions
+  stored in the db.
   */
   std::string DESC;
   if (sortOrder == SortOrderDescending)
@@ -7191,10 +7311,7 @@ std::string CMusicDatabase::AlphanumericSortSQL(const std::string& strField, con
   if (StringUtils::EqualsNoCase(
           CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_databaseMusic.type,
           "mysql"))
-    strSort = PrepareSQL("CASE WHEN CAST(%s AS UNSIGNED INTEGER) = 0 "
-                         "THEN 100000000 ELSE CAST(%s AS UNSIGNED INTEGER) END%s, %s%s",
-                         strField.c_str(), strField.c_str(), DESC.c_str(), strField.c_str(),
-                         DESC.c_str());
+    strSort = PrepareSQL("udfNaturalSortFormat(%s, 8, '.')%s", strField.c_str(), DESC.c_str());
   else
     strSort = PrepareSQL("%s COLLATE ALPHANUM%s", strField.c_str(), DESC.c_str());
   return strSort;
@@ -7972,7 +8089,7 @@ void CMusicDatabase::UpdateTables(int version)
 
 int CMusicDatabase::GetSchemaVersion() const
 {
-  return 75;
+  return 76; // Bumped for addition of functions to MySQL, SQLite v76 = v75
 }
 
 int CMusicDatabase::GetMusicNeedsTagScan()
diff --git a/xbmc/music/MusicDatabase.h b/xbmc/music/MusicDatabase.h
index a531fa77c11c..a0e5536145aa 100644
--- a/xbmc/music/MusicDatabase.h
+++ b/xbmc/music/MusicDatabase.h
@@ -692,6 +692,7 @@ void SetLibraryLastUpdated();
   /*! \brief (Re)Create the generic database views for songs and albums
    */
   virtual void CreateViews();
+  void CreateNativeDBFunctions();
 
   void SplitPath(const std::string& strFileNameAndPath, std::string& strPath, std::string& strFileName);
 

From 46cbcabd889334aac1ed3440999da9458a750bf0 Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Mon, 30 Mar 2020 13:16:46 +0100
Subject: [PATCH 3/4] Use order by clauses when fetching songs, album and
 artists. Make music nodes and smartplaylists faster by avoiding needless
 expensive URL decoding and checking in FillInDefaultIcon

---
 xbmc/FileItem.cpp            |   2 +-
 xbmc/FileItem.h              |   3 +
 xbmc/music/MusicDatabase.cpp | 223 +++++++++++++++++++++++------------
 3 files changed, 149 insertions(+), 79 deletions(-)

diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index 9f61e78746bc..6ef8b42cb91c 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -1410,7 +1410,7 @@ void CFileItem::FillInDefaultIcon()
     }
   }
   // Set the icon overlays (if applicable)
-  if (!HasOverlay())
+  if (!HasOverlay() && !HasProperty("icon_never_overlay"))
   {
     if (URIUtils::IsInRAR(m_strPath))
       SetOverlayImage(CGUIListItem::ICON_OVERLAY_RAR);
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index e08808f7e427..347009d7d1e3 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -690,6 +690,9 @@ class CFileItemList : public CFileItem
 
   SortOrder GetSortOrder() const { return m_sortDescription.sortOrder; }
   SortBy GetSortMethod() const { return m_sortDescription.sortBy; }
+  void SetSortOrder(SortOrder sortOrder) { m_sortDescription.sortOrder = sortOrder; }
+  void SetSortMethod(SortBy sortBy) { m_sortDescription.sortBy = sortBy; }
+
   /*! \brief load a CFileItemList out of the cache
 
    The file list may be cached based on which window we're viewing in, as different
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index 0380f755aee0..589ab50143b8 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -4670,18 +4670,21 @@ bool CMusicDatabase::GetArtistsByWhere(const std::string& strBaseDir, const Filt
     {
       extFilter.limit =
           DatabaseUtils::BuildLimitClauseOnly(sortDescription.limitEnd, sortDescription.limitStart);
-      const std::shared_ptr<CSettings> settings =
-          CServiceBroker::GetSettingsComponent()->GetSettings();
-      if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
-        sorting.sortAttributes =
-            static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
-      // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
-      GetOrderFilter(MediaTypeArtist, sorting, extFilter);
-      strSQLExtra.clear();
-      if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
-        return false;
     }
 
+    // Apply sort in SQL
+    const std::shared_ptr<CSettings> settings =
+        CServiceBroker::GetSettingsComponent()->GetSettings();
+    if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
+      sorting.sortAttributes =
+          static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
+    // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
+    GetOrderFilter(MediaTypeArtist, sorting, extFilter);
+
+    strSQLExtra.clear();
+    if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
+      return false;
+
     std::string strSQL;
     std::string strFields = "artistview.*";
     if (!extFilter.fields.empty() && extFilter.fields.compare("*") != 0)
@@ -4708,12 +4711,13 @@ bool CMusicDatabase::GetArtistsByWhere(const std::string& strBaseDir, const Filt
 
     DatabaseResults results;
     results.reserve(iRowsFound);
-    // Avoid sorting when populating results when have limits so already sorted in SQL
-    sorting = sortDescription;
-    if (limitedInSQL)
-      sorting.sortBy = SortByNone;
-    if (!SortUtils::SortFromDataset(sorting, MediaTypeArtist, m_pDS, results))
+    // Populate results field vector from dataset
+    FieldList fields;
+    if (!DatabaseUtils::GetDatabaseResults(MediaTypeArtist, fields, m_pDS, results))
       return false;
+    // Store item list sort order
+    items.SetSortMethod(sortDescription.sortBy);
+    items.SetSortOrder(sortDescription.sortOrder);
 
     // Get Artists from returned rows
     items.Reserve(results.size());
@@ -4734,6 +4738,8 @@ bool CMusicDatabase::GetArtistsByWhere(const std::string& strBaseDir, const Filt
         pItem->SetPath(itemUrl.ToString());
 
         pItem->GetMusicInfoTag()->SetDatabaseId(artist.idArtist, MediaTypeArtist);
+        // Set icon now to avoid slow per item processing in FillInDefaultIcon later
+        pItem->SetProperty("icon_never_overlay", true);
         pItem->SetArt("icon", "DefaultArtist.png");
 
         SetPropertiesFromArtist(*pItem, artist);
@@ -4745,7 +4751,6 @@ bool CMusicDatabase::GetArtistsByWhere(const std::string& strBaseDir, const Filt
         CLog::Log(LOGERROR, "%s - out of memory getting listing (got %i)", __FUNCTION__, items.Size());
       }
     }
-
     // cleanup
     m_pDS->close();
 
@@ -4872,23 +4877,32 @@ bool CMusicDatabase::GetAlbumsByWhere(const std::string &baseDir, const Filter &
       return true;
     }
 
-    // Apply any limiting directly in SQL and so sort as well
+    // Apply any limiting directly in SQL
     if (limitedInSQL)
     {
       extFilter.limit =
           DatabaseUtils::BuildLimitClauseOnly(sortDescription.limitEnd, sortDescription.limitStart);
-      const std::shared_ptr<CSettings> settings =
-          CServiceBroker::GetSettingsComponent()->GetSettings();
-      if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
-        sorting.sortAttributes =
-            static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
-      // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
-      GetOrderFilter(MediaTypeAlbum, sorting, extFilter);
-      strSQLExtra.clear();
-      if(!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
-        return false;
     }
 
+    // Apply sort in SQL
+    const std::shared_ptr<CSettings> settings =
+        CServiceBroker::GetSettingsComponent()->GetSettings();
+    if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
+      sorting.sortAttributes =
+          static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
+    // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
+    GetOrderFilter(MediaTypeAlbum, sorting, extFilter);
+    // Modify order to use correct calculated year field
+    if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+            CSettings::SETTING_MUSICLIBRARY_USEORIGINALDATE))
+      StringUtils::Replace(extFilter.order, "iYear", "CAST(strReleaseDate AS INTEGER)");
+    else
+      StringUtils::Replace(extFilter.order, "iYear", "CAST(strOrigReleaseDate AS INTEGER)");
+
+    strSQLExtra.clear();
+    if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
+      return false;
+
     std::string strSQL;
     std::string strFields = "albumview.*";
     if (!extFilter.fields.empty() && extFilter.fields.compare("*") != 0)
@@ -4915,15 +4929,16 @@ bool CMusicDatabase::GetAlbumsByWhere(const std::string &baseDir, const Filter &
 
     DatabaseResults results;
     results.reserve(iRowsFound);
-    // Avoid sorting when populating results when have limits as already sorted in SQL
-    sorting = sortDescription;
-    if (limitedInSQL)
-      sorting.sortBy = SortByNone;
-    if (!SortUtils::SortFromDataset(sorting, MediaTypeAlbum, m_pDS, results))
+    // Populate results field vector from dataset
+    FieldList fields;
+    if (!DatabaseUtils::GetDatabaseResults(MediaTypeAlbum, fields, m_pDS, results))
       return false;
+    // Store item list sort order
+    items.SetSortMethod(sortDescription.sortBy);
+    items.SetSortOrder(sortDescription.sortOrder);
 
     // Get albums from returned rows
-    items.Reserve(total);
+    items.Reserve(results.size());
     const dbiplus::query_data &data = m_pDS->get_result_set().records;
     for (const auto &i : results)
     {
@@ -4937,6 +4952,8 @@ bool CMusicDatabase::GetAlbumsByWhere(const std::string &baseDir, const Filter &
         itemUrl.AppendPath(path);
 
         CFileItemPtr pItem(new CFileItem(itemUrl.ToString(), GetAlbumFromDataset(record)));
+        // Set icon now to avoid slow per item processing in FillInDefaultIcon later
+        pItem->SetProperty("icon_never_overlay", true);
         pItem->SetArt("icon", "DefaultAlbumCover.png");
         items.Add(pItem);
       }
@@ -5138,6 +5155,8 @@ bool CMusicDatabase::GetDiscsByWhere(CMusicDbUrl& musicUrl,
         pItem->GetMusicInfoTag()->SetDiscNumber(discnum);
         pItem->GetMusicInfoTag()->SetTitle(strDiscSubtitle);
         pItem->SetLabel(strDiscSubtitle);
+        // Set icon now to avoid slow per item processing in FillInDefaultIcon later
+        pItem->SetProperty("icon_never_overlay", true);
         pItem->SetArt("icon", "DefaultAlbumCover.png");
         items.Add(pItem);
       }
@@ -5186,9 +5205,9 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
 
   try
   {
+    unsigned int querytime = 0;
     unsigned int time = XbmcThreads::SystemClockMillis();
     int total = -1;
-    bool extended = false;
 
     Filter extFilter = filter;
     CMusicDbUrl musicUrl;
@@ -5196,6 +5215,10 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
     if (!musicUrl.FromString(baseDir) || !GetFilter(musicUrl, extFilter, sorting))
       return false;
 
+    bool extended = false;
+    bool limitedInSQL =
+        extFilter.limit.empty() && (sortDescription.limitStart > 0 || sortDescription.limitEnd > 0);
+
     // If there are extra WHERE conditions (from media filter dialog) we might
     // need access to albumview for these conditions
     if (extFilter.where.find("albumview") != std::string::npos)
@@ -5204,69 +5227,110 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
       extFilter.AppendJoin("JOIN albumview ON albumview.idAlbum = songview.idAlbum");
     }
 
+    // Build songview <where> for count
     std::string strSQLExtra;
     if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
       return false;
 
     // Count (without group by) number of songs that satisfy selection criteria
+    // Much quicker to use song table, not songview, when filtering only on song fields
     std::string strValue;
-    strValue = GetSingleValue("SELECT COUNT(1) FROM songview " + strSQLExtra, m_pDS);
+    if (extended ||
+        (!extFilter.where.empty() && (extFilter.where.find("strAlbum") != std::string::npos ||
+                                      extFilter.where.find("strPath") != std::string::npos ||
+                                      extFilter.where.find("bCompilation") != std::string::npos ||
+                                      extFilter.where.find("bBoxedset") != std::string::npos)))
+      strValue = GetSingleValue("SELECT COUNT(1) FROM songview " + strSQLExtra, m_pDS);
+    else
+    {
+      std::string strSQLsong = strSQLExtra;
+      StringUtils::Replace(strSQLsong, "songview", "song");
+      strValue = GetSingleValue("SELECT COUNT(1) FROM song " + strSQLsong, m_pDS);
+    }
     total = static_cast<int>(strtol(strValue.c_str(), NULL, 10));
 
     if (extended)
       extFilter.AppendGroup("songview.idSong");
 
-    // Apply any limiting directly in SQL and so sort as well
-    bool limitedInSQL =
-        extFilter.limit.empty() && (sortDescription.limitStart > 0 || sortDescription.limitEnd > 0);
+    // Apply any limiting directly in SQL
     if (limitedInSQL)
     {
       extFilter.limit =
           DatabaseUtils::BuildLimitClauseOnly(sortDescription.limitEnd, sortDescription.limitStart);
-      const std::shared_ptr<CSettings> settings =
-          CServiceBroker::GetSettingsComponent()->GetSettings();
-      if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
-        sorting.sortAttributes =
-            static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
-      // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
-      GetOrderFilter(MediaTypeSong, sorting, extFilter);
     }
-    else if (artistData)
+
+    // Apply sort in SQL
+    const std::shared_ptr<CSettings> settings =
+        CServiceBroker::GetSettingsComponent()->GetSettings();
+    if (settings->GetBool(CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME))
+      sorting.sortAttributes =
+          static_cast<SortAttribute>(sorting.sortAttributes | SortAttributeUseArtistSortName);
+    // Set Orderby and add any extra fields needed for sort e.g. "artistname" scalar query
+    GetOrderFilter(MediaTypeSong, sorting, extFilter);
+    // Modify order to use correct calculated year field
+    if (!CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+            CSettings::SETTING_MUSICLIBRARY_USEORIGINALDATE))
+      StringUtils::Replace(extFilter.order, "iYear", "CAST(strReleaseDate AS INTEGER)");
+    else
+      StringUtils::Replace(extFilter.order, "iYear", "CAST(strOrigReleaseDate AS INTEGER)");
+
+    std::string strFields = "songview.*";
+    if (!artistData || limitedInSQL)
     {
-      extFilter.AppendOrder("songartistview.idSong");
-      extFilter.AppendOrder("songartistview.idRole");
-      extFilter.AppendOrder("songartistview.iOrder");
+      // Build songview <where> + <order by> + <limits>
+      strSQLExtra.clear();
+      if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
+        return false;
     }
-    strSQLExtra.clear();
-    BuildSQL(strSQLExtra, extFilter, strSQLExtra);
+    else
+      strFields = "songview.*, songartistview.*";
+    if (!extFilter.fields.empty() && extFilter.fields.compare("*") != 0)
+      strFields = strFields + ", " + extFilter.fields;
 
     std::string strSQL;
     if (artistData)
     { // Get data from song and song_artist tables to fully populate songs with artists
       // All songs now have at least one artist so inner join sufficient
-      // Need guaranteed ordering for dataset processing to extract songs
+      // Build songartistview JOIN part of query
+      Filter joinFilter;
+      std::string strSQLJoin;
+      joinFilter.AppendJoin("JOIN songartistview ON songartistview.idSong = songview.idSong");
+      if (sortDescription.sortBy == SortByRandom)
+        joinFilter.AppendOrder("songartistview.idSong");
+      else
+        joinFilter.order = extFilter.order;
+      if (limitedInSQL)
+      {
+        StringUtils::Replace(joinFilter.join, "songview.idSong", "sv.idSong");
+        StringUtils::Replace(joinFilter.order, "songview.", "sv.");
+      }
+      else
+        joinFilter.where = extFilter.where;
+      joinFilter.AppendOrder("songartistview.idRole");
+      joinFilter.AppendOrder("songartistview.iOrder");
+      if (!BuildSQL(strSQLJoin, joinFilter, strSQLJoin))
+        return false;
+
       if (limitedInSQL)
       {
-        // Apply where clause, limits and order to songview, then join as multiple
-        // records in result set per song in idSong order for dataset processing
-        // so item list will be in idSong order until sorted elsewhere
-        std::string strSVFields = "songview.*";
-        if (!extFilter.fields.empty() && extFilter.fields.compare("*") != 0)
-          strSVFields = "songview.*, " + extFilter.fields;
-        strSQL = "SELECT sv.*, songartistview.* "
-          "FROM (SELECT " + strSVFields + " FROM songview " + strSQLExtra + ") AS sv "
-          "JOIN songartistview ON songartistview.idSong = sv.idSong "
-          "ORDER BY songartistview.idSong, songartistview.idRole, songartistview.iOrder";
+        // When have artist data (all roles) and LIMIT on songs use inline view
+        // SELECT sv.*, songartistview.* FROM
+        //   (SELECT songview.* FROM songview <where> + <order by> + <limits> ) AS sv
+        //   <order by sv fields>, songartistview.idRole, songartistview.iOrder
+        // Apply where clause, limits and order to songview, then join to songartistview this gives
+        // multiple records per song in result set
+        strSQL = "SELECT " + strFields + " FROM songview " + strSQLExtra;
+        strSQL = "(" + strSQL + ") AS sv ";
+        strSQL = "SELECT sv.*, songartistview.* FROM " + strSQL + strSQLJoin;
       }
       else
-        strSQL = "SELECT songview.*, songartistview.* "
-                 "FROM songview JOIN songartistview ON songartistview.idSong = songview.idSong " +
-                 strSQLExtra;
+        strSQL = "SELECT " + strFields + " FROM songview " + strSQLJoin;
     }
     else
-      strSQL = "SELECT songview.* FROM songview " + strSQLExtra;
+      strSQL = "SELECT " + strFields + " FROM songview " + strSQLExtra;
 
     CLog::Log(LOGDEBUG, "%s query = %s", __FUNCTION__, strSQL.c_str());
+    querytime = XbmcThreads::SystemClockMillis();
     // run query
     if (!m_pDS->query(strSQL))
       return false;
@@ -5277,20 +5341,20 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
       m_pDS->close();
       return true;
     }
+    querytime = XbmcThreads::SystemClockMillis() - querytime;
 
     // Store the total number of songs as a property
     items.SetProperty("total", total);
 
     DatabaseResults results;
     results.reserve(iRowsFound);
-    // Avoid sorting when populating results when a) have join with songartistview
-    // or b) no join but have limits so already sorted in SQL
-    // Apply sort later to fileitems list rather than dataset
-    sorting = sortDescription;
-    if (artistData || limitedInSQL)
-      sorting.sortBy = SortByNone;
-    if (!SortUtils::SortFromDataset(sorting, MediaTypeSong, m_pDS, results))
+    // Populate results field vector from dataset
+    FieldList fields;
+    if (!DatabaseUtils::GetDatabaseResults(MediaTypeSong, fields, m_pDS, results))
       return false;
+    // Store item list sort order
+    items.SetSortMethod(sortDescription.sortBy);
+    items.SetSortOrder(sortDescription.sortOrder);
 
     // Get songs from returned rows. If join songartistview then there is a row for every artist
     items.Reserve(total);
@@ -5319,6 +5383,9 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
           GetFileItemFromDataset(record, item.get(), musicUrl);
           // HACK for sorting by database returned order
           item->m_iprogramCount = ++count;
+          // Set icon now to avoid slow per item processing in FillInDefaultIcon later
+          item->SetProperty("icon_never_overlay", true);
+          item->SetArt("icon", "DefaultAudio.png");
           items.Add(item);
         }
         // Get song artist credits and contributors
@@ -5347,17 +5414,17 @@ bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filte
     // cleanup
     m_pDS->close();
 
-    // Finally do any sorting in items list we have not been able to do before because have join
-    // so have idSong order for processing.
+    // Ensure random order of item list when results set sorted by idSong for artist processing
     // Note while smartplaylists and xml nodes provide sort order, sort is not passed in from node
     // navigation. Order is read later from view state and list sorting is then triggered by
     // CGUIMediaWindow::Update in both cases.
-    // Sorting here is probably redundant, but leave in place until certain
+    // So sorting here is currently redundant, but the consistent place to do it.
     // !@ todo: do sorting once, preferably in SQL
-    if (artistData)
+    if (sortDescription.sortBy == SortByRandom && artistData)
       items.Sort(sortDescription);
 
-    CLog::Log(LOGDEBUG, "%s(%s) - took %d ms", __FUNCTION__, filter.where.c_str(), XbmcThreads::SystemClockMillis() - time);
+    CLog::Log(LOGDEBUG, "{0}: Time to fill list with songs {1}ms query took {2}ms", __FUNCTION__,
+              XbmcThreads::SystemClockMillis() - time, querytime);
     return true;
   }
   catch (...)

From ea43619d5b3b09c66bf890db3d1e1e30ea49b06c Mon Sep 17 00:00:00 2001
From: DaveTBlake <oak99sky@yahoo.co.uk>
Date: Tue, 12 May 2020 06:36:59 +0100
Subject: [PATCH 4/4] [JSON]Bump patch version for implementation changes of
 sorting of Audiolibrary results

---
 xbmc/interfaces/json-rpc/schema/version.txt | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/interfaces/json-rpc/schema/version.txt b/xbmc/interfaces/json-rpc/schema/version.txt
index 5359a67dc84f..7de89c902f9c 100644
--- a/xbmc/interfaces/json-rpc/schema/version.txt
+++ b/xbmc/interfaces/json-rpc/schema/version.txt
@@ -1 +1 @@
-JSONRPC_VERSION 11.8.1
+JSONRPC_VERSION 11.8.2
