From c7f1eab2c96b91eeaffb51bb8eef5cdfc0137fd3 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Mon, 16 Jul 2018 15:34:53 +0200
Subject: [PATCH] [PVR] Fix deadlock on Kodi startup - trac#15952

---
 xbmc/pvr/epg/Epg.cpp          |  7 +++++--
 xbmc/pvr/epg/EpgContainer.cpp | 26 +++++++++++++-------------
 xbmc/pvr/epg/EpgContainer.h   |  4 ++--
 xbmc/pvr/epg/EpgDatabase.cpp  | 21 ++++++++-------------
 xbmc/pvr/epg/EpgDatabase.h    | 10 +++++-----
 5 files changed, 33 insertions(+), 35 deletions(-)

diff --git a/xbmc/pvr/epg/Epg.cpp b/xbmc/pvr/epg/Epg.cpp
index 0ba8ae8854d8..f79e016e021d 100644
--- a/xbmc/pvr/epg/Epg.cpp
+++ b/xbmc/pvr/epg/Epg.cpp
@@ -310,15 +310,18 @@ bool CPVREpg::Load(void)
     return bReturn;
   }
 
-  int iEntriesLoaded = database->Get(*this);
+  const std::vector<CPVREpgInfoTagPtr> result = database->Get(*this);
 
   CSingleLock lock(m_critSection);
-  if (iEntriesLoaded <= 0)
+  if (result.empty())
   {
     CLog::LogFC(LOGDEBUG, LOGEPG, "No database entries found for table '%s'.", m_strName.c_str());
   }
   else
   {
+    for (const auto& entry : result)
+      AddEntry(*entry);
+
     m_lastScanTime = GetLastScanTime();
     bReturn = true;
   }
diff --git a/xbmc/pvr/epg/EpgContainer.cpp b/xbmc/pvr/epg/EpgContainer.cpp
index d6b8bb739bf2..eb5b1083ff38 100644
--- a/xbmc/pvr/epg/EpgContainer.cpp
+++ b/xbmc/pvr/epg/EpgContainer.cpp
@@ -80,7 +80,7 @@ class CEpgTagStateChange
 {
 public:
   CEpgTagStateChange() = default;
-  CEpgTagStateChange(const CPVREpgInfoTagPtr tag, EPG_EVENT_STATE eNewState) : m_epgtag(tag), m_state(eNewState) {}
+  CEpgTagStateChange(const CPVREpgInfoTagPtr &tag, EPG_EVENT_STATE eNewState) : m_epgtag(tag), m_state(eNewState) {}
 
   void Deliver();
 
@@ -315,9 +315,12 @@ void CPVREpgContainer::LoadFromDB(void)
   m_database->Lock();
   m_iNextEpgId = m_database->GetLastEPGId();
   m_database->DeleteEpgEntries(cleanupTime);
-  m_database->Get(*this);
+  const std::vector<CPVREpgPtr> result = m_database->Get(*this);
   m_database->Unlock();
 
+  for (const auto& entry : result)
+    InsertFromDatabase(entry);
+
   for (const auto &epgEntry : m_epgs)
   {
     if (m_bStop)
@@ -518,13 +521,13 @@ std::vector<CPVREpgInfoTagPtr> CPVREpgContainer::GetEpgTagsForTimer(const CPVRTi
   return std::vector<CPVREpgInfoTagPtr>();
 }
 
-void CPVREpgContainer::InsertFromDatabase(int iEpgID, const std::string &strName, const std::string &strScraperName)
+void CPVREpgContainer::InsertFromDatabase(const CPVREpgPtr &newEpg)
 {
   // table might already have been created when pvr channels were loaded
-  CPVREpgPtr epg = GetById(iEpgID);
+  CPVREpgPtr epg = GetById(newEpg->EpgID());
   if (epg)
   {
-    if (epg->Name() != strName || epg->ScraperName() != strScraperName)
+    if (epg->Name() != newEpg->Name() || epg->ScraperName() != newEpg->ScraperName())
     {
       // current table data differs from the info in the db
       epg->SetChanged();
@@ -534,13 +537,10 @@ void CPVREpgContainer::InsertFromDatabase(int iEpgID, const std::string &strName
   else
   {
     // create a new epg table
-    epg.reset(new CPVREpg(iEpgID, strName, strScraperName, true));
-    if (epg)
-    {
-      m_epgs.insert(std::make_pair(iEpgID, epg));
-      SetChanged();
-      epg->RegisterObserver(this);
-    }
+    epg = newEpg;
+    m_epgs.insert(std::make_pair(epg->EpgID(), epg));
+    SetChanged();
+    epg->RegisterObserver(this);
   }
 }
 
@@ -868,7 +868,7 @@ void CPVREpgContainer::UpdateRequest(int iClientID, unsigned int iUniqueChannelI
   m_updateRequests.emplace_back(CEpgUpdateRequest(iClientID, iUniqueChannelID));
 }
 
-void CPVREpgContainer::UpdateFromClient(const CPVREpgInfoTagPtr tag, EPG_EVENT_STATE eNewState)
+void CPVREpgContainer::UpdateFromClient(const CPVREpgInfoTagPtr &tag, EPG_EVENT_STATE eNewState)
 {
   CSingleLock lock(m_epgTagChangesLock);
   m_epgTagChanges.emplace_back(CEpgTagStateChange(tag, eNewState));
diff --git a/xbmc/pvr/epg/EpgContainer.h b/xbmc/pvr/epg/EpgContainer.h
index 3e0bd58a51aa..62943b5ac77d 100644
--- a/xbmc/pvr/epg/EpgContainer.h
+++ b/xbmc/pvr/epg/EpgContainer.h
@@ -204,7 +204,7 @@ namespace PVR
      * @param tag The epg tag containing the updated data
      * @param eNewState The kind of change (CREATED, UPDATED, DELETED)
      */
-    void UpdateFromClient(const CPVREpgInfoTagPtr tag, EPG_EVENT_STATE eNewState);
+    void UpdateFromClient(const CPVREpgInfoTagPtr &tag, EPG_EVENT_STATE eNewState);
 
     /*!
      * @brief Get the number of past days to show in the guide and to import from backends.
@@ -253,7 +253,7 @@ namespace PVR
      */
     void LoadFromDB(void);
 
-    void InsertFromDatabase(int iEpgID, const std::string &strName, const std::string &strScraperName);
+    void InsertFromDatabase(const CPVREpgPtr &newEpg);
 
     CPVREpgDatabasePtr m_database; /*!< the EPG database */
 
diff --git a/xbmc/pvr/epg/EpgDatabase.cpp b/xbmc/pvr/epg/EpgDatabase.cpp
index 10451cd4ad38..cfd66876a502 100644
--- a/xbmc/pvr/epg/EpgDatabase.cpp
+++ b/xbmc/pvr/epg/EpgDatabase.cpp
@@ -201,16 +201,14 @@ bool CPVREpgDatabase::Delete(const CPVREpgInfoTag &tag)
   return DeleteValues("epgtags", filter);
 }
 
-int CPVREpgDatabase::Get(CPVREpgContainer &container)
+std::vector<CPVREpgPtr> CPVREpgDatabase::Get(const CPVREpgContainer &container)
 {
-  int iReturn(-1);
+  std::vector<CPVREpgPtr> result;
 
   CSingleLock lock(m_critSection);
   std::string strQuery = PrepareSQL("SELECT idEpg, sName, sScraperName FROM epg;");
   if (ResultQuery(strQuery))
   {
-    iReturn = 0;
-
     try
     {
       while (!m_pDS->eof())
@@ -219,8 +217,7 @@ int CPVREpgDatabase::Get(CPVREpgContainer &container)
         std::string strName        = m_pDS->fv("sName").get_asString().c_str();
         std::string strScraperName = m_pDS->fv("sScraperName").get_asString().c_str();
 
-        container.InsertFromDatabase(iEpgID, strName, strScraperName);
-        ++iReturn;
+        result.emplace_back(new CPVREpg(iEpgID, strName, strScraperName, true));
         m_pDS->next();
       }
       m_pDS->close();
@@ -231,18 +228,17 @@ int CPVREpgDatabase::Get(CPVREpgContainer &container)
     }
   }
 
-  return iReturn;
+  return result;
 }
 
-int CPVREpgDatabase::Get(CPVREpg &epg)
+std::vector<CPVREpgInfoTagPtr> CPVREpgDatabase::Get(const CPVREpg &epg)
 {
-  int iReturn(-1);
+  std::vector<CPVREpgInfoTagPtr> result;
 
   CSingleLock lock(m_critSection);
   std::string strQuery = PrepareSQL("SELECT * FROM epgtags WHERE idEpg = %u;", epg.EpgID());
   if (ResultQuery(strQuery))
   {
-    iReturn = 0;
     try
     {
       while (!m_pDS->eof())
@@ -289,8 +285,7 @@ int CPVREpgDatabase::Get(CPVREpg &epg)
         newTag->m_strIconPath        = m_pDS->fv("sIconPath").get_asString().c_str();
         newTag->m_iFlags             = m_pDS->fv("iFlags").get_asInt();
 
-        epg.AddEntry(*newTag);
-        ++iReturn;
+        result.emplace_back(newTag);
 
         m_pDS->next();
       }
@@ -301,7 +296,7 @@ int CPVREpgDatabase::Get(CPVREpg &epg)
       CLog::LogF(LOGERROR, "Could not load EPG data from the database");
     }
   }
-  return iReturn;
+  return result;
 }
 
 bool CPVREpgDatabase::GetLastEpgScanTime(int iEpgId, CDateTime *lastScan)
diff --git a/xbmc/pvr/epg/EpgDatabase.h b/xbmc/pvr/epg/EpgDatabase.h
index ceba8efac2ee..30aee9631365 100644
--- a/xbmc/pvr/epg/EpgDatabase.h
+++ b/xbmc/pvr/epg/EpgDatabase.h
@@ -111,17 +111,17 @@ namespace PVR
 
     /*!
      * @brief Get all EPG tables from the database. Does not get the EPG tables' entries.
-     * @param container The container to fill.
-     * @return The amount of entries that was added.
+     * @param container The container to get the EPG tables for.
+     * @return The entries.
      */
-    int Get(CPVREpgContainer &container);
+    std::vector<CPVREpgPtr> Get(const CPVREpgContainer &container);
 
     /*!
      * @brief Get all EPG entries for a table.
      * @param epg The EPG table to get the entries for.
-     * @return The amount of entries that was added.
+     * @return The entries.
      */
-    int Get(CPVREpg &epg);
+    std::vector<CPVREpgInfoTagPtr> Get(const CPVREpg &epg);
 
     /*!
      * @brief Get the last stored EPG scan time.
