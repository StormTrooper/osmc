From c30a6e47d7c8b4160ee9e7b3078794433e1ad219 Mon Sep 17 00:00:00 2001
From: Wolfgang Haupt <haupt.wolfgang@gmail.com>
Date: Thu, 23 Apr 2020 20:35:26 +0200
Subject: [PATCH] Network: Simplify the bind logic

 - increase readability of the code
 - use closesocket consistently
 - fix another potential sizeof issue
---
 xbmc/network/Socket.cpp | 105 +++++++++++++++++++++++-----------------
 xbmc/network/Socket.h   |   2 +
 2 files changed, 63 insertions(+), 44 deletions(-)

diff --git a/xbmc/network/Socket.cpp b/xbmc/network/Socket.cpp
index 37fa644c83a2..41fff7909bf0 100644
--- a/xbmc/network/Socket.cpp
+++ b/xbmc/network/Socket.cpp
@@ -10,6 +10,7 @@
 
 #include "Socket.h"
 
+#include "utils/ScopeGuard.h"
 #include "utils/log.h"
 
 #include <vector>
@@ -34,56 +35,23 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
   // with an IPv6-only socket).
   if (!localOnly) // Only bind loopback to ipv4. TODO : Implement dual bindinds.
   {
-    m_iSock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
-    if (m_iSock != INVALID_SOCKET)
+    m_ipv6Socket = CheckIPv6(port, range);
+
+    if (m_ipv6Socket)
     {
+      m_iSock = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
+      if (m_iSock != INVALID_SOCKET)
+      {
 #ifdef WINSOCK_VERSION
-      const char zero = 0;
+        const char zero = 0;
 #else
-      int zero = 0;
+        int zero = 0;
 #endif
-      if (setsockopt(m_iSock, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero)) == -1)
-      {
-        close(m_iSock);
-        m_iSock = INVALID_SOCKET;
-      }
-      else
-      {
-        m_addr = CAddress("::");
-
-        SOCKET testSocket = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
-        if (testSocket != INVALID_SOCKET)
-        {
-          setsockopt(testSocket, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero));
-          // Try to bind a socket to validate ipv6 status
-          for (m_iPort = port; m_iPort <= port + range; ++m_iPort)
-          {
-            m_addr.saddr.saddr6.sin6_port = htons(m_iPort);
-            if (bind(testSocket, reinterpret_cast<struct sockaddr*>(&m_addr.saddr), m_addr.size) >= 0)
-            {
-              m_ipv6Socket = true;
-              break;
-            }
-          }
-          if (!m_ipv6Socket)
-          {
-            CLog::Log(LOGWARNING, "UDP: Unable to bind to advertised ipv6, fallback to ipv4");
-            close(m_iSock);
-            m_iSock = INVALID_SOCKET;
-          }
-
-          closesocket(testSocket);
-          testSocket = INVALID_SOCKET;
-        }
-        else
+        if (setsockopt(m_iSock, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero)) == -1)
         {
-          CLog::Log(LOGWARNING, "UDP: Could not create testSocket");
-          close(m_iSock);
+          closesocket(m_iSock);
           m_iSock = INVALID_SOCKET;
         }
-
-        if (testSocket != INVALID_SOCKET)
-          closesocket(testSocket);
       }
     }
   }
@@ -116,7 +84,7 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
 #else
   int yes = 1;
 #endif
-  if (setsockopt(m_iSock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int))==-1)
+  if (setsockopt(m_iSock, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1)
   {
     CLog::Log(LOGWARNING, "UDP: Could not enable the address reuse options");
     CLog::Log(LOGWARNING, "UDP: %s", strerror(errno));
@@ -171,6 +139,55 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
   return true;
 }
 
+bool CPosixUDPSocket::CheckIPv6(int port, int range)
+{
+  CAddress testaddr("::");
+#if defined(TARGET_WINDOWS)
+  using CAutoPtrSocket = KODI::UTILS::CScopeGuard<SOCKET, INVALID_SOCKET, decltype(closesocket)>;
+  CAutoPtrSocket testSocket(closesocket, socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP));
+#else
+  using CAutoPtrSocket = KODI::UTILS::CScopeGuard<int, -1, decltype(close)>;
+  CAutoPtrSocket testSocket(close, socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP));
+#endif
+
+  if (static_cast<SOCKET>(testSocket) == INVALID_SOCKET)
+  {
+    CLog::LogF(LOGDEBUG, "Could not create IPv6 socket: %s", strerror(errno));
+    return false;
+  }
+
+#ifdef WINSOCK_VERSION
+  const char zero = 0;
+#else
+  int zero = 0;
+#endif
+
+  if (setsockopt(static_cast<SOCKET>(testSocket), IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(zero)) ==
+      -1)
+  {
+    CLog::LogF(LOGDEBUG, "Could not disable IPV6_V6ONLY for socket: %s", strerror(errno));
+    return false;
+  }
+
+  // Try to bind a socket to validate ipv6 status
+  for (; port <= port + range; port++)
+  {
+    testaddr.saddr.saddr6.sin6_port = htons(port);
+    if (bind(static_cast<SOCKET>(testSocket), reinterpret_cast<struct sockaddr*>(&testaddr.saddr),
+             testaddr.size) == 0)
+    {
+      CLog::LogF(LOGDEBUG, "IPv6 socket bound successfully");
+      return true;
+    }
+    else
+    {
+      CLog::LogF(LOGDEBUG, "Could not bind IPv6 socket: %s", strerror(errno));
+    }
+  }
+
+  return false;
+}
+
 void CPosixUDPSocket::Close()
 {
   if (m_iSock>=0)
diff --git a/xbmc/network/Socket.h b/xbmc/network/Socket.h
index 89c0a98b2f52..facd8ec427ec 100644
--- a/xbmc/network/Socket.h
+++ b/xbmc/network/Socket.h
@@ -209,6 +209,8 @@ namespace SOCKETS
     CAddress m_addr;
 
   private:
+    bool CheckIPv6(int port, int range);
+
     bool m_ipv6Socket;
   };
 
