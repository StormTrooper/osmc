From 15411c4b02ccef8ac5b6ab27aad6174582f4863c Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Sun, 26 Apr 2020 11:02:37 +0200
Subject: [PATCH] [dialogs][guillib] CGUIDialogKaiToast now only closes the
 dialog if the whole toast text was displayed at least once.

---
 xbmc/dialogs/GUIDialogKaiToast.cpp  | 25 ++++++++++++++++++++++++-
 xbmc/guilib/GUIFadeLabelControl.cpp | 12 ++++++++++++
 xbmc/guilib/GUIFadeLabelControl.h   |  3 +++
 3 files changed, 39 insertions(+), 1 deletion(-)

diff --git a/xbmc/dialogs/GUIDialogKaiToast.cpp b/xbmc/dialogs/GUIDialogKaiToast.cpp
index eb84656ede24..239afaca314d 100644
--- a/xbmc/dialogs/GUIDialogKaiToast.cpp
+++ b/xbmc/dialogs/GUIDialogKaiToast.cpp
@@ -9,6 +9,7 @@
 #include "GUIDialogKaiToast.h"
 
 #include "ServiceBroker.h"
+#include "guilib/GUIFadeLabelControl.h"
 #include "guilib/GUIMessage.h"
 #include "peripherals/Peripherals.h"
 #include "threads/SingleLock.h"
@@ -90,6 +91,13 @@ bool CGUIDialogKaiToast::DoWork()
   if (!m_notifications.empty() &&
       CTimeUtils::GetFrameTime() - m_timer > m_toastMessageTime)
   {
+    // if we have a fade label control for the text to display, ensure the whole text was shown
+    // (scrolled to the end) before we move on to the next message
+    const CGUIFadeLabelControl* notificationText =
+        dynamic_cast<const CGUIFadeLabelControl*>(GetControl(POPUP_NOTIFICATION_BUTTON));
+    if (notificationText && !notificationText->AllLabelsShown())
+      return false;
+
     Notification toast = m_notifications.front();
     m_notifications.pop();
     lock.Leave();
@@ -148,7 +156,22 @@ void CGUIDialogKaiToast::FrameMove()
 
   // now check if we should exit
   if (CTimeUtils::GetFrameTime() - m_timer > m_toastDisplayTime)
-    Close();
+  {
+    bool bClose = true;
+
+    // if we have a fade label control for the text to display, ensure the whole text was shown
+    // (scrolled to the end) before we're closing the toast dialog
+    const CGUIFadeLabelControl* notificationText =
+        dynamic_cast<const CGUIFadeLabelControl*>(GetControl(POPUP_NOTIFICATION_BUTTON));
+    if (notificationText)
+    {
+      CSingleLock lock(m_critical);
+      bClose = notificationText->AllLabelsShown() && m_notifications.empty();
+    }
+
+    if (bClose)
+      Close();
+  }
 
   CGUIDialog::FrameMove();
 }
diff --git a/xbmc/guilib/GUIFadeLabelControl.cpp b/xbmc/guilib/GUIFadeLabelControl.cpp
index 45fa33df09b2..237ac37771eb 100644
--- a/xbmc/guilib/GUIFadeLabelControl.cpp
+++ b/xbmc/guilib/GUIFadeLabelControl.cpp
@@ -45,6 +45,7 @@ CGUIFadeLabelControl::CGUIFadeLabelControl(const CGUIFadeLabelControl &from)
   m_shortText = from.m_shortText;
   m_scroll = from.m_scroll;
   m_randomized = from.m_randomized;
+  m_allLabelsShown = from.m_allLabelsShown;
 }
 
 CGUIFadeLabelControl::~CGUIFadeLabelControl(void) = default;
@@ -53,6 +54,7 @@ void CGUIFadeLabelControl::SetInfo(const std::vector<GUIINFO::CGUIInfoLabel> &in
 {
   m_lastLabel = -1;
   m_infoLabels = infoLabels;
+  m_allLabelsShown = m_infoLabels.empty();
   if (m_randomized)
     KODI::UTILS::RandomShuffle(m_infoLabels.begin(), m_infoLabels.end());
 }
@@ -60,6 +62,7 @@ void CGUIFadeLabelControl::SetInfo(const std::vector<GUIINFO::CGUIInfoLabel> &in
 void CGUIFadeLabelControl::AddLabel(const std::string &label)
 {
   m_infoLabels.emplace_back(label, "", GetParentID());
+  m_allLabelsShown = false;
 }
 
 void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
@@ -90,6 +93,10 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
     }
     MarkDirtyRegion();
   }
+
+  if (m_shortText && m_infoLabels.size() == 1)
+    m_allLabelsShown = true;
+
   if (m_currentLabel != m_lastLabel)
   { // new label - reset scrolling
     m_scrollInfo.Reset();
@@ -132,7 +139,10 @@ void CGUIFadeLabelControl::Process(unsigned int currentTime, CDirtyRegionList &d
       if (m_fadeAnim.GetProcess() != ANIM_PROCESS_NORMAL)
       {
         if (++m_currentLabel >= m_infoLabels.size())
+        {
           m_currentLabel = 0;
+          m_allLabelsShown = true;
+        }
         m_scrollInfo.Reset();
         m_fadeAnim.QueueAnimation(ANIM_PROCESS_REVERSE);
       }
@@ -217,6 +227,7 @@ bool CGUIFadeLabelControl::OnMessage(CGUIMessage& message)
     {
       m_lastLabel = -1;
       m_infoLabels.clear();
+      m_allLabelsShown = true;
       m_scrollInfo.Reset();
       return true;
     }
@@ -224,6 +235,7 @@ bool CGUIFadeLabelControl::OnMessage(CGUIMessage& message)
     {
       m_lastLabel = -1;
       m_infoLabels.clear();
+      m_allLabelsShown = true;
       m_scrollInfo.Reset();
       AddLabel(message.GetLabel());
       return true;
diff --git a/xbmc/guilib/GUIFadeLabelControl.h b/xbmc/guilib/GUIFadeLabelControl.h
index 03c888ed4d68..a82602874f5a 100644
--- a/xbmc/guilib/GUIFadeLabelControl.h
+++ b/xbmc/guilib/GUIFadeLabelControl.h
@@ -39,6 +39,8 @@ class CGUIFadeLabelControl : public CGUIControl
   void SetInfo(const std::vector<KODI::GUILIB::GUIINFO::CGUIInfoLabel> &vecInfo);
   void SetScrolling(bool scroll) { m_scroll = scroll; }
 
+  bool AllLabelsShown() const { return m_allLabelsShown; }
+
 protected:
   bool UpdateColors() override;
   std::string GetDescription() const override;
@@ -71,5 +73,6 @@ class CGUIFadeLabelControl : public CGUIControl
   unsigned int m_scrollSpeed;
   bool m_resetOnLabelChange;
   bool m_randomized;
+  bool m_allLabelsShown = true;
 };
 
