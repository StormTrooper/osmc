From da066402c11b78b23972d38bc2a728211dba097f Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Sun, 19 Jan 2020 21:24:25 +0100
Subject: [PATCH] [PVR] Context menus: Implement 'Record', 'Stop recording',
 'Switch to channel' for EPG gap tags.

---
 xbmc/pvr/PVRContextMenus.cpp           | 72 +++++++++++++++++++++-----
 xbmc/pvr/guilib/PVRGUIActions.cpp      | 19 ++++++-
 xbmc/pvr/windows/GUIWindowPVRGuide.cpp | 39 +-------------
 3 files changed, 78 insertions(+), 52 deletions(-)

diff --git a/xbmc/pvr/PVRContextMenus.cpp b/xbmc/pvr/PVRContextMenus.cpp
index f7ddce455e2f..0e8280c1da0f 100644
--- a/xbmc/pvr/PVRContextMenus.cpp
+++ b/xbmc/pvr/PVRContextMenus.cpp
@@ -15,6 +15,7 @@
 #include "pvr/addons/PVRClient.h"
 #include "pvr/addons/PVRClientMenuHooks.h"
 #include "pvr/channels/PVRChannel.h"
+#include "pvr/channels/PVRChannelGroupsContainer.h"
 #include "pvr/epg/EpgInfoTag.h"
 #include "pvr/guilib/PVRGUIActions.h"
 #include "pvr/recordings/PVRRecording.h"
@@ -150,8 +151,8 @@ namespace PVR
       if (channel)
         return channel->GetEPGNow().get() != nullptr;
 
-      if (item.GetEPGInfoTag())
-        return true;
+      if (item.HasEPGInfoTag())
+        return !item.GetEPGInfoTag()->IsGapTag();
 
       const std::shared_ptr<CPVRTimerInfoTag> timer(item.GetPVRTimerInfoTag());
       if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
@@ -197,8 +198,8 @@ namespace PVR
       if (channel)
         return channel->GetEPGNow().get() != nullptr;
 
-      if (item.GetEPGInfoTag())
-        return true;
+      if (item.HasEPGInfoTag())
+        return !item.GetEPGInfoTag()->IsGapTag();
 
       const std::shared_ptr<CPVRTimerInfoTag> timer(item.GetPVRTimerInfoTag());
       if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
@@ -223,22 +224,49 @@ namespace PVR
     {
       const std::shared_ptr<CPVRClient> client = CServiceBroker::GetPVRManager().GetClient(item);
 
-      const std::shared_ptr<CPVRChannel> channel = item.GetPVRChannelInfoTag();
+      std::shared_ptr<CPVRChannel> channel = item.GetPVRChannelInfoTag();
       if (channel)
         return client && client->GetClientCapabilities().SupportsTimers() &&
                !CServiceBroker::GetPVRManager().Timers()->IsRecordingOnChannel(*channel);
 
       const std::shared_ptr<CPVREpgInfoTag> epg = item.GetEPGInfoTag();
-      if (epg &&
-          !CServiceBroker::GetPVRManager().Timers()->GetTimerForEpgTag(epg) &&
-          epg->IsRecordable())
-        return client && client->GetClientCapabilities().SupportsTimers();
-
+      if (epg && epg->IsRecordable())
+      {
+        if (epg->IsGapTag())
+        {
+          channel = CServiceBroker::GetPVRManager().ChannelGroups()->GetChannelForEpgTag(epg);
+          if (channel)
+          {
+            return client && client->GetClientCapabilities().SupportsTimers() &&
+                !CServiceBroker::GetPVRManager().Timers()->IsRecordingOnChannel(*channel);
+          }
+        }
+        else
+        {
+          return client && client->GetClientCapabilities().SupportsTimers() &&
+              !CServiceBroker::GetPVRManager().Timers()->GetTimerForEpgTag(epg);
+        }
+      }
       return false;
     }
 
     bool StartRecording::Execute(const CFileItemPtr& item) const
     {
+      const std::shared_ptr<CPVREpgInfoTag> epgTag = item->GetEPGInfoTag();
+      if (!epgTag || epgTag->IsActive())
+      {
+        // instant recording
+        std::shared_ptr<CPVRChannel> channel;
+        if (epgTag)
+          channel = CServiceBroker::GetPVRManager().ChannelGroups()->GetChannelForEpgTag(epgTag);
+
+        if (!channel)
+          channel = item->GetPVRChannelInfoTag();
+
+        if (channel)
+          return CServiceBroker::GetPVRManager().GUIActions()->SetRecordingOnChannel(channel, true);
+      }
+
       return CServiceBroker::GetPVRManager().GUIActions()->AddTimer(item, false);
     }
 
@@ -251,7 +279,7 @@ namespace PVR
       if (recording && recording->IsInProgress())
         return true;
 
-      const std::shared_ptr<CPVRChannel> channel(item.GetPVRChannelInfoTag());
+      std::shared_ptr<CPVRChannel> channel = item.GetPVRChannelInfoTag();
       if (channel)
         return CServiceBroker::GetPVRManager().Timers()->IsRecordingOnChannel(*channel);
 
@@ -259,11 +287,30 @@ namespace PVR
       if (timer && !URIUtils::PathEquals(item.GetPath(), CPVRTimersPath::PATH_ADDTIMER))
         return timer->IsRecording();
 
+      const std::shared_ptr<CPVREpgInfoTag> epg = item.GetEPGInfoTag();
+      if (epg && epg->IsGapTag())
+      {
+        channel = CServiceBroker::GetPVRManager().ChannelGroups()->GetChannelForEpgTag(epg);
+        if (channel)
+          return CServiceBroker::GetPVRManager().Timers()->IsRecordingOnChannel(*channel);
+      }
+
       return false;
     }
 
     bool StopRecording::Execute(const CFileItemPtr& item) const
     {
+      const std::shared_ptr<CPVREpgInfoTag> epgTag = item->GetEPGInfoTag();
+      if (epgTag && epgTag->IsGapTag())
+      {
+        // instance recording
+        const std::shared_ptr<CPVRChannel> channel =
+            CServiceBroker::GetPVRManager().ChannelGroups()->GetChannelForEpgTag(epgTag);
+        if (channel)
+          return CServiceBroker::GetPVRManager().GUIActions()->SetRecordingOnChannel(channel,
+                                                                                     false);
+      }
+
       return CServiceBroker::GetPVRManager().GUIActions()->StopRecording(item);
     }
 
@@ -408,7 +455,8 @@ namespace PVR
     bool AddTimerRule::IsVisible(const CFileItem& item) const
     {
       const std::shared_ptr<CPVREpgInfoTag> epg = item.GetEPGInfoTag();
-      if (epg && !CServiceBroker::GetPVRManager().Timers()->GetTimerForEpgTag(epg))
+      if (epg && !epg->IsGapTag() &&
+          !CServiceBroker::GetPVRManager().Timers()->GetTimerForEpgTag(epg))
       {
         const std::shared_ptr<CPVRClient> client = CServiceBroker::GetPVRManager().GetClient(item);
         return client && client->GetClientCapabilities().SupportsTimers();
diff --git a/xbmc/pvr/guilib/PVRGUIActions.cpp b/xbmc/pvr/guilib/PVRGUIActions.cpp
index 0a27ec194d00..5a109c7b4e29 100644
--- a/xbmc/pvr/guilib/PVRGUIActions.cpp
+++ b/xbmc/pvr/guilib/PVRGUIActions.cpp
@@ -414,8 +414,13 @@ namespace PVR
     if (CheckParentalLock(channel) != ParentalCheckResult::SUCCESS)
       return false;
 
-    const std::shared_ptr<CPVREpgInfoTag> epgTag(CPVRItem(item).GetEpgInfoTag());
-    if (!epgTag && bCreateRule)
+    std::shared_ptr<CPVREpgInfoTag> epgTag = CPVRItem(item).GetEpgInfoTag();
+    if (epgTag)
+    {
+      if (epgTag->IsGapTag())
+        epgTag.reset(); // for gap tags, we can only create instant timers
+    }
+    else if (bCreateRule)
     {
       CLog::LogF(LOGERROR, "No epg tag!");
       return false;
@@ -669,6 +674,16 @@ namespace PVR
               }
             }
 
+            if (ePreselect == RECORD_INSTANTRECORDTIME)
+            {
+              if (iDurationDefault == 30)
+                ePreselect = RECORD_30_MINUTES;
+              else if (iDurationDefault == 60)
+                ePreselect = RECORD_60_MINUTES;
+              else if (iDurationDefault == 120)
+                ePreselect = RECORD_120_MINUTES;
+            }
+
             selector.PreSelectAction(ePreselect);
 
             PVRRECORD_INSTANTRECORDACTION eSelected = selector.Select();
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
index 2d73815276bd..e5f7567b243a 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -393,7 +393,7 @@ bool CGUIWindowPVRGuideBase::OnMessage(CGUIMessage& message)
         }
 
         const std::shared_ptr<CFileItem> pItem = GetCurrentListItem();
-        if (pItem && !pItem->GetEPGInfoTag()->IsGapTag())
+        if (pItem)
         {
           switch (message.GetParam1())
           {
@@ -493,43 +493,6 @@ bool CGUIWindowPVRGuideBase::OnMessage(CGUIMessage& message)
               break;
           }
         }
-        else
-        {
-          switch (message.GetParam1())
-          {
-            case ACTION_SELECT_ITEM:
-            case ACTION_MOUSE_LEFT_CLICK:
-            case ACTION_PLAYER_PLAY:
-            {
-              // EPG "gap" selected => switch to associated channel.
-              CGUIEPGGridContainer* epgGridContainer = GetGridControl();
-              if (epgGridContainer)
-              {
-                const CFileItemPtr item(epgGridContainer->GetSelectedGridItem());
-                if (item)
-                {
-                  CServiceBroker::GetPVRManager().GUIActions()->SwitchToChannel(item, true);
-                  bReturn = true;
-                }
-              }
-              break;
-            }
-            case ACTION_CONTEXT_MENU:
-            {
-              // EPG "gap" selected => create and process special context menu with item independent entries.
-              CContextButtons buttons;
-              GetContextButtons(-1, buttons);
-
-              int iButton = CGUIDialogContextMenu::ShowAndGetChoice(buttons);
-              if (iButton >= 0)
-              {
-                OnContextButton(-1, static_cast<CONTEXT_BUTTON>(iButton));
-              }
-              bReturn = true;
-              break;
-            }
-          }
-        }
       }
       else if (message.GetSenderId() == CONTROL_BTNVIEWASICONS ||
                message.GetSenderId() == CONTROL_BTNSORTBY)
