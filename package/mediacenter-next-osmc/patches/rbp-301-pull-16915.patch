From 2809d8d9ecfeef4d32bbf2072d6952544d0ed9df Mon Sep 17 00:00:00 2001
From: the-black-eagle <g.moore@gmx.co.uk>
Date: Wed, 11 Sep 2019 06:44:36 +0100
Subject: [PATCH] Add boxset detection and navigation by individual discs

---
 .../resources/strings.po                      |  48 +-
 system/library/music/boxsets.xml              |   6 +
 system/settings/settings.xml                  |   5 +
 xbmc/GUIInfoManager.cpp                       |  46 ++
 xbmc/SortFileItem.h                           |   1 +
 xbmc/dialogs/GUIDialogMediaFilter.cpp         |   3 +
 .../MusicDatabaseDirectory/CMakeLists.txt     |   2 +
 .../MusicDatabaseDirectory/DirectoryNode.cpp  |   3 +
 .../MusicDatabaseDirectory/DirectoryNode.h    |   3 +-
 .../DirectoryNodeAlbum.cpp                    |   2 +-
 .../DirectoryNodeAlbumRecentlyAdded.cpp       |   2 +-
 .../DirectoryNodeAlbumRecentlyPlayed.cpp      |   2 +-
 .../DirectoryNodeDiscs.cpp                    |  57 ++
 .../DirectoryNodeDiscs.h                      |  28 +
 .../DirectoryNodeOverview.cpp                 |   1 +
 .../MusicDatabaseDirectory/QueryParams.cpp    |   4 +
 .../MusicDatabaseDirectory/QueryParams.h      |   2 +
 xbmc/guilib/guiinfo/GUIInfoLabels.h           |   7 +-
 xbmc/guilib/guiinfo/LibraryGUIInfo.cpp        |  18 +
 xbmc/guilib/guiinfo/LibraryGUIInfo.h          |   1 +
 xbmc/guilib/guiinfo/MusicGUIInfo.cpp          |  20 +
 xbmc/music/Album.cpp                          |   3 +
 xbmc/music/Album.h                            |   4 +
 xbmc/music/GUIViewStateMusic.cpp              |  14 +
 xbmc/music/MusicDatabase.cpp                  | 538 ++++++++++++++++--
 xbmc/music/MusicDatabase.h                    |  40 +-
 xbmc/music/MusicDbUrl.cpp                     |   8 +
 xbmc/music/MusicThumbLoader.cpp               |  76 ++-
 xbmc/music/Song.cpp                           |   7 +
 xbmc/music/Song.h                             |   6 +
 xbmc/music/infoscanner/MusicInfoScanner.cpp   |   4 +
 xbmc/music/infoscanner/MusicInfoScanner.h     |   1 +
 xbmc/music/tags/MusicInfoTag.cpp              |  50 +-
 xbmc/music/tags/MusicInfoTag.h                |   9 +
 xbmc/music/tags/MusicInfoTagLoaderFFmpeg.cpp  |   2 +
 xbmc/music/tags/TagLoaderTagLib.cpp           |  18 +
 xbmc/music/tags/TagLoaderTagLib.h             |   4 +-
 xbmc/music/windows/GUIWindowMusicNav.cpp      |  58 +-
 .../windows/MusicFileItemListModifier.cpp     |   7 +
 xbmc/playlists/SmartPlayList.cpp              |  17 +-
 xbmc/settings/Settings.cpp                    |   1 +
 xbmc/settings/Settings.h                      |   1 +
 xbmc/utils/DatabaseUtils.cpp                  |   6 +
 xbmc/utils/DatabaseUtils.h                    |   3 +
 xbmc/utils/LabelFormatter.cpp                 |  10 +-
 xbmc/utils/SortUtils.cpp                      |  10 +
 xbmc/utils/SortUtils.h                        |   2 +
 47 files changed, 1069 insertions(+), 91 deletions(-)
 create mode 100644 system/library/music/boxsets.xml
 create mode 100644 xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.cpp
 create mode 100644 xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.h

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index c573f6e5f9c9..b15369af00bf 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -2003,6 +2003,7 @@ msgid "No CD information found"
 msgstr ""
 
 #: addons/skin.estuary/xml/Variables.xml
+#: xbmc/music/MusicDatabase.cpp
 msgctxt "#427"
 msgid "Disc"
 msgstr ""
@@ -7327,7 +7328,19 @@ msgctxt "#13521"
 msgid "Choose art type"
 msgstr ""
 
-#empty strings from id 13522 to 13549
+#. label of a setting that allows splitting of albums into component discs
+#: system/settings/settings.xml
+msgctxt "#13522"
+msgid "Split albums into individual discs"
+msgstr ""
+
+#. Description of setting with label #13522 "Split albums into individual discs"
+#: system/settings/settings.xml
+msgctxt "#13523"
+msgid "When enabled, opening a multi-disc album shows the discs as individual items instead of all the songs. Opening a disc then shows the songs on that disc."
+msgstr ""
+
+#empty strings from id 13524 to 13549
 
 #: system/settings/settings.xml
 msgctxt "#13550"
@@ -7795,6 +7808,7 @@ msgctxt "#14086"
 msgid "Playback"
 msgstr ""
 
+#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
 #: system/settings/settings.xml
 msgctxt "#14087"
 msgid "Discs"
@@ -8404,14 +8418,17 @@ msgstr ""
 
 #: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp
 #: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
-#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeRcentlyAdded.cpp
-#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeRcentlyPlayed.cpp
+#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDisc.cpp
+#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeRecentlyAdded.cpp
+#: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeRecentlyPlayed.cpp
+#: xbmc/music/windows/MusicFileItemListModifier.cpp
 msgctxt "#15102"
 msgid "* All albums"
 msgstr ""
 
 #: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp
 #: xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeArtist.cpp
+#: xbmc/music/windows/MusicFileItemListModifier.cpp
 msgctxt "#15103"
 msgid "* All artists"
 msgstr ""
@@ -21248,8 +21265,29 @@ msgctxt "#38073"
 msgid "Do you want to refresh information for this item now?"
 msgstr ""
 
-#empty strings from id 38074 to 38099
-#strings 38074 to 38099 reserved for music library
+#: system/library/music/boxsets.xml
+#: xbmc/playlists/SmartPlaylist.cpp
+msgctxt "#38074"
+msgid "Boxsets"
+msgstr ""
+
+#: xbmc/music/windows/MusicFileItemListModifier.cpp
+msgctxt "#38075"
+msgid "* All discs"
+msgstr ""
+
+#: addons/skin.estuary/xml/Variables.xml
+msgctxt "#38076"
+msgid "Disc title"
+msgstr ""
+
+#: xbmc/playlists/SmartPlaylist.cpp
+msgctxt "#38077"
+msgid "Total discs"
+msgstr ""
+
+#empty strings from id 38078 to 38099
+#strings 38078 to 38099 reserved for music library
 
 #. Description of section #14200 "Player""
 #: system/settings/settings.xml
diff --git a/system/library/music/boxsets.xml b/system/library/music/boxsets.xml
new file mode 100644
index 000000000000..e7f36e287f7a
--- /dev/null
+++ b/system/library/music/boxsets.xml
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
+<node order="99" type="folder" visible="Library.HasContent(Boxsets)">
+        <label>38074</label>
+        <icon>DefaultSets.png</icon>
+        <path>musicdb://albums/?boxset=true</path>
+</node>
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index ec98e18efe95..abddbdcfcabd 100755
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1044,6 +1044,11 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+        <setting id="musiclibrary.showdiscs" type="boolean" label="13522" help="13523">
+          <level>0</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
         <setting id="musiclibrary.useartistsortname" type="boolean" label="20228" help="36294">
           <level>1</level>
           <default>false</default>
diff --git a/xbmc/GUIInfoManager.cpp b/xbmc/GUIInfoManager.cpp
index dcbbb468cf1d..af61ded7dd9b 100644
--- a/xbmc/GUIInfoManager.cpp
+++ b/xbmc/GUIInfoManager.cpp
@@ -2531,6 +2531,14 @@ const infomap musicpartymode[] = {{ "enabled",           MUSICPM_ENABLED },
 ///     @skinning_v17 **[New Infolabel]** \link MusicPlayer_DBID `MusicPlayer.DBID`\endlink
 ///     <p>
 ///   }
+///   \table_row3{   <b>`MusicPlayer.DiscTitle`</b>,
+///                  \anchor MusicPlayer_DiscTitle
+///                  _string_,
+///     @return The title of the disc currently playing.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link MusicPlayer_DiscTitle `MusicPlayer.DiscTitle`\endlink
+///     <p>
+///   }
 /// \table_end
 ///
 /// -----------------------------------------------------------------------------
@@ -2551,6 +2559,7 @@ const infomap musicplayer[] =    {{ "title",            MUSICPLAYER_TITLE },
                                   { "samplerate",       MUSICPLAYER_SAMPLERATE },
                                   { "codec",            MUSICPLAYER_CODEC },
                                   { "discnumber",       MUSICPLAYER_DISC_NUMBER },
+                                  { "disctitle",        MUSICPLAYER_DISC_TITLE },
                                   { "rating",           MUSICPLAYER_RATING },
                                   { "ratingandvotes",   MUSICPLAYER_RATING_AND_VOTES },
                                   { "userrating",       MUSICPLAYER_USER_RATING },
@@ -5736,6 +5745,30 @@ const infomap container_str[]  = {{ "property",         CONTAINER_PROPERTY },
 ///     @skinning_v19 **[New Infolabel]** \link ListItem_IsNew `ListItem.IsNew`\endlink
 ///     <p>
 ///   }
+///   \table_row3{   <b>`ListItem.DiscTitle`</b>,
+///                  \anchor ListItem_DiscTitle
+///                  _string_,
+///     @return The disc title of the currently selected album or song.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_DiscTitle `ListItem.DiscTitle`\endlink
+///     <p>
+///   }
+///   \table_row3{   <b>`ListItem.IsBoxset`</b>,
+///                  \anchor ListItem_IsBoxset
+///                  _boolean_,
+///     @return **True** if the item is part of a boxset album.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_IsBoxset `ListItem.IsBoxset`\endlink
+///     <p>
+///   }
+///   \table_row3{   <b>`ListItem.TotalDiscs`</b>,
+///                  \anchor ListItem_TotalDiscs
+///                  _boolean_,
+///     @return The total number of discs belonging to an album.
+///     <p><hr>
+///     @skinning_v19 **[New Infolabel]** \link ListItem_TotalDiscs `ListItem.TotalDiscs`\endlink
+///     <p>
+///   }
 /// \table_end
 ///
 /// -----------------------------------------------------------------------------
@@ -5755,6 +5788,7 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "contributors",     LISTITEM_CONTRIBUTORS },
                                   { "contributorandrole", LISTITEM_CONTRIBUTOR_AND_ROLE },
                                   { "director",         LISTITEM_DIRECTOR },
+                                  { "disctitle",        LISTITEM_DISC_TITLE },
                                   { "filename",         LISTITEM_FILENAME },
                                   { "filenameandpath",  LISTITEM_FILENAME_AND_PATH },
                                   { "fileextension",    LISTITEM_FILE_EXTENSION },
@@ -5929,6 +5963,8 @@ const infomap listitem_labels[]= {{ "thumb",            LISTITEM_THUMB },
                                   { "parentalrating",   LISTITEM_PARENTAL_RATING },
                                   { "currentitem",      LISTITEM_CURRENTITEM },
                                   { "isnew",            LISTITEM_IS_NEW },
+                                  { "isboxset",         LISTITEM_IS_BOXSET },
+                                  { "totaldiscs",       LISTITEM_TOTALDISCS },
 };
 
 /// \page modules__infolabels_boolean_conditions
@@ -8475,6 +8511,14 @@ const infomap slideshow[] =      {{ "ispaused",               SLIDESHOW_ISPAUSED
 ///     @skinning_v17 **[New Boolean Condition]** \link Library_HasContent_Role_Mixer `Library.HasContent(Role.Mixer)`\endlink
 ///     <p>
 ///   }
+///   \table_row3{   <b>`Library.HasContent(boxsets)`</b>,
+///                  \anchor Library_HasContent_Boxsets
+///                  _boolean_,
+///     @return **True** if there are albums in the library which are boxsets.
+///     <p><hr>
+///     @skinning_v19 **[New Boolean Condition]** \link Library_HasContent_Boxsets `Library.HasContent(boxsets)`\endlink
+///     <p>
+///   }
 /// \table_end
 ///
 /// -----------------------------------------------------------------------------
@@ -8889,6 +8933,8 @@ int CGUIInfoManager::TranslateSingleString(const std::string &strCondition, bool
           return LIBRARY_HAS_SINGLES;
         else if (cat == "compilations")
           return LIBRARY_HAS_COMPILATIONS;
+        else if (cat == "boxsets")
+          return LIBRARY_HAS_BOXSETS;
         else if (cat == "role" && prop.num_params() > 1)
           return AddMultiInfo(CGUIInfo(LIBRARY_HAS_ROLE, prop.param(1), 0));
       }
diff --git a/xbmc/SortFileItem.h b/xbmc/SortFileItem.h
index 66ce0e24ea82..defb3d0cf256 100644
--- a/xbmc/SortFileItem.h
+++ b/xbmc/SortFileItem.h
@@ -55,5 +55,6 @@ typedef enum {
   SORT_METHOD_BITRATE,
   SORT_METHOD_DATE_TAKEN,
   SORT_METHOD_CLIENT_CHANNEL_ORDER,
+  SORT_METHOD_TOTAL_DISCS,
   SORT_METHOD_MAX
 } SORT_METHOD;
diff --git a/xbmc/dialogs/GUIDialogMediaFilter.cpp b/xbmc/dialogs/GUIDialogMediaFilter.cpp
index bbd71ab7327a..a829ee6bb100 100644
--- a/xbmc/dialogs/GUIDialogMediaFilter.cpp
+++ b/xbmc/dialogs/GUIDialogMediaFilter.cpp
@@ -105,6 +105,7 @@ static const CGUIDialogMediaFilter::Filter filterList[] = {
 
   { "albums",       FieldAlbum,         556,    SettingType::String,  "edit",   "string",   CDatabaseQueryRule::OPERATOR_CONTAINS },
 //  { "albums",       FieldArtist,        557,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
+  { "albums",       FieldDiscTitle,     38076,  SettingType::String,  "edit",   "string",   CDatabaseQueryRule::OPERATOR_CONTAINS },
   { "albums",       FieldAlbumArtist,   566,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "albums",       FieldSource,      39030,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "albums",       FieldRating,        563,    SettingType::Number,  "range",  "number",   CDatabaseQueryRule::OPERATOR_BETWEEN },
@@ -114,9 +115,11 @@ static const CGUIDialogMediaFilter::Filter filterList[] = {
   { "albums",       FieldGenre,         515,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "albums",       FieldMusicLabel,    21899,  SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "albums",       FieldCompilation,   204,    SettingType::Boolean, "toggle", "",         CDatabaseQueryRule::OPERATOR_FALSE },
+  { "albums",       FieldIsBoxset,      38074,  SettingType::Boolean, "toggle", "",         CDatabaseQueryRule::OPERATOR_FALSE },
 
   { "songs",        FieldTitle,         556,    SettingType::String,  "edit",   "string",   CDatabaseQueryRule::OPERATOR_CONTAINS },
   { "songs",        FieldAlbum,         558,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
+  { "songs",        FieldDiscTitle,   38076,    SettingType::String,  "edit",   "string",   CDatabaseQueryRule::OPERATOR_CONTAINS },
   { "songs",        FieldArtist,        557,    SettingType::List,    "list",   "string",   CDatabaseQueryRule::OPERATOR_EQUALS },
   { "songs",        FieldTime,          180,    SettingType::Integer, "range",  "time",     CDatabaseQueryRule::OPERATOR_BETWEEN },
   { "songs",        FieldRating,        563,    SettingType::Number,  "range",  "number",   CDatabaseQueryRule::OPERATOR_BETWEEN },
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/CMakeLists.txt b/xbmc/filesystem/MusicDatabaseDirectory/CMakeLists.txt
index 93a6a8cef8c8..6eafcba00ab2 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/CMakeLists.txt
+++ b/xbmc/filesystem/MusicDatabaseDirectory/CMakeLists.txt
@@ -6,6 +6,7 @@ set(SOURCES DirectoryNodeAlbum.cpp
             DirectoryNodeAlbumTop100.cpp
             DirectoryNodeAlbumTop100Song.cpp
             DirectoryNodeArtist.cpp
+            DirectoryNodeDiscs.cpp
             DirectoryNode.cpp
             DirectoryNodeGrouped.cpp
             DirectoryNodeOverview.cpp
@@ -25,6 +26,7 @@ set(HEADERS DirectoryNode.h
             DirectoryNodeAlbumTop100.h
             DirectoryNodeAlbumTop100Song.h
             DirectoryNodeArtist.h
+            DirectoryNodeDiscs.h
             DirectoryNodeGrouped.h
             DirectoryNodeOverview.h
             DirectoryNodeRoot.h
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp
index ad98e86162c7..00e1bce6f3dd 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.cpp
@@ -16,6 +16,7 @@
 #include "DirectoryNodeAlbumTop100.h"
 #include "DirectoryNodeAlbumTop100Song.h"
 #include "DirectoryNodeArtist.h"
+#include "DirectoryNodeDiscs.h"
 #include "DirectoryNodeGrouped.h"
 #include "DirectoryNodeOverview.h"
 #include "DirectoryNodeRoot.h"
@@ -114,6 +115,8 @@ CDirectoryNode* CDirectoryNode::CreateNode(NODE_TYPE Type, const std::string& st
   case NODE_TYPE_ROLE:
   case NODE_TYPE_YEAR:
     return new CDirectoryNodeGrouped(Type, strName, pParent);
+  case NODE_TYPE_DISC:
+    return new CDirectoryNodeDiscs(strName, pParent);
   case NODE_TYPE_ARTIST:
     return new CDirectoryNodeArtist(strName, pParent);
   case NODE_TYPE_ALBUM:
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.h b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.h
index 51941125434b..63d11d1547a5 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.h
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNode.h
@@ -38,7 +38,8 @@ namespace XFILE
       NODE_TYPE_SONG,
       NODE_TYPE_SONG_TOP100,
       NODE_TYPE_YEAR,
-      NODE_TYPE_SINGLES
+      NODE_TYPE_SINGLES,
+      NODE_TYPE_DISC,
     } NODE_TYPE;
 
     typedef struct {
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
index f422318bc9b1..f60a0253a826 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbum.cpp
@@ -22,7 +22,7 @@ CDirectoryNodeAlbum::CDirectoryNodeAlbum(const std::string& strName, CDirectoryN
 
 NODE_TYPE CDirectoryNodeAlbum::GetChildType() const
 {
-  return NODE_TYPE_SONG;
+  return NODE_TYPE_DISC;
 }
 
 std::string CDirectoryNodeAlbum::GetLocalizedName() const
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyAdded.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyAdded.cpp
index 72c1a4a42d58..be674da7d6d7 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyAdded.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyAdded.cpp
@@ -26,7 +26,7 @@ NODE_TYPE CDirectoryNodeAlbumRecentlyAdded::GetChildType() const
   if (GetName()=="-1")
     return NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS;
 
-  return NODE_TYPE_SONG;
+  return NODE_TYPE_DISC;
 }
 
 std::string CDirectoryNodeAlbumRecentlyAdded::GetLocalizedName() const
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyPlayed.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyPlayed.cpp
index 34d50acba61b..3e09b4a28175 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyPlayed.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeAlbumRecentlyPlayed.cpp
@@ -26,7 +26,7 @@ NODE_TYPE CDirectoryNodeAlbumRecentlyPlayed::GetChildType() const
   if (GetName()=="-1")
     return NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS;
 
-  return NODE_TYPE_SONG;
+  return NODE_TYPE_DISC;
 }
 
 std::string CDirectoryNodeAlbumRecentlyPlayed::GetLocalizedName() const
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.cpp
new file mode 100644
index 000000000000..42cf3bbba94b
--- /dev/null
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.cpp
@@ -0,0 +1,57 @@
+/*
+ *  Copyright (C) 2005-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DirectoryNodeDiscs.h"
+
+#include "QueryParams.h"
+#include "guilib/LocalizeStrings.h"
+#include "music/MusicDatabase.h"
+
+using namespace XFILE::MUSICDATABASEDIRECTORY;
+
+CDirectoryNodeDiscs::CDirectoryNodeDiscs(const std::string& strName,
+                                         CDirectoryNode* pParent)
+  : CDirectoryNode(NODE_TYPE_DISC, strName, pParent)
+{
+}
+
+NODE_TYPE CDirectoryNodeDiscs::GetChildType() const
+{
+  return NODE_TYPE_SONG;
+}
+
+std::string CDirectoryNodeDiscs::GetLocalizedName() const
+{
+  CQueryParams params;
+  CollectQueryParams(params);
+  std::string title;
+  CMusicDatabase db;
+  if (db.Open())
+    title = db.GetAlbumDiscTitle(params.GetAlbumId(), params.GetDisc());
+  db.Close();
+  if (title.empty())
+    title = g_localizeStrings.Get(15102); // All Albums
+
+  return title;
+}
+
+bool CDirectoryNodeDiscs::GetContent(CFileItemList& items) const
+{
+  CMusicDatabase musicdatabase;
+  if (!musicdatabase.Open())
+    return false;
+
+  CQueryParams params;
+  CollectQueryParams(params);
+
+  bool bSuccess = musicdatabase.GetDiscsNav(BuildPath(), items, params.GetAlbumId());
+
+  musicdatabase.Close();
+
+  return bSuccess;
+}
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.h b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.h
new file mode 100644
index 000000000000..5cf4f6a344ce
--- /dev/null
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeDiscs.h
@@ -0,0 +1,28 @@
+/*
+ *  Copyright (C) 2005-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "DirectoryNode.h"
+
+namespace XFILE
+{
+namespace MUSICDATABASEDIRECTORY
+{
+class CDirectoryNodeDiscs : public CDirectoryNode
+{
+public:
+  CDirectoryNodeDiscs(const std::string& strName, CDirectoryNode* pParent);
+
+protected:
+  NODE_TYPE GetChildType() const override;
+  bool GetContent(CFileItemList& items) const override;
+  std::string GetLocalizedName() const override;
+};
+} // namespace MUSICDATABASEDIRECTORY
+} // namespace XFILE
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
index 54dd81a14b46..f308375b9705 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/DirectoryNodeOverview.cpp
@@ -30,6 +30,7 @@ namespace XFILE
                                 { NODE_TYPE_ALBUM,                 "compilations",         521 },
                                 { NODE_TYPE_ROLE,                  "roles",              38033 },
                                 { NODE_TYPE_SOURCE,                "sources",            39031 },
+                                { NODE_TYPE_DISC,                  "discs",              14087 },
                               };
   };
 };
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.cpp b/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.cpp
index d1aa397bc23f..54dbbcf287f6 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.cpp
+++ b/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.cpp
@@ -19,6 +19,7 @@ CQueryParams::CQueryParams()
   m_idGenre=-1;
   m_idSong=-1;
   m_year=-1;
+  m_disc = -1;
 }
 
 void CQueryParams::SetQueryParam(NODE_TYPE NodeType, const std::string& strNodeName)
@@ -36,6 +37,9 @@ void CQueryParams::SetQueryParam(NODE_TYPE NodeType, const std::string& strNodeN
   case NODE_TYPE_ARTIST:
     m_idArtist=idDb;
     break;
+  case NODE_TYPE_DISC:
+    m_disc = idDb;
+    break;
   case NODE_TYPE_ALBUM_RECENTLY_PLAYED:
   case NODE_TYPE_ALBUM_RECENTLY_ADDED:
   case NODE_TYPE_ALBUM_TOP100:
diff --git a/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.h b/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.h
index 75f95986dcfd..47fcd6fde24b 100644
--- a/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.h
+++ b/xbmc/filesystem/MusicDatabaseDirectory/QueryParams.h
@@ -23,6 +23,7 @@ namespace XFILE
       long GetGenreId() { return m_idGenre; }
       long GetSongId() { return m_idSong; }
       long GetYear() { return m_year; }
+      long GetDisc() { return m_disc; }
 
     protected:
       void SetQueryParam(NODE_TYPE NodeType, const std::string& strNodeName);
@@ -34,6 +35,7 @@ namespace XFILE
       long m_idGenre;
       long m_idSong;
       long m_year;
+      long m_disc;
     };
   }
 }
diff --git a/xbmc/guilib/guiinfo/GUIInfoLabels.h b/xbmc/guilib/guiinfo/GUIInfoLabels.h
index 62b3f8ce1f67..0818b1268eb6 100644
--- a/xbmc/guilib/guiinfo/GUIInfoLabels.h
+++ b/xbmc/guilib/guiinfo/GUIInfoLabels.h
@@ -187,7 +187,7 @@
 
 // Range of musicplayer infolabels that work with offset and position
 #define MUSICPLAYER_OFFSET_POSITION_FIRST MUSICPLAYER_TITLE
-#define MUSICPLAYER_OFFSET_POSITION_LAST MUSICPLAYER_DBID 
+#define MUSICPLAYER_OFFSET_POSITION_LAST MUSICPLAYER_DISC_TITLE
 
 #define MUSICPLAYER_PROPERTY        236
 #define MUSICPLAYER_CHANNEL_NAME    237
@@ -199,6 +199,7 @@
 #define MUSICPLAYER_EXISTS          242
 #define MUSICPLAYER_PLAYLISTPLAYING 243
 #define MUSICPLAYER_CONTENT         244
+#define MUSICPLAYER_DISC_TITLE      245
 
 #define VIDEOPLAYER_AUDIO_BITRATE     248
 #define VIDEOPLAYER_VIDEO_BITRATE     249
@@ -417,6 +418,7 @@
 #define LIBRARY_IS_SCANNING_VIDEO   729
 #define LIBRARY_IS_SCANNING_MUSIC   730
 #define LIBRARY_HAS_ROLE            735
+#define LIBRARY_HAS_BOXSETS         736
 
 #define SYSTEM_PLATFORM_LINUX       741
 #define SYSTEM_PLATFORM_WINDOWS     742
@@ -884,6 +886,9 @@
 #define LISTITEM_FILENAME_NO_EXTENSION (LISTITEM_START + 187)
 #define LISTITEM_CURRENTITEM        (LISTITEM_START + 188)
 #define LISTITEM_IS_NEW             (LISTITEM_START + 189)
+#define LISTITEM_DISC_TITLE         (LISTITEM_START + 190)
+#define LISTITEM_IS_BOXSET          (LISTITEM_START + 191)
+#define LISTITEM_TOTALDISCS         (LISTITEM_START + 192)
 
 #define LISTITEM_END                (LISTITEM_START + 2500)
 
diff --git a/xbmc/guilib/guiinfo/LibraryGUIInfo.cpp b/xbmc/guilib/guiinfo/LibraryGUIInfo.cpp
index 510c05b21562..167fcdb08dfd 100644
--- a/xbmc/guilib/guiinfo/LibraryGUIInfo.cpp
+++ b/xbmc/guilib/guiinfo/LibraryGUIInfo.cpp
@@ -54,6 +54,9 @@ void CLibraryGUIInfo::SetLibraryBool(int condition, bool value)
     case LIBRARY_HAS_COMPILATIONS:
       m_libraryHasCompilations = value ? 1 : 0;
       break;
+    case LIBRARY_HAS_BOXSETS:
+      m_libraryHasBoxsets = value ? 1 : 0;
+      break;
     default:
       break;
   }
@@ -68,6 +71,7 @@ void CLibraryGUIInfo::ResetLibraryBools()
   m_libraryHasMovieSets = -1;
   m_libraryHasSingles = -1;
   m_libraryHasCompilations = -1;
+  m_libraryHasBoxsets = -1;
   m_libraryRoleCounts.clear();
 }
 
@@ -191,6 +195,20 @@ bool CLibraryGUIInfo::GetBool(bool& value, const CGUIListItem *gitem, int contex
       value = m_libraryHasCompilations > 0;
       return true;
     }
+    case LIBRARY_HAS_BOXSETS:
+    {
+      if (m_libraryHasBoxsets < 0)
+      {
+        CMusicDatabase db;
+        if (db.Open())
+        {
+          m_libraryHasBoxsets = (db.GetBoxsetsCount() > 0) ? 1 : 0;
+          db.Close();
+        }
+      }
+      value = m_libraryHasBoxsets > 0;
+      return true;
+    }
     case LIBRARY_HAS_VIDEO:
     {
       return (GetBool(value, gitem, contextWindow, CGUIInfo(LIBRARY_HAS_MOVIES)) ||
diff --git a/xbmc/guilib/guiinfo/LibraryGUIInfo.h b/xbmc/guilib/guiinfo/LibraryGUIInfo.h
index d068d37ea7ee..a9d47fc13a66 100644
--- a/xbmc/guilib/guiinfo/LibraryGUIInfo.h
+++ b/xbmc/guilib/guiinfo/LibraryGUIInfo.h
@@ -47,6 +47,7 @@ class CLibraryGUIInfo : public CGUIInfoProvider
   mutable int m_libraryHasMovieSets;
   mutable int m_libraryHasSingles;
   mutable int m_libraryHasCompilations;
+  mutable int m_libraryHasBoxsets;
 
   //Count of artists in music library contributing to song by role e.g. composers, conductors etc.
   //For checking visibility of custom nodes for a role.
diff --git a/xbmc/guilib/guiinfo/MusicGUIInfo.cpp b/xbmc/guilib/guiinfo/MusicGUIInfo.cpp
index 401fb2a1b04b..692081d5dd54 100644
--- a/xbmc/guilib/guiinfo/MusicGUIInfo.cpp
+++ b/xbmc/guilib/guiinfo/MusicGUIInfo.cpp
@@ -144,6 +144,13 @@ bool CMusicGUIInfo::GetLabel(std::string& value, const CFileItem *item, int cont
           return true;
         }
         break;
+      case LISTITEM_TOTALDISCS:
+        value = StringUtils::Format("%i", tag->GetTotalDiscs());
+        return true;
+      case MUSICPLAYER_DISC_TITLE:
+      case LISTITEM_DISC_TITLE:
+        value = tag->GetDiscSubtitle();
+        return true;
       case MUSICPLAYER_ARTIST:
       case LISTITEM_ARTIST:
         value = tag->GetArtistString();
@@ -556,6 +563,19 @@ bool CMusicGUIInfo::GetBool(bool& value, const CGUIListItem *gitem, int contextW
     case MUSICPM_ENABLED:
       value = g_partyModeManager.IsEnabled();
       return true;
+
+    ///////////////////////////////////////////////////////////////////////////////////////////////
+    // LISTITEM_*
+    ///////////////////////////////////////////////////////////////////////////////////////////////
+    case LISTITEM_IS_BOXSET:
+      const CFileItem* item = static_cast<const CFileItem*>(gitem);
+      const CMusicInfoTag* tag = item->GetMusicInfoTag();
+      if (tag)
+      {
+        value = item->GetMusicInfoTag()->GetBoxset() == true;
+        return true;
+      }
+      break;
   }
 
   return false;
diff --git a/xbmc/music/Album.cpp b/xbmc/music/Album.cpp
index 9e9c1cc87641..222d1b3d2069 100644
--- a/xbmc/music/Album.cpp
+++ b/xbmc/music/Album.cpp
@@ -54,6 +54,7 @@ CAlbum::CAlbum(const CFileItem& item)
   strType = tag.GetMusicBrainzReleaseType();
   bCompilation = tag.GetCompilation();
   iTimesPlayed = 0;
+  bBoxedSet = tag.GetBoxset();
   dateAdded.Reset();
   lastPlayed.Reset();
   releaseType = tag.GetAlbumReleaseType();
@@ -480,6 +481,7 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
   XMLUtils::GetStringArray(album, "mood", moods, prioritise, itemSeparator);
   XMLUtils::GetStringArray(album, "theme", themes, prioritise, itemSeparator);
   XMLUtils::GetBoolean(album, "compilation", bCompilation);
+  XMLUtils::GetBoolean(album, "boxset", bBoxedSet);
 
   XMLUtils::GetString(album,"review",strReview);
   XMLUtils::GetString(album,"releasedate",m_strDateOfRelease);
@@ -594,6 +596,7 @@ bool CAlbum::Save(TiXmlNode *node, const std::string &tag, const std::string& st
   XMLUtils::SetStringArray(album,                "mood", moods);
   XMLUtils::SetStringArray(album,               "theme", themes);
   XMLUtils::SetBoolean(album,      "compilation", bCompilation);
+  XMLUtils::SetBoolean(album, "boxset", bBoxedSet);
 
   XMLUtils::SetString(album,      "review", strReview);
   XMLUtils::SetString(album,        "type", strType);
diff --git a/xbmc/music/Album.h b/xbmc/music/Album.h
index 875addf26d31..cc560f5def2f 100644
--- a/xbmc/music/Album.h
+++ b/xbmc/music/Album.h
@@ -56,9 +56,11 @@ class CAlbum
     iVotes = -1;
     iYear = -1;
     bCompilation = false;
+    bBoxedSet = false;
     iTimesPlayed = 0;
     dateAdded.Reset();
     lastPlayed.Reset();
+    iTotalDiscs = -1;
     songs.clear();
     releaseType = Album;
     strLastScraped.clear();
@@ -155,10 +157,12 @@ class CAlbum
   int iUserrating = -1;
   int iVotes = -1;
   int iYear = -1;
+  bool bBoxedSet = false;
   bool bCompilation = false;
   int iTimesPlayed = 0;
   CDateTime dateAdded;
   CDateTime lastPlayed;
+  int iTotalDiscs = -1;
   VECSONGS songs;     ///< Local songs
   ReleaseType releaseType = Album;
   std::string strLastScraped;
diff --git a/xbmc/music/GUIViewStateMusic.cpp b/xbmc/music/GUIViewStateMusic.cpp
index 14c622c70dbd..d3e9c42e22e0 100644
--- a/xbmc/music/GUIViewStateMusic.cpp
+++ b/xbmc/music/GUIViewStateMusic.cpp
@@ -167,6 +167,10 @@ CGUIViewStateMusicDatabase::CGUIViewStateMusicDatabase(const CFileItemList& item
       AddSortMethod(SortByArtist, sortAttribute, 557, LABEL_MASKS("%F", "", strAlbum, "%A"));  // Filename, empty | Userdefined, Artist
       // artist / year
       AddSortMethod(SortByArtistThenYear, sortAttribute, 578, LABEL_MASKS("%F", "", strAlbum, "%A / %Y"));  // Filename, empty | Userdefined, Artist / Year
+      // discs
+      AddSortMethod(
+          SortByTotalDiscs, sortAttribute, 38077,
+          LABEL_MASKS("%F", "", strAlbum, "%b")); // Filename, empty | Userdefined, Total discs
       // year
       AddSortMethod(SortByYear, 562, LABEL_MASKS("%F", "", strAlbum, "%Y"));  // Filename, empty | Userdefined, Year
       // album date added
@@ -288,6 +292,12 @@ CGUIViewStateMusicDatabase::CGUIViewStateMusicDatabase(const CFileItemList& item
       SetSortOrder(SortOrderNone);
     }
     break;
+  case NODE_TYPE_DISC:
+    {
+      AddSortMethod(SortByNone, 427, LABEL_MASKS("%L")); // Use the existing label
+      SetSortMethod(SortByNone);
+    }
+    break;
   default:
     break;
   }
@@ -365,6 +375,10 @@ CGUIViewStateMusicSmartPlaylist::CGUIViewStateMusicSmartPlaylist(const CFileItem
     AddSortMethod(SortByArtist, sortAttribute, 557, LABEL_MASKS("%F", "", strAlbum, "%A"));  // Filename, empty | Userdefined, Artist
     // artist / year
     AddSortMethod(SortByArtistThenYear, sortAttribute, 578, LABEL_MASKS("%F", "", strAlbum, "%A / %Y"));  // Filename, empty | Userdefined, Artist / Year
+    // discs
+    AddSortMethod(
+        SortByTotalDiscs, sortAttribute, 38077,
+        LABEL_MASKS("%F", "", strAlbum, "%b")); // Filename, empty | Userdefined, Total discs
     // year
     AddSortMethod(SortByYear, 562, LABEL_MASKS("%F", "", strAlbum, "%Y"));
     // album date added
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index ff7cbe244d45..dfc274db6e31 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -142,6 +142,7 @@ void CMusicDatabase::CreateTables()
               " strReleaseGroupMBID text, "
               " strArtistDisp text, strArtistSort text, strGenres text, "
               " iYear integer, "
+              " bBoxedSet INTEGER NOT NULL DEFAULT 0, "
               " bCompilation integer not null default '0', "
               " strMoods text, strStyles text, strThemes text, "
               " strReview text, strImage text, strLabel text, "
@@ -152,6 +153,7 @@ void CMusicDatabase::CreateTables()
               " lastScraped varchar(20) default NULL, "
               " bScrapedMBID INTEGER NOT NULL DEFAULT 0, "
               " strReleaseType text, "
+              " iDiscTotal INTEGER NOT NULL DEFAULT 0, "
               " idInfoSetting INTEGER NOT NULL DEFAULT 0)");
 
   CLog::Log(LOGINFO, "create audiobook table");
@@ -183,7 +185,7 @@ void CMusicDatabase::CreateTables()
               " idAlbum integer, idPath integer, "
               " strArtistDisp text, strArtistSort text, strGenres text, strTitle varchar(512), "
               " iTrack integer, iDuration integer, iYear integer, "
-              " strFileName text, strMusicBrainzTrackID text, "
+              " strDiscSubtitle text, strFileName text, strMusicBrainzTrackID text, "
               " iTimesPlayed integer, iStartOffset integer, iEndOffset integer, "
               " lastplayed varchar(20) default NULL, "
               " rating FLOAT NOT NULL DEFAULT 0, votes INTEGER NOT NULL DEFAULT 0, "
@@ -300,6 +302,7 @@ void CMusicDatabase::CreateViews()
               "        strTitle, "
               "        iTrack, iDuration, "
               "        song.iYear AS iYear, "
+              "        song.strDiscSubtitle as strDiscSubtitle, "
               "        strFileName, "
               "        strMusicBrainzTrackID, "
               "        iTimesPlayed, iStartOffset, iEndOffset, "
@@ -312,6 +315,7 @@ void CMusicDatabase::CreateViews()
               "        strAlbum, "
               "        strPath, "
               "        album.bCompilation AS bCompilation,"
+              "        album.bBoxedSet AS bBoxedSet, "
               "        album.strArtistDisp AS strAlbumArtists,"
               "        album.strArtistSort AS strAlbumArtistSort,"
               "        album.strReleaseType AS strAlbumReleaseType,"
@@ -334,6 +338,7 @@ void CMusicDatabase::CreateViews()
               "        album.strArtistSort AS strArtistSort, "
               "        album.strGenres AS strGenres, "
               "        album.iYear AS iYear, "
+              "        album.bBoxedSet AS bBoxedSet, "
               "        album.strMoods AS strMoods, "
               "        album.strStyles AS strStyles, "
               "        strThemes, "
@@ -349,6 +354,7 @@ void CMusicDatabase::CreateViews()
               "        lastScraped,"
               "        (SELECT ROUND(AVG(song.iTimesPlayed)) FROM song WHERE song.idAlbum = album.idAlbum) AS iTimesPlayed, "
               "        strReleaseType, "
+              "        iDiscTotal, "
               "        (SELECT MAX(song.dateAdded) FROM song WHERE song.idAlbum = album.idAlbum) AS dateAdded, "
               "        (SELECT MAX(song.lastplayed) FROM song WHERE song.idAlbum = album.idAlbum) AS lastplayed "
               "FROM album"
@@ -423,6 +429,7 @@ bool CMusicDatabase::AddAlbum(CAlbum& album, int idSource)
                            album.GetAlbumArtistSort(),
                            album.GetGenreString(),
                            album.iYear,
+                           album.bBoxedSet,
                            album.strLabel, album.strType,
                            album.bCompilation, album.releaseType);
 
@@ -450,6 +457,7 @@ bool CMusicDatabase::AddAlbum(CAlbum& album, int idSource)
                            song->GetArtistSort(),
                            song->genre,
                            song->iTrack, song->iDuration, song->iYear,
+                           song->strDiscSubtitle,
                            song->iTimesPlayed, song->iStartOffset,
                            song->iEndOffset,
                            song->lastPlayed,
@@ -489,6 +497,24 @@ bool CMusicDatabase::AddAlbum(CAlbum& album, int idSource)
   for (const auto &albumArt : album.art)
     SetArtForItem(album.idAlbum, MediaTypeAlbum, albumArt.first, albumArt.second);
 
+  // Set album disc total
+  m_pDS->exec(
+      PrepareSQL("UPDATE album SET iDisctotal = (SELECT COUNT(DISTINCT iTrack >> 16) FROM song "
+                 "WHERE song.idAlbum = album.idAlbum) WHERE idAlbum = %i",
+                 album.idAlbum));
+  // Set a non-compilation album as a boxset if it has three or more distinct disc titles
+  if (!album.bBoxedSet && !album.bCompilation)
+  {
+    std::string strSQL;
+    strSQL = PrepareSQL("SELECT COUNT(DISTINCT strDiscSubtitle) FROM song WHERE song.idAlbum = %i",
+                        album.idAlbum);
+    int numTitles = static_cast<int>(strtol(GetSingleValue(strSQL).c_str(), nullptr, 10));
+    if (numTitles >=3)
+    {
+      strSQL = PrepareSQL("UPDATE album SET bBoxedSet=1 WHERE album.idAlbum=%i", album.idAlbum);
+      m_pDS->exec(strSQL);
+    }
+  }
   CommitTransaction();
   return true;
 }
@@ -511,7 +537,8 @@ bool CMusicDatabase::UpdateAlbum(CAlbum& album)
               album.strReview,
               album.thumbURL.m_xml.c_str(),
               album.strLabel, album.strType,
-              album.fRating, album.iUserrating, album.iVotes, album.iYear, album.bCompilation, album.releaseType,
+              album.fRating, album.iUserrating, album.iVotes, album.iYear, album.bBoxedSet,
+              album.bCompilation, album.releaseType,
               album.bScrapedMBID);
 
   if (!album.bArtistSongMerge)
@@ -557,6 +584,7 @@ int CMusicDatabase::AddSong(const int idAlbum,
                             const std::string &artistDisp, const std::string &artistSort,
                             const std::vector<std::string>& genres,
                             int iTrack, int iDuration, int iYear,
+                            std::string& strDiscSubtitle,
                             const int iTimesPlayed, int iStartOffset, int iEndOffset,
                             const CDateTime& dtLastPlayed, float rating, int userrating, int votes,
                             const ReplayGain& replayGain)
@@ -596,18 +624,27 @@ int CMusicDatabase::AddSong(const int idAlbum,
     if (m_pDS->num_rows() == 0)
     {
       m_pDS->close();
+
+      // As all discs in a boxset have to have a title, generate one in the form of 'Disc N'
+      bool isBoxset = IsAlbumBoxset(idAlbum);
+      if (isBoxset && strDiscSubtitle.empty())
+      {
+        int discno = iTrack >> 16;
+        strDiscSubtitle = StringUtils::Format("%s %i", g_localizeStrings.Get(427), discno);
+      }
       strSQL=PrepareSQL("INSERT INTO song ("
                                           "idSong,idAlbum,idPath,strArtistDisp,"
-                                          "strTitle,iTrack,iDuration,iYear,strFileName,"
+                                          "strTitle,iTrack,iDuration,iYear,strDiscSubtitle,strFileName,"
                                           "strMusicBrainzTrackID, strArtistSort, "
                                           "iTimesPlayed,iStartOffset, "
                                           "iEndOffset,lastplayed,rating,userrating,votes,comment,mood,strReplayGain"
-                        ") values (NULL, %i, %i, '%s', '%s', %i, %i, %i, '%s'",
+                        ") values (NULL, %i, %i, '%s', '%s', %i, %i, %i, '%s', '%s'",
                     idAlbum,
                     idPath,
                     artistDisp.c_str(),
                     strTitle.c_str(),
                     iTrack, iDuration, iYear,
+                    strDiscSubtitle.c_str(),
                     strFileName.c_str());
 
       if (strMusicBrainzTrackID.empty())
@@ -633,11 +670,11 @@ int CMusicDatabase::AddSong(const int idAlbum,
     {
       idSong = m_pDS->fv("idSong").get_asInt();
       m_pDS->close();
-      UpdateSong( idSong, strTitle, strMusicBrainzTrackID, strPathAndFileName, strComment, strMood, strThumb,
-                  artistDisp, artistSort, genres, iTrack, iDuration, iYear, iTimesPlayed, iStartOffset, iEndOffset,
-                  dtLastPlayed, rating, userrating, votes, replayGain);
+      UpdateSong(idSong, strTitle, strMusicBrainzTrackID, strPathAndFileName, strComment, strMood,
+                 strThumb, artistDisp, artistSort, genres, iTrack, iDuration, iYear,
+                 strDiscSubtitle, iTimesPlayed, iStartOffset, iEndOffset, dtLastPlayed, rating,
+                 userrating, votes, replayGain);
     }
-
     if (!strThumb.empty())
       SetArtForItem(idSong, MediaTypeSong, "thumb", strThumb);
 
@@ -720,6 +757,7 @@ bool CMusicDatabase::UpdateSong(CSong& song, bool bArtists /*= true*/)
                     song.iTrack,
                     song.iDuration,
                     song.iYear,
+                    song.strDiscSubtitle,
                     song.iTimesPlayed,
                     song.iStartOffset,
                     song.iEndOffset,
@@ -764,6 +802,7 @@ int CMusicDatabase::UpdateSong(int idSong,
                                const std::string &artistDisp, const std::string &artistSort,
                                const std::vector<std::string>& genres,
                                int iTrack, int iDuration, int iYear,
+                               const std::string& strDiscSubtitle,
                                int iTimesPlayed, int iStartOffset, int iEndOffset,
                                const CDateTime& dtLastPlayed, float rating, int userrating, int votes,
                                const ReplayGain& replayGain)
@@ -776,14 +815,16 @@ int CMusicDatabase::UpdateSong(int idSong,
   SplitPath(strPathAndFileName, strPath, strFileName);
   int idPath = AddPath(strPath);
 
-  strSQL = PrepareSQL("UPDATE song SET idPath = %i, strArtistDisp = '%s', strGenres = '%s', "
-      " strTitle = '%s', iTrack = %i, iDuration = %i, iYear = %i, strFileName = '%s'",
-      idPath,
-      artistDisp.c_str(),
-      StringUtils::Join(genres, CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_musicItemSeparator).c_str(),
-      strTitle.c_str(),
-      iTrack, iDuration, iYear,
-      strFileName.c_str());
+  strSQL = PrepareSQL(
+      "UPDATE song SET idPath = %i, strArtistDisp = '%s', strGenres = '%s', "
+      " strTitle = '%s', iTrack = %i, iDuration = %i, iYear = %i, strDiscSubtitle = '%s', "
+      "strFileName = '%s'",
+      idPath, artistDisp.c_str(),
+      StringUtils::Join(
+          genres,
+          CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_musicItemSeparator)
+          .c_str(),
+      strTitle.c_str(), iTrack, iDuration, iYear, strDiscSubtitle.c_str(), strFileName.c_str());
   if (strMusicBrainzTrackID.empty())
     strSQL += PrepareSQL(", strMusicBrainzTrackID = NULL");
   else
@@ -814,7 +855,7 @@ int CMusicDatabase::UpdateSong(int idSong,
 int CMusicDatabase::AddAlbum(const std::string& strAlbum, const std::string& strMusicBrainzAlbumID,
                              const std::string& strReleaseGroupMBID,
                              const std::string& strArtist, const std::string& strArtistSort,
-                             const std::string& strGenre, int year,
+                             const std::string& strGenre, int year, bool bBoxedSet,
                              const std::string& strRecordLabel, const std::string& strType,
                              bool bCompilation, CAlbum::ReleaseType releaseType)
 {
@@ -834,22 +875,20 @@ int CMusicDatabase::AddAlbum(const std::string& strAlbum, const std::string& str
                           strArtist.c_str(),
                           strAlbum.c_str());
     m_pDS->query(strSQL);
-
+    if (strType.find("boxset") != std::string::npos) //boxset flagged in album type
+      bBoxedSet = true;
     if (m_pDS->num_rows() == 0)
     {
       m_pDS->close();
       // doesnt exists, add it
-      strSQL = PrepareSQL("INSERT INTO album (idAlbum, strAlbum, strArtistDisp, strGenres, iYear, "
-        "strLabel, strType, bCompilation, strReleaseType, strMusicBrainzAlbumID, strReleaseGroupMBID, strArtistSort) "
-        "values(NULL, '%s', '%s', '%s', %i, '%s', '%s', %i, '%s'",
-        strAlbum.c_str(),
-        strArtist.c_str(),
-        strGenre.c_str(),
-        year,
-        strRecordLabel.c_str(),
-        strType.c_str(),
-        bCompilation,
-        CAlbum::ReleaseTypeToString(releaseType).c_str());
+      strSQL = PrepareSQL(
+          "INSERT INTO album (idAlbum, strAlbum, strArtistDisp, strGenres, iYear, bBoxedSet, "
+          "strLabel, strType, bCompilation, strReleaseType, strMusicBrainzAlbumID, "
+          "strReleaseGroupMBID, strArtistSort) "
+          "values(NULL, '%s', '%s', '%s', %i, %i, '%s', '%s', %i, '%s'",
+          strAlbum.c_str(), strArtist.c_str(), strGenre.c_str(), year, bBoxedSet,
+          strRecordLabel.c_str(), strType.c_str(), bCompilation,
+          CAlbum::ReleaseTypeToString(releaseType).c_str());
 
       if (strMusicBrainzAlbumID.empty())
         strSQL += PrepareSQL(", NULL");
@@ -894,16 +933,12 @@ int CMusicDatabase::AddAlbum(const std::string& strAlbum, const std::string& str
       else
         strSQL += PrepareSQL(" strArtistSort = '%s'", strArtistSort.c_str());
 
-      strSQL += PrepareSQL(", strGenres = '%s', iYear=%i, strLabel = '%s', strType = '%s', "
-        "bCompilation=%i, strReleaseType = '%s', lastScraped = NULL "
-        "WHERE idAlbum=%i",
-        strGenre.c_str(),
-        year,
-        strRecordLabel.c_str(),
-        strType.c_str(),
-        bCompilation,
-        CAlbum::ReleaseTypeToString(releaseType).c_str(),
-        idAlbum);
+      strSQL +=
+          PrepareSQL(", strGenres = '%s', iYear=%i, bBoxedSet=%i, strLabel = '%s', strType = '%s', "
+                     "bCompilation=%i, strReleaseType = '%s', lastScraped = NULL "
+                     "WHERE idAlbum=%i",
+                     strGenre.c_str(), year, bBoxedSet, strRecordLabel.c_str(), strType.c_str(),
+                     bCompilation, CAlbum::ReleaseTypeToString(releaseType).c_str(), idAlbum);
       m_pDS->exec(strSQL);
       DeleteAlbumArtistsByAlbum(idAlbum);
       DeleteAlbumSources(idAlbum);
@@ -918,18 +953,28 @@ int CMusicDatabase::AddAlbum(const std::string& strAlbum, const std::string& str
   return -1;
 }
 
-int  CMusicDatabase::UpdateAlbum(int idAlbum,
-                                 const std::string& strAlbum, const std::string& strMusicBrainzAlbumID,
-                                 const std::string& strReleaseGroupMBID,
-                                 const std::string& strArtist, const std::string& strArtistSort,
-                                 const std::string& strGenre,
-                                 const std::string& strMoods, const std::string& strStyles,
-                                 const std::string& strThemes, const std::string& strReview,
-                                 const std::string& strImage, const std::string& strLabel,
-                                 const std::string& strType,
-                                 float fRating, int iUserrating, int iVotes, int iYear, bool bCompilation,
-                                 CAlbum::ReleaseType releaseType,
-                                 bool bScrapedMBID)
+int CMusicDatabase::UpdateAlbum(int idAlbum,
+                                const std::string& strAlbum,
+                                const std::string& strMusicBrainzAlbumID,
+                                const std::string& strReleaseGroupMBID,
+                                const std::string& strArtist,
+                                const std::string& strArtistSort,
+                                const std::string& strGenre,
+                                const std::string& strMoods,
+                                const std::string& strStyles,
+                                const std::string& strThemes,
+                                const std::string& strReview,
+                                const std::string& strImage,
+                                const std::string& strLabel,
+                                const std::string& strType,
+                                float fRating,
+                                int iUserrating,
+                                int iVotes,
+                                int iYear,
+                                bool bBoxedSet,
+                                bool bCompilation,
+                                CAlbum::ReleaseType releaseType,
+                                bool bScrapedMBID)
 {
   if (idAlbum < 0)
     return -1;
@@ -940,13 +985,13 @@ int  CMusicDatabase::UpdateAlbum(int idAlbum,
                       " strMoods = '%s', strStyles = '%s', strThemes = '%s', "
                       " strReview = '%s', strImage = '%s', strLabel = '%s', "
                       " strType = '%s', fRating = %f, iUserrating = %i, iVotes = %i,"
-                      " iYear = %i, bCompilation = %i, strReleaseType = '%s', "
+                      " iYear = %i, bBoxedSet = %i, bCompilation = %i, strReleaseType = '%s', "
                       " lastScraped = '%s', bScrapedMBID = %i",
                       strAlbum.c_str(), strArtist.c_str(), strGenre.c_str(),
                       strMoods.c_str(), strStyles.c_str(), strThemes.c_str(),
                       strReview.c_str(), strImage.c_str(), strLabel.c_str(),
                       strType.c_str(), fRating, iUserrating, iVotes,
-                      iYear, bCompilation,
+                      iYear, bBoxedSet, bCompilation,
                       CAlbum::ReleaseTypeToString(releaseType).c_str(),
                       CDateTime::GetCurrentDateTime().GetAsDBDateTime().c_str(),
                       bScrapedMBID);
@@ -2203,6 +2248,7 @@ void CMusicDatabase::GetFileItemFromDataset(const dbiplus::sql_record* const rec
   stTime.wYear = static_cast<unsigned short>(record->at(song_iYear).get_asInt());
   item->GetMusicInfoTag()->SetReleaseDate(stTime);
   item->GetMusicInfoTag()->SetTitle(record->at(song_strTitle).get_asString());
+  item->GetMusicInfoTag()->SetDiscSubtitle(record->at(song_strDiscSubtitle).get_asString());
   item->SetLabel(record->at(song_strTitle).get_asString());
   item->m_lStartOffset = record->at(song_iStartOffset).get_asInt64();
   item->SetProperty("item_start", item->m_lStartOffset);
@@ -2219,6 +2265,7 @@ void CMusicDatabase::GetFileItemFromDataset(const dbiplus::sql_record* const rec
   std::string strRealPath = URIUtils::AddFileToFolder(record->at(song_strPath).get_asString(), record->at(song_strFileName).get_asString());
   item->GetMusicInfoTag()->SetURL(strRealPath);
   item->GetMusicInfoTag()->SetCompilation(record->at(song_bCompilation).get_asInt() == 1);
+  item->GetMusicInfoTag()->SetBoxset(record->at(song_bBoxedSet).get_asInt() == 1);
   // get the album artist string from songview (not the album_artist and artist tables)
   item->GetMusicInfoTag()->SetAlbumArtist(record->at(song_strAlbumArtists).get_asString());
   item->GetMusicInfoTag()->SetAlbumReleaseType(CAlbum::ReleaseTypeFromString(record->at(song_strAlbumReleaseType).get_asString()));
@@ -2292,6 +2339,7 @@ CAlbum CMusicDatabase::GetAlbumFromDataset(const dbiplus::sql_record* const reco
   album.strArtistSort = record->at(offset + album_strArtistSort).get_asString();
   album.genre = StringUtils::Split(record->at(offset + album_strGenres).get_asString(), itemSeparator);
   album.iYear = record->at(offset + album_iYear).get_asInt();
+  album.bBoxedSet = record->at(offset + album_bBoxedSet).get_asInt() == 1;
   if (imageURL)
     album.thumbURL.ParseString(record->at(offset + album_strThumbURL).get_asString());
   album.fRating = record->at(offset + album_fRating).get_asFloat();
@@ -2309,6 +2357,7 @@ CAlbum CMusicDatabase::GetAlbumFromDataset(const dbiplus::sql_record* const reco
   album.strLastScraped = record->at(offset + album_lastScraped).get_asString();
   album.iTimesPlayed = record->at(offset + album_iTimesPlayed).get_asInt();
   album.SetReleaseType(record->at(offset + album_strReleaseType).get_asString());
+  album.iTotalDiscs = record->at(offset + album_iTotalDiscs).get_asInt();
   album.SetDateAdded(record->at(offset + album_dtDateAdded).get_asString());
   album.SetLastPlayed(record->at(offset + album_dtLastPlayed).get_asString());
   return album;
@@ -4591,6 +4640,216 @@ bool CMusicDatabase::GetAlbumsByWhere(const std::string &baseDir, const Filter &
   return false;
 }
 
+bool CMusicDatabase::GetDiscsNav(const std::string& strBaseDir, CFileItemList& items, int idAlbum,
+  const Filter& filter, const SortDescription& sortDescription, bool countOnly)
+{
+  CMusicDbUrl musicUrl;
+  if (!musicUrl.FromString(strBaseDir))
+    return false;
+
+  if (idAlbum > 0)
+    musicUrl.AddOption("albumid", idAlbum);
+
+  return GetDiscsByWhere(musicUrl, filter, items, sortDescription, countOnly);
+}
+
+bool CMusicDatabase::GetDiscsByWhere(const std::string& baseDir,
+                                     const Filter& filter,
+                                     CFileItemList& items,
+                                     const SortDescription& sortDescription,
+                                     bool countOnly)
+{
+  CMusicDbUrl musicUrl;
+  if (!musicUrl.FromString(baseDir))
+    return false;
+  return GetDiscsByWhere(musicUrl, filter, items, sortDescription, countOnly);
+}
+
+bool CMusicDatabase::GetDiscsByWhere(CMusicDbUrl& musicUrl,
+                                     const Filter& filter,
+                                     CFileItemList& items,
+                                     const SortDescription& sortDescription,
+                                     bool countOnly)
+{
+  if (m_pDB == nullptr || m_pDS == nullptr)
+    return false;
+
+  try
+  {
+    unsigned int querytime = 0;
+    unsigned int time = XbmcThreads::SystemClockMillis();
+    int total = -1;
+    std::string strSQL;
+
+    Filter extFilter = filter;
+    SortDescription sorting = sortDescription;
+
+    if (!GetFilter(musicUrl, extFilter, sorting))
+      return false;
+
+    extFilter.AppendGroup("albumview.idAlbum, iDisc");
+
+    // If there are extra songview WHERE conditions adjust to song or albumview
+    // fields, and join Path table for strPath
+    // ! @todo: convert songview fields into to song or albumview fields
+    // But not sure we ever get songview fields in filter - REMOVE??
+    if (extFilter.where.find("songview.strPath") != std::string::npos)
+    {
+      extFilter.AppendJoin("JOIN path ON song.idPath = path.idPath");
+    }
+
+    std::string strSQLExtra;
+    if (!BuildSQL(strSQLExtra, extFilter, strSQLExtra))
+      return false;
+
+    // Apply any limiting directly in SQL if there is either no special sorting or random sort
+    // When limited, random sort is also applied in SQL
+    bool limitedInSQL = extFilter.limit.empty() &&
+      (sortDescription.sortBy == SortByNone || sortDescription.sortBy == SortByRandom) &&
+      (sortDescription.limitStart > 0 || sortDescription.limitEnd > 0);
+
+    if (countOnly || limitedInSQL)
+    {
+      // Count number of discs that satisfy selection criteria 
+      // (when fetching all records get total from row count of results dataset)
+      // Count not allow for same non-null title discs to be grouped together
+      strSQL = "SELECT iTrack >> 16 AS iDisc FROM albumview JOIN song on song.idAlbum = "
+               "albumview.idAlbum " +
+               strSQLExtra;
+      strSQL = "SELECT COUNT(1) FROM (" + strSQL + ") AS albumdisc ";
+      total = static_cast<int>(strtol(GetSingleValue(strSQL, m_pDS).c_str(), nullptr, 10));
+    }
+    if (countOnly)
+    {
+      items.SetProperty("total", total);
+      return true;
+    }
+    // Apply limits and random sort order directly in SQL
+    if (limitedInSQL)
+    {
+      if (sortDescription.sortBy == SortByRandom)
+        strSQLExtra += PrepareSQL(" ORDER BY RANDOM()");
+      strSQLExtra +=
+          DatabaseUtils::BuildLimitClause(sortDescription.limitEnd, sortDescription.limitStart);
+    }
+    else
+      strSQLExtra += PrepareSQL(" ORDER BY albumview.idAlbum, iDisc");
+
+    strSQL = "SELECT iTrack >> 16 AS iDisc, strDiscSubtitle, albumview.* "
+      "FROM albumview JOIN song on song.idAlbum = albumview.idAlbum " + strSQLExtra;
+
+    // run query
+    CLog::Log(LOGDEBUG, "%s query: %s", __FUNCTION__, strSQL.c_str());
+    querytime = XbmcThreads::SystemClockMillis();
+    if (!m_pDS->query(strSQL))
+      return false;
+    int iRowsFound = m_pDS->num_rows();
+    if (iRowsFound == 0)
+    {
+      m_pDS->close();
+      return true;
+    }
+    querytime = XbmcThreads::SystemClockMillis() - querytime;
+
+    // store the total value of items as a property
+    if (total < iRowsFound)
+      total = iRowsFound;
+    items.SetProperty("total", total);
+
+    DatabaseResults results;
+    results.reserve(iRowsFound);
+
+    // Avoid sorting with limits, just fetch results from dataset
+    // Limit when SortByNone already applied in SQL,
+    // Need guaranteed ordering for dataset processing to group by disc title
+    // so apply sort later to fileitems list rather than dataset
+    sorting = sortDescription;
+    if (sortDescription.sortBy != SortByNone)
+      sorting.sortBy = SortByNone;
+    if (!SortUtils::SortFromDataset(sorting, MediaTypeAlbum, m_pDS, results))
+      return false;
+
+    // Get data from returned rows, note possibly multiple albums although usually only one
+    items.Reserve(total);
+    int albumOffset = 2;
+    CAlbum album;
+    bool useTitle = false;
+    std::string oldDiscTitle;
+    const dbiplus::query_data& data = m_pDS->get_result_set().records;
+    for (const auto& i : results)
+    {
+      unsigned int targetRow = static_cast<unsigned int>(i.at(FieldRow).asInteger());
+      const dbiplus::sql_record* const record = data.at(targetRow);
+      try
+      {
+        if (album.idAlbum != record->at(albumOffset + album_idAlbum).get_asInt())
+        { // New album
+          useTitle = false;
+          album = GetAlbumFromDataset(record, albumOffset);
+        }
+
+        int discnum = record->at(0).get_asInt();
+        std::string strDiscSubtitle = record->at(1).get_asString();
+        if (strDiscSubtitle.empty())
+          // Make (fake) disc title from disc number
+          strDiscSubtitle = StringUtils::Format("%s %i", g_localizeStrings.Get(427), discnum);
+        else if (oldDiscTitle == strDiscSubtitle)
+        { // When real disc titles are provided (as they ALWAYS are for boxed sets)
+          // group discs together by title not number.
+          useTitle = true;
+          continue;
+        }
+        else
+          oldDiscTitle = strDiscSubtitle;
+
+        CMusicDbUrl itemUrl = musicUrl;
+        std::string path = StringUtils::Format("%i/", discnum);
+        itemUrl.AppendPath(path);
+
+        // When disc titles are provided group discs together by title not number.
+        // For monster sets like https://musicbrainz.org/release/cc967f36-7e4e-4a5b-ae0d-f1a1ab2c9c5a
+        if (useTitle)
+          itemUrl.AddOption("disctitle", strDiscSubtitle.c_str());
+        else
+          itemUrl.AddOption("discid", discnum);
+        CFileItemPtr pItem(new CFileItem(itemUrl.ToString(), album));
+        pItem->SetLabel2(record->at(0).get_asString()); // GUI show label2 for disc sort order??
+        pItem->GetMusicInfoTag()->SetDiscNumber(
+            discnum); // Skins show discnumber for "albums"?? Confluence does.
+        pItem->SetLabel(strDiscSubtitle);
+        pItem->SetArt("icon", "DefaultAlbumCover.png");
+        items.Add(pItem);
+      }
+      catch (...)
+      {
+        m_pDS->close();
+        CLog::Log(LOGERROR, "%s - out of memory getting listing (got %i)", __FUNCTION__,
+                  items.Size());
+      }
+    }
+
+    // cleanup
+    m_pDS->close();
+
+    // Finally do any sorting in items list we have not been able to do before in SQL or dataset,
+    // that is when have join with songartistview and sorting other than random with limit
+    if (sortDescription.sortBy != SortByNone &&
+        !(limitedInSQL && sortDescription.sortBy == SortByRandom))
+      items.Sort(sortDescription);
+
+    CLog::Log(LOGDEBUG, "{0}: Time to fill list with discs {1}ms query took {2}ms",
+      __FUNCTION__, XbmcThreads::SystemClockMillis() - time, querytime);
+    return true;
+  }
+  catch (...)
+  {
+    m_pDS->close();
+    CLog::Log(LOGERROR, "%s (%s) failed", __FUNCTION__, filter.where.c_str());
+  }
+
+  return false;
+}
+
 bool CMusicDatabase::GetSongsFullByWhere(const std::string &baseDir, const Filter &filter, CFileItemList &items, const SortDescription &sortDescription /* = SortDescription() */, bool artistData /* = false*/)
 {
   if (m_pDB == nullptr || m_pDS == nullptr)
@@ -7491,6 +7750,18 @@ void CMusicDatabase::UpdateTables(int version)
     // and filled as part of scanning anyway so simply force full rescan.
     MigrateSources();
   }
+  if (version < 73)
+  {
+    // add bBoxedSet to album table
+    m_pDS->exec("ALTER TABLE album ADD bBoxedSet INTEGER \n");
+    //  add iDiscTotal to album table
+    m_pDS->exec("ALTER TABLE album ADD iDiscTotal INTEGER \n");
+    // populate iDiscTotal from the data already in the song table
+    m_pDS->exec("UPDATE album SET iDisctotal = (SELECT COUNT(DISTINCT (iTrack >> 16)) "
+                "FROM song WHERE song.idAlbum = album.idAlbum GROUP BY idAlbum ) ");
+    // add strDiscSubtitles to song table
+    m_pDS->exec("ALTER TABLE song ADD strDiscSubtitle TEXT \n");
+  }
 
   // Set the verion of tag scanning required.
   // Not every schema change requires the tags to be rescanned, set to the highest schema version
@@ -7500,9 +7771,10 @@ void CMusicDatabase::UpdateTables(int version)
   // The original db version when the tags were scanned, and the minimal db version needed are
   // later used to determine if a forced rescan should be prompted
 
-  // The last schema change needing forced rescanning was 60.
-  // Mostly because of the new tags processed by v17 rather than a schema change.
-  SetMusicNeedsTagScan(60);
+  // The last schema change needing forced rescanning was 73.
+  // This is because Kodi can now read and process extra tags involved in the creation of box sets
+
+  SetMusicNeedsTagScan(73);
 
   // After all updates, store the original db version.
   // This indicates the version of tag processing that was used to populate db
@@ -7511,7 +7783,7 @@ void CMusicDatabase::UpdateTables(int version)
 
 int CMusicDatabase::GetSchemaVersion() const
 {
-  return 72;
+  return 73;
 }
 
 int CMusicDatabase::GetMusicNeedsTagScan()
@@ -8716,6 +8988,13 @@ bool CMusicDatabase::IsSongAlbumArtist(int idSong, int idArtist)
   return GetSingleValue(strSQL).empty();
 }
 
+bool CMusicDatabase::IsAlbumBoxset(int idAlbum)
+{
+  std::string strSQL = PrepareSQL("SELECT bBoxedSet FROM album WHERE idAlbum = %i", idAlbum);
+  int isBoxSet = strtol(GetSingleValue(strSQL).c_str(), nullptr, 10);
+  return (isBoxSet == 1 ? true : false);
+}
+
 int CMusicDatabase::GetAlbumByName(const std::string& strAlbum, const std::string& strArtist)
 {
   try
@@ -9016,6 +9295,38 @@ bool CMusicDatabase::GetGenresJSON(CFileItemList& items, bool bSources)
   return false;
 }
 
+std::string CMusicDatabase::GetAlbumDiscTitle(int idAlbum, int idDisc)
+{
+  // Get disc node title from ids allowing for "*all"
+  std::string disctitle;
+  std::string albumtitle;
+  if (idAlbum > 0)
+    albumtitle = GetAlbumById(idAlbum);
+  if (idDisc > 0)
+  {
+    disctitle = GetSingleValue("song", "strDiscSubtitle",
+                               PrepareSQL("idAlbum = %i AND iTrack >> 16 = %i", idAlbum, idDisc));
+    if (disctitle.empty())
+      disctitle = StringUtils::Format("%s %i", g_localizeStrings.Get(427), idDisc); // "Disc 1" etc.
+    if (albumtitle.empty())
+      albumtitle = disctitle;
+    else
+      albumtitle = albumtitle + " - " + disctitle;
+  }
+  return albumtitle;
+}
+
+int CMusicDatabase::GetBoxsetsCount()
+{
+  return strtol(GetSingleValue("album", "count(idAlbum)", "bBoxedSet = 1").c_str(), nullptr, 10);
+}
+
+int CMusicDatabase::GetAlbumDiscsCount(int idAlbum)
+{
+  std::string strSQL = PrepareSQL("SELECT iDiscTotal FROM album WHERE album.idAlbum = %i", idAlbum);
+  return strtol(GetSingleValue(strSQL).c_str(), nullptr, 10);
+}
+
 int CMusicDatabase::GetCompilationAlbumsCount()
 {
   return strtol(GetSingleValue("album", "count(idAlbum)", "bCompilation = 1").c_str(), NULL, 10);
@@ -9589,6 +9900,8 @@ bool CMusicDatabase::GetItems(const std::string &strBaseDir, const std::string &
     return GetArtistsNav(strBaseDir, items, !CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS), -1, -1, -1, filter, sortDescription);
   else if (StringUtils::EqualsNoCase(itemType, "albums"))
     return GetAlbumsByWhere(strBaseDir, filter, items, sortDescription);
+  else if (StringUtils::EqualsNoCase(itemType, "discs"))
+    return GetDiscsByWhere(strBaseDir, filter, items, sortDescription);
   else if (StringUtils::EqualsNoCase(itemType, "songs"))
     return GetSongsFullByWhere(strBaseDir, filter, items, sortDescription, true);
 
@@ -10501,6 +10814,11 @@ void CMusicDatabase::SetPropertiesFromAlbum(CFileItem& item, const CAlbum& album
     item.SetProperty("album_userrating", album.iUserrating);
   if (album.iVotes > 0)
     item.SetProperty("album_votes", album.iVotes);
+
+  if (album.bBoxedSet)
+    item.SetProperty("album_bBoxedSet", true); //! @todo Set listItem the same way as totalDiscs ??
+  item.SetProperty("album_totaldiscs", album.iTotalDiscs);
+  item.GetMusicInfoTag()->SetTotalDiscs(album.iTotalDiscs); // sets for ListItem.TotalDiscs
   item.SetProperty("album_releasetype", CAlbum::ReleaseTypeToString(album.releaseType));
 }
 
@@ -10876,6 +11194,7 @@ bool CMusicDatabase::GetFilter(CDbUrl &musicUrl, Filter &filter, SortDescription
   if(idRole > 0) strRoleSQL = PrepareSQL(" AND song_artist.idRole = %i ", idRole);
 
   int idArtist = -1, idGenre = -1, idAlbum = -1, idSong = -1;
+  int idDisc = -1;
   int idSource = -1;
   bool albumArtistsOnly = false;
   std::string artistname;
@@ -11075,6 +11394,11 @@ bool CMusicDatabase::GetFilter(CDbUrl &musicUrl, Filter &filter, SortDescription
     if (option != options.end())
       filter.AppendWhere(PrepareSQL("albumview.bCompilation = %i", option->second.asBoolean() ? 1 : 0));
 
+    option = options.find("boxset");
+    if (option != options.end())
+      filter.AppendWhere(
+          PrepareSQL("albumview.bBoxedSet = %i", option->second.asBoolean() ? 1 : 0));
+
     if (idSource > 0)
       filter.AppendWhere(PrepareSQL("EXISTS(SELECT 1 FROM album_source "
         "WHERE album_source.idAlbum = albumview.idAlbum AND album_source.idSource = %i)", idSource));
@@ -11162,6 +11486,88 @@ bool CMusicDatabase::GetFilter(CDbUrl &musicUrl, Filter &filter, SortDescription
         filter.AppendWhere(PrepareSQL("albumview.strReleaseType = '%s'", CAlbum::ReleaseTypeToString(CAlbum::Album).c_str()));
     }
   }
+  else if (type == "discs")
+  {
+    if (idAlbum > 0)
+      filter.AppendWhere(PrepareSQL("albumview.idAlbum = %i", idAlbum));
+    else
+    {
+      option = options.find("year");
+      if (option != options.end())
+        filter.AppendWhere(
+            PrepareSQL("albumview.iYear = %i", static_cast<int>(option->second.asInteger())));
+
+      option = options.find("compilation");
+      if (option != options.end())
+        filter.AppendWhere(
+            PrepareSQL("albumview.bCompilation = %i", option->second.asBoolean() ? 1 : 0));
+
+      option = options.find("boxset");
+      if (option != options.end())
+        filter.AppendWhere(
+            PrepareSQL("albumview.bBoxedSet = %i", option->second.asBoolean() ? 1 : 0));
+
+      if (idSource > 0)
+        filter.AppendWhere(PrepareSQL("EXISTS(SELECT 1 FROM album_source "
+          "WHERE album_source.idAlbum = albumview.idAlbum AND album_source.idSource = %i)", idSource));
+    }
+    option = options.find("discid");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("iDisc = %i", option->second.asInteger()));
+
+    option = options.find("disctitle");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("strDiscSubtitle = '%s'", option->second.asString().c_str()));
+
+    if (idGenre > 0)
+      filter.AppendWhere(PrepareSQL("EXISTS(SELECT 1 FROM song_genre WHERE song_genre.idSong = "
+                                    "song.idSong AND song_genre.idGenre = %i)",
+                                    idGenre));
+
+    std::string songArtistClause, albumArtistClause;
+    if (idArtist > 0)
+    {
+      songArtistClause = PrepareSQL("EXISTS (SELECT 1 FROM song_artist "
+        "WHERE song_artist.idSong = song.idSong AND song_artist.idArtist = %i %s)",
+        idArtist, strRoleSQL.c_str());
+      albumArtistClause = PrepareSQL("EXISTS (SELECT 1 FROM album_artist "
+        "WHERE album_artist.idAlbum = song.idAlbum AND album_artist.idArtist = %i)",
+        idArtist);
+    }
+    else if (!artistname.empty())
+    {  // Artist name is not unique, so could get songs from more than one.
+      songArtistClause = PrepareSQL(
+          "EXISTS (SELECT 1 FROM song_artist JOIN artist ON artist.idArtist = song_artist.idArtist "
+          "WHERE song_artist.idSong = song.idSong AND artist.strArtist like '%s' %s)",
+          artistname.c_str(), strRoleSQL.c_str());
+      albumArtistClause =
+          PrepareSQL("EXISTS (SELECT 1 FROM album_artist JOIN artist ON artist.idArtist = "
+                     "album_artist.idArtist "
+                     "WHERE album_artist.idAlbum = song.idAlbum AND artist.strArtist like '%s')",
+                     artistname.c_str());
+    }
+
+    // Process artist name or id option
+    if (!songArtistClause.empty())
+    {
+      if (idRole < 0) // Artist contributes to songs, any roles OR is album artist
+        filter.AppendWhere("(" + songArtistClause + " OR " + albumArtistClause + ")");
+      else if (idRole > 1)
+      {
+        if (albumArtistsOnly)  //Album artists only with role, check AND in album_artist for same song
+          filter.AppendWhere("(" + songArtistClause + " AND " + albumArtistClause + ")");
+        else // songs where artist contributes that role.
+          filter.AppendWhere(songArtistClause);
+      }
+      else
+      {
+        if (albumArtistsOnly) // Only look at album artists, not where artist features on songs
+          filter.AppendWhere(albumArtistClause);
+        else // Artist is song artist or album artist
+          filter.AppendWhere("(" + songArtistClause + " OR " + albumArtistClause + ")");
+      }
+    }
+  }
   else if (type == "songs" || type == "singles")
   {
     option = options.find("singles");
@@ -11178,12 +11584,30 @@ bool CMusicDatabase::GetFilter(CDbUrl &musicUrl, Filter &filter, SortDescription
     if (option != options.end())
       filter.AppendWhere(PrepareSQL("songview.bCompilation = %i", option->second.asBoolean() ? 1 : 0));
 
+    option = options.find("boxset");
+    if (option != options.end())
+      filter.AppendWhere(PrepareSQL("EXISTS(SELECT 1 FROM album WHERE album.idAlbum = "
+                                    "songview.idAlbum AND bBoxedSet = %i)",
+                                    option->second.asBoolean() ? 1 : 0));
+
+    option = options.find("discid");
+    if (option != options.end())
+      idDisc = static_cast<int>(option->second.asInteger());
+
+    option = options.find("disctitle");
+    if (option != options.end())
+      filter.AppendWhere(
+          PrepareSQL("songview.strDiscSubtitle = '%s'", option->second.asString().c_str()));
+
     if (idSong > 0)
       filter.AppendWhere(PrepareSQL("songview.idSong = %i", idSong));
 
     if (idAlbum > 0)
       filter.AppendWhere(PrepareSQL("songview.idAlbum = %i", idAlbum));
 
+    if (idDisc > 0)
+      filter.AppendWhere(PrepareSQL("songview.iTrack >> 16 = %i", idDisc));
+
     if (idGenre > 0)
       filter.AppendWhere(PrepareSQL("songview.idSong IN (SELECT song_genre.idSong FROM song_genre WHERE song_genre.idGenre = %i)", idGenre));
 
diff --git a/xbmc/music/MusicDatabase.h b/xbmc/music/MusicDatabase.h
index f7ddd2455542..b40bafb72978 100644
--- a/xbmc/music/MusicDatabase.h
+++ b/xbmc/music/MusicDatabase.h
@@ -128,6 +128,7 @@ class CMusicDatabase : public CDatabase
    \param iTrack [in] the track number and disc number of the song
    \param iDuration [in] the duration of the song
    \param iYear [in] the year of the song
+  \param strDiscSubtitle [in] subtitle of a disc
    \param iTimesPlayed [in] the number of times the song has been played
    \param iStartOffset [in] the start offset of the song (when using a single audio file with a .cue)
    \param iEndOffset [in] the end offset of the song (when using a single audio file with .cue)
@@ -148,6 +149,7 @@ class CMusicDatabase : public CDatabase
               const std::string &artistDisp, const std::string &artistSort,
               const std::vector<std::string>& genres,
               int iTrack, int iDuration, int iYear,
+              std::string& strDiscSubtitle,
               const int iTimesPlayed, int iStartOffset, int iEndOffset,
               const CDateTime& dtLastPlayed, float rating, int userrating, int votes,
               const ReplayGain& replayGain);
@@ -174,6 +176,7 @@ class CMusicDatabase : public CDatabase
    \param iTrack [in] the track number and disc number of the song
    \param iDuration [in] the duration of the song
    \param iYear [in] the year of the song
+   \param strDiscSubtitle [in] subtitle of a disc
    \param iTimesPlayed [in] the number of times the song has been played
    \param iStartOffset [in] the start offset of the song (when using a single audio file with a .cue)
    \param iEndOffset [in] the end offset of the song (when using a single audio file with .cue)
@@ -191,6 +194,7 @@ class CMusicDatabase : public CDatabase
                  const std::string &artistDisp, const std::string &artistSort,
                  const std::vector<std::string>& genres,
                  int iTrack, int iDuration, int iYear,
+                 const std::string& strDiscSubtitle,
                  int iTimesPlayed, int iStartOffset, int iEndOffset,
                  const CDateTime& dtLastPlayed, float rating, int userrating, int votes, const ReplayGain& replayGain);
 
@@ -227,6 +231,7 @@ class CMusicDatabase : public CDatabase
    \param strArtistSort the album artist name(s) sort string
    \param strGenre the album genre(s)
    \param year the year
+   \param bBoxedSet if the album is a boxset
    \param strRecordLabel the recording label
    \param strType album type (Musicbrainz release type e.g. "Broadcast, Soundtrack, live"),
    \param bCompilation if the album is a compilation
@@ -236,7 +241,7 @@ class CMusicDatabase : public CDatabase
   int  AddAlbum(const std::string& strAlbum, const std::string& strMusicBrainzAlbumID,
                 const std::string& strReleaseGroupMBID,
                 const std::string& strArtist, const std::string& strArtistSort,
-                const std::string& strGenre, int year,
+                const std::string& strGenre, int year, bool bBoxedSet,
                 const std::string& strRecordLabel, const std::string& strType,
                 bool bCompilation, CAlbum::ReleaseType releaseType);
 
@@ -256,7 +261,8 @@ class CMusicDatabase : public CDatabase
                    const std::string& strThemes, const std::string& strReview,
                    const std::string& strImage, const std::string& strLabel,
                    const std::string& strType,
-                   float fRating, int iUserrating, int iVotes, int iYear, bool bCompilation,
+                   float fRating, int iUserrating, int iVotes, int iYear, bool bBoxedSet,
+                   bool bCompilation,
                    CAlbum::ReleaseType releaseType,
                    bool bScrapedMBID);
   bool ClearAlbumLastScrapedTime(int idAlbum);
@@ -281,7 +287,9 @@ class CMusicDatabase : public CDatabase
   int  GetAlbumByName(const std::string& strAlbum, const std::vector<std::string>& artist);
   int  GetAlbumByMatch(const CAlbum &album);
   std::string GetAlbumById(int id);
+  std::string GetAlbumDiscTitle(int idAlbum, int idDisc);
   bool SetAlbumUserrating(const int idAlbum, int userrating);
+  int GetAlbumDiscsCount(int idAlbum);
 
   /////////////////////////////////////////////////
   // Artist CRUD
@@ -417,6 +425,12 @@ class CMusicDatabase : public CDatabase
   /////////////////////////////////////////////////
   int  GetCompilationAlbumsCount();
 
+  ////////////////////////////////////////////////
+  // Boxsets
+  ////////////////////////////////////////////////
+  bool IsAlbumBoxset(int idAlbum);
+  int GetBoxsetsCount();
+
   int GetSinglesCount();
 
   int GetArtistCountForRole(int role);
@@ -441,12 +455,28 @@ class CMusicDatabase : public CDatabase
   bool GetAlbumTypesNav(const std::string &strBaseDir, CFileItemList &items, const Filter &filter = Filter(), bool countOnly = false);
   bool GetMusicLabelsNav(const std::string &strBaseDir, CFileItemList &items, const Filter &filter = Filter(), bool countOnly = false);
   bool GetAlbumsNav(const std::string& strBaseDir, CFileItemList& items, int idGenre = -1, int idArtist = -1, const Filter &filter = Filter(), const SortDescription &sortDescription = SortDescription(), bool countOnly = false);
-  bool GetAlbumsByYear(const std::string &strBaseDir, CFileItemList& items, int year);
+  bool GetDiscsNav(const std::string& strBaseDir,
+                   CFileItemList& items,
+                   int idAlbum,
+                   const Filter& filter = Filter(),
+                   const SortDescription& sortDescription = SortDescription(),
+                   bool countOnly = false);
+  bool GetAlbumsByYear(const std::string& strBaseDir, CFileItemList& items, int year);
   bool GetSongsNav(const std::string& strBaseDir, CFileItemList& items, int idGenre, int idArtist,int idAlbum, const SortDescription &sortDescription = SortDescription());
   bool GetSongsByYear(const std::string& baseDir, CFileItemList& items, int year);
   bool GetSongsByWhere(const std::string &baseDir, const Filter &filter, CFileItemList& items, const SortDescription &sortDescription = SortDescription());
   bool GetSongsFullByWhere(const std::string &baseDir, const Filter &filter, CFileItemList& items, const SortDescription &sortDescription = SortDescription(), bool artistData = false);
   bool GetAlbumsByWhere(const std::string &baseDir, const Filter &filter, CFileItemList &items, const SortDescription &sortDescription = SortDescription(), bool countOnly = false);
+  bool GetDiscsByWhere(const std::string& baseDir,
+                       const Filter& filter,
+                       CFileItemList& items,
+                       const SortDescription& sortDescription = SortDescription(),
+                       bool countOnly = false);
+  bool GetDiscsByWhere(CMusicDbUrl& musicUrl,
+                       const Filter& filter,
+                       CFileItemList& items,
+                       const SortDescription& sortDescription = SortDescription(),
+                       bool countOnly = false);
   bool GetArtistsByWhere(const std::string& strBaseDir, const Filter &filter, CFileItemList& items, const SortDescription &sortDescription = SortDescription(), bool countOnly = false);
   int GetSongsCount(const Filter &filter = Filter());
   bool GetFilter(CDbUrl &musicUrl, Filter &filter, SortDescription &sorting) override;
@@ -731,6 +761,7 @@ void SetLibraryLastUpdated();
     song_iTrack,
     song_iDuration,
     song_iYear,
+    song_strDiscSubtitle,
     song_strFileName,
     song_strMusicBrainzTrackID,
     song_iTimesPlayed,
@@ -745,6 +776,7 @@ void SetLibraryLastUpdated();
     song_strAlbum,
     song_strPath,
     song_bCompilation,
+    song_bBoxedSet,
     song_strAlbumArtists,
     song_strAlbumArtistSort,
     song_strAlbumReleaseType,
@@ -766,6 +798,7 @@ void SetLibraryLastUpdated();
     album_strArtistSort,
     album_strGenres,
     album_iYear,
+    album_bBoxedSet,
     album_strMoods,
     album_strStyles,
     album_strThemes,
@@ -781,6 +814,7 @@ void SetLibraryLastUpdated();
     album_lastScraped,
     album_iTimesPlayed,
     album_strReleaseType,
+    album_iTotalDiscs,
     album_dtDateAdded,
     album_dtLastPlayed,
     album_enumCount // end of the enum, do not add past here
diff --git a/xbmc/music/MusicDbUrl.cpp b/xbmc/music/MusicDbUrl.cpp
index 2e5ec4576c53..3b4893bc183b 100644
--- a/xbmc/music/MusicDbUrl.cpp
+++ b/xbmc/music/MusicDbUrl.cpp
@@ -50,6 +50,10 @@ bool CMusicDbUrl::parse()
       m_type = "albums";
       break;
 
+    case NODE_TYPE_DISC:
+      m_type = "discs";
+      break;
+
     case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
     case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
     case NODE_TYPE_ALBUM_TOP100_SONGS:
@@ -76,6 +80,10 @@ bool CMusicDbUrl::parse()
       m_type = "albums";
       break;
 
+    case NODE_TYPE_DISC:
+      m_type = "discs";
+      break;
+
     case NODE_TYPE_SONG:
     case NODE_TYPE_ALBUM_RECENTLY_ADDED_SONGS:
     case NODE_TYPE_ALBUM_RECENTLY_PLAYED_SONGS:
diff --git a/xbmc/music/MusicThumbLoader.cpp b/xbmc/music/MusicThumbLoader.cpp
index 909b61449f3a..1f0ff867d949 100644
--- a/xbmc/music/MusicThumbLoader.cpp
+++ b/xbmc/music/MusicThumbLoader.cpp
@@ -268,8 +268,9 @@ bool CMusicThumbLoader::FillLibraryArt(CFileItem &item)
   if (artfound)
   {
     std::string fanartfallback;
-    bool bDiscSetThumbSet = false;
+    std::string artname;
     std::map<std::string, std::string> artmap;
+    std::map<std::string, std::string> discartmap;
     for (auto artitem : art)
     {
       /* Add art to artmap, naming according to media type.
@@ -277,7 +278,6 @@ bool CMusicThumbLoader::FillLibraryArt(CFileItem &item)
       albums have "thumb", "artist.thumb", "artist.fanart",... "artist1.thumb", "artist1.fanart" etc.,
       songs have "thumb", "album.thumb", "artist.thumb", "albumartist.thumb", "albumartist1.thumb" etc.
       */
-      std::string artname;
       if (tag.GetType() == artitem.mediaType)
         artname = artitem.artType;
       else if (artitem.prefix.empty())
@@ -289,24 +289,29 @@ bool CMusicThumbLoader::FillLibraryArt(CFileItem &item)
         artname = artitem.prefix + "." + artitem.artType;
       }
 
+      // Pull out album art for this specific disc e.g. "thumb2", skip art for other discs
+      if (artitem.mediaType == MediaTypeAlbum && tag.GetDiscNumber() > 0)
+      {
+        // Find any trailing digits
+        size_t startnum = artitem.artType.find_last_not_of("0123456789");
+        std::string digits = artitem.artType.substr(startnum + 1);
+        int num = atoi(digits.c_str());
+        if (num > 0 && startnum < artitem.artType.size())
+        {
+          if (num == tag.GetDiscNumber())
+            discartmap.insert(std::make_pair(artitem.artType.substr(0, startnum + 1), artitem.url));
+          continue;
+        }
+      }
+
       artmap.insert(std::make_pair(artname, artitem.url));
 
       // Add fallback art for "thumb" and "fanart" art types only
       // Set album thumb as the fallback used when song thumb is missing
-      // or use extra album thumb when part of disc set
-      if (tag.GetType() == MediaTypeSong && artitem.mediaType == MediaTypeAlbum)
+      if (tag.GetType() == MediaTypeSong && artitem.mediaType == MediaTypeAlbum &&
+          artitem.artType == "thumb")
       {
-        if (artitem.artType == "thumb" && !bDiscSetThumbSet)
-          item.SetArtFallback(artitem.artType, artname);
-        else if (StringUtils::StartsWith(artitem.artType, "thumb"))
-        {
-          int number = atoi(artitem.artType.substr(5).c_str());
-          if (number > 0 && tag.GetDiscNumber() == number)
-          {
-            item.SetArtFallback("thumb", artname);
-            bDiscSetThumbSet = true;
-          }
-        }
+        item.SetArtFallback(artitem.artType, artname);
       }
 
       // For albums and songs set fallback fanart from the artist.
@@ -319,6 +324,47 @@ bool CMusicThumbLoader::FillLibraryArt(CFileItem &item)
     if (!fanartfallback.empty())
       item.SetArtFallback("fanart", fanartfallback);
 
+    // Process specific disc art when we have some
+    for (auto discart : discartmap)
+    {
+      std::map<std::string, std::string>::iterator it;
+      if (tag.GetType() == MediaTypeAlbum)
+      {
+        // Insert or replace album art with specific disc art
+        it = artmap.find(discart.first);
+        if (it != artmap.end())
+          it->second = discart.second;
+        else
+          artmap.insert(discart);
+      }
+      else if (tag.GetType() == MediaTypeSong)
+      {
+        // Use disc thumb rather than album as fallback for song thumb
+        // (Fallback approach is used to fill missing thumbs).
+        if (discart.first == "thumb")
+        {
+          it = artmap.find("album.thumb");
+          if (it != artmap.end())
+            // Replace "album.thumb" already set as fallback
+            it->second = discart.second;
+          else
+          {
+            // Insert thumb for album and set as fallback
+            artmap.insert(std::make_pair("album.thumb", discart.second));
+            item.SetArtFallback("thumb", "album.thumb");
+          }
+        }
+        else
+        {
+          // Apply disc art as song art when not have that type (fallback does not apply).
+          // Art of other types could been set via JSON, or in future read from metadata
+          it = artmap.find(discart.first);
+          if (it == artmap.end())
+            artmap.insert(discart);
+        }
+      }
+    }
+
     item.AppendArt(artmap);
   }
 
diff --git a/xbmc/music/Song.cpp b/xbmc/music/Song.cpp
index c2d6146f8616..edbb6068c804 100644
--- a/xbmc/music/Song.cpp
+++ b/xbmc/music/Song.cpp
@@ -57,6 +57,7 @@ CSong::CSong(CFileItem& item)
   userrating = tag.GetUserrating();
   votes = tag.GetVotes();
   iYear = stTime.wYear;
+  strDiscSubtitle = tag.GetDiscSubtitle();
   iTrack = tag.GetTrackAndDiscNumber();
   iDuration = tag.GetDuration();
   strRecordLabel = tag.GetRecordLabel();
@@ -254,6 +255,7 @@ void CSong::Clear()
   iTrack = 0;
   iDuration = 0;
   iYear = 0;
+  strDiscSubtitle.clear();
   iStartOffset = 0;
   iEndOffset = 0;
   idSong = -1;
@@ -349,3 +351,8 @@ bool CSong::ArtMatches(const CSong &right) const
   return (right.strThumb == strThumb &&
           embeddedArt.Matches(right.embeddedArt));
 }
+
+const std::string CSong::GetDiscSubtitle() const
+{
+  return strDiscSubtitle;
+}
diff --git a/xbmc/music/Song.h b/xbmc/music/Song.h
index 8dde36f1420f..d59814c2b4cb 100644
--- a/xbmc/music/Song.h
+++ b/xbmc/music/Song.h
@@ -100,6 +100,11 @@ class CSong final : public ISerializable
   */
   const std::string GetAlbumArtistSort() const { return m_strAlbumArtistSort; }
 
+  /*! \brief Get disc subtitle string where one exists
+  \return disc subtitle as a single string
+  */
+  const std::string GetDiscSubtitle() const;
+
   /*! \brief Get composer sort name string
   \return composer sort name as a single string
   */
@@ -173,6 +178,7 @@ class CSong final : public ISerializable
   int iTrack;
   int iDuration;
   int iYear;
+  std::string strDiscSubtitle;
   int iTimesPlayed;
   CDateTime lastPlayed;
   CDateTime dateAdded;
diff --git a/xbmc/music/infoscanner/MusicInfoScanner.cpp b/xbmc/music/infoscanner/MusicInfoScanner.cpp
index 254a611fbbd8..30bb7daf28b6 100644
--- a/xbmc/music/infoscanner/MusicInfoScanner.cpp
+++ b/xbmc/music/infoscanner/MusicInfoScanner.cpp
@@ -667,6 +667,7 @@ void CMusicInfoScanner::FileItemsToAlbums(CFileItemList& items, VECALBUMS& album
     bool tracksOverlap = false;
     bool hasAlbumArtist = false;
     bool isCompilation = true;
+    std::string old_DiscSubtitle;
 
     std::map<std::string, std::vector<CSong *> > artists;
     for (VECSONGS::iterator song = songs.begin(); song != songs.end(); ++song)
@@ -678,6 +679,9 @@ void CMusicInfoScanner::FileItemsToAlbums(CFileItemList& items, VECALBUMS& album
       if (!song->bCompilation)
         isCompilation = false;
 
+      if (song->strDiscSubtitle != old_DiscSubtitle)
+        old_DiscSubtitle = song->strDiscSubtitle;
+
       // get primary artist
       std::string primary;
       if (!song->GetAlbumArtist().empty())
diff --git a/xbmc/music/infoscanner/MusicInfoScanner.h b/xbmc/music/infoscanner/MusicInfoScanner.h
index ec6dff3f850b..b8f9afe3c8e7 100644
--- a/xbmc/music/infoscanner/MusicInfoScanner.h
+++ b/xbmc/music/infoscanner/MusicInfoScanner.h
@@ -78,6 +78,7 @@ class CMusicInfoScanner : public IRunnable, public CInfoScanner
   virtual void Process();
   bool DoScan(const std::string& strDirectory) override;
 
+
   /*! \brief Find art for albums
    Based on the albums in the folder, finds whether we have unique album art
    and assigns to the album if we do.
diff --git a/xbmc/music/tags/MusicInfoTag.cpp b/xbmc/music/tags/MusicInfoTag.cpp
index e03c1fe13e0a..7ca4af4799d6 100644
--- a/xbmc/music/tags/MusicInfoTag.cpp
+++ b/xbmc/music/tags/MusicInfoTag.cpp
@@ -36,7 +36,10 @@ bool CMusicInfoTag::operator !=(const CMusicInfoTag& tag) const
   if (m_albumArtist != tag.m_albumArtist) return true;
   if (m_strAlbum != tag.m_strAlbum) return true;
   if (m_iDuration != tag.m_iDuration) return true;
-  if (m_iTrack != tag.m_iTrack) return true;
+  if (m_strDiscSubtitle != tag.m_strDiscSubtitle)
+    return true;
+  if (m_iTrack != tag.m_iTrack)
+    return true;
   if (m_albumReleaseType != tag.m_albumReleaseType) return true;
   return false;
 }
@@ -101,6 +104,11 @@ const std::string& CMusicInfoTag::GetAlbum() const
   return m_strAlbum;
 }
 
+const std::string& CMusicInfoTag::GetDiscSubtitle() const
+{
+  return m_strDiscSubtitle;
+}
+
 int CMusicInfoTag::GetAlbumId() const
 {
   return m_iAlbumId;
@@ -221,6 +229,16 @@ bool CMusicInfoTag::GetCompilation() const
   return m_bCompilation;
 }
 
+bool CMusicInfoTag::GetBoxset() const
+{
+  return m_bBoxset;
+}
+
+int CMusicInfoTag::GetTotalDiscs() const
+{
+  return m_iDiscTotal;
+}
+
 const EmbeddedArtInfo &CMusicInfoTag::GetCoverArtInfo() const
 {
   return m_coverArt;
@@ -368,6 +386,16 @@ void CMusicInfoTag::SetDiscNumber(int iDiscNumber)
   m_iTrack = (m_iTrack & 0xffff) | (iDiscNumber << 16);
 }
 
+void CMusicInfoTag::SetDiscSubtitle(const std::string& strDiscSubtitle)
+{
+  m_strDiscSubtitle = strDiscSubtitle;
+}
+
+void CMusicInfoTag::SetTotalDiscs(int iDiscTotal)
+{
+  m_iDiscTotal = iDiscTotal;
+}
+
 void CMusicInfoTag::SetTrackAndDiscNumber(int iTrackAndDisc)
 {
   m_iTrack = iTrackAndDisc;
@@ -461,6 +489,11 @@ void CMusicInfoTag::SetCompilation(bool compilation)
   m_bCompilation = compilation;
 }
 
+void CMusicInfoTag::SetBoxset(bool boxset)
+{
+  m_bBoxset = boxset;
+}
+
 void CMusicInfoTag::SetLoaded(bool bOnOff)
 {
   m_bLoaded = bOnOff;
@@ -614,12 +647,14 @@ void CMusicInfoTag::SetAlbum(const CAlbum& album)
   SetCompilation(album.bCompilation);
   SYSTEMTIME stTime;
   stTime.wYear = album.iYear;
+  SetBoxset(album.bBoxedSet);
   SetReleaseDate(stTime);
   SetAlbumReleaseType(album.releaseType);
   SetDateAdded(album.dateAdded);
   SetPlayCount(album.iTimesPlayed);
   SetDatabaseId(album.idAlbum, MediaTypeAlbum);
   SetLastPlayed(album.lastPlayed);
+  SetTotalDiscs(album.iTotalDiscs);
 
   SetLoaded();
 }
@@ -661,6 +696,7 @@ void CMusicInfoTag::SetSong(const CSong& song)
   stTime.wYear = song.iYear;
   SetReleaseDate(stTime);
   SetTrackAndDiscNumber(song.iTrack);
+  SetDiscSubtitle(song.strDiscSubtitle);
   SetDuration(song.iDuration);
   SetMood(song.strMood);
   SetCompilation(song.bCompilation);
@@ -762,6 +798,9 @@ void CMusicInfoTag::ToSortable(SortItem& sortable, Field field) const
   case FieldGenre:       sortable[FieldGenre] = m_genre; break;
   case FieldTime:        sortable[FieldTime] = m_iDuration; break;
   case FieldTrackNumber: sortable[FieldTrackNumber] = m_iTrack; break;
+  case FieldTotalDiscs:
+    sortable[FieldTotalDiscs] = m_iDiscTotal;
+    break;
   case FieldYear:        sortable[FieldYear] = m_dwReleaseDate.wYear; break;
   case FieldComment:     sortable[FieldComment] = m_strComment; break;
   case FieldMoods:       sortable[FieldMoods] = m_strMood; break;
@@ -799,6 +838,9 @@ void CMusicInfoTag::Archive(CArchive& ar)
     ar << m_strMusicBrainzAlbumID;
     ar << m_strMusicBrainzReleaseGroupID;
     ar << m_musicBrainzAlbumArtistID;
+    ar << m_strDiscSubtitle;
+    ar << m_bBoxset;
+    ar << m_iDiscTotal;
     ar << m_strMusicBrainzReleaseType;
     ar << m_lastPlayed;
     ar << m_dateAdded;
@@ -847,6 +889,9 @@ void CMusicInfoTag::Archive(CArchive& ar)
     ar >> m_strMusicBrainzAlbumID;
     ar >> m_strMusicBrainzReleaseGroupID;
     ar >> m_musicBrainzAlbumArtistID;
+    ar >> m_strDiscSubtitle;
+    ar >> m_bBoxset;
+    ar >> m_iDiscTotal;
     ar >> m_strMusicBrainzReleaseType;
     ar >> m_lastPlayed;
     ar >> m_dateAdded;
@@ -910,6 +955,8 @@ void CMusicInfoTag::Clear()
   m_lastPlayed.Reset();
   m_dateAdded.Reset();
   m_bCompilation = false;
+  m_bBoxset = false;
+  m_strDiscSubtitle.clear();
   m_strComment.clear();
   m_strMood.clear();
   m_strRecordLabel.clear();
@@ -926,6 +973,7 @@ void CMusicInfoTag::Clear()
   m_Rating = 0;
   m_Userrating = 0;
   m_Votes = 0;
+  m_iDiscTotal = 0;
 }
 
 void CMusicInfoTag::AppendArtist(const std::string &artist)
diff --git a/xbmc/music/tags/MusicInfoTag.h b/xbmc/music/tags/MusicInfoTag.h
index 8bd5053c7cd7..e4e74a9f7453 100644
--- a/xbmc/music/tags/MusicInfoTag.h
+++ b/xbmc/music/tags/MusicInfoTag.h
@@ -46,10 +46,12 @@ class CMusicInfoTag final : public IArchivable, public ISerializable, public ISo
   int GetTrackNumber() const;
   int GetDiscNumber() const;
   int GetTrackAndDiscNumber() const;
+  int GetTotalDiscs() const;
   int GetDuration() const;  // may be set even if Loaded() returns false
   int GetYear() const;
   int GetDatabaseId() const;
   const std::string &GetType() const;
+  const std::string& GetDiscSubtitle() const;
 
   void GetReleaseDate(SYSTEMTIME& dateTime) const;
   std::string GetYearString() const;
@@ -69,6 +71,7 @@ class CMusicInfoTag final : public IArchivable, public ISerializable, public ISo
   const CDateTime& GetLastPlayed() const;
   const CDateTime& GetDateAdded() const;
   bool  GetCompilation() const;
+  bool GetBoxset() const;
   float GetRating() const;
   int GetUserrating() const;
   int GetVotes() const;
@@ -127,10 +130,13 @@ class CMusicInfoTag final : public IArchivable, public ISerializable, public ISo
   void SetDateAdded(const std::string& strDateAdded);
   void SetDateAdded(const CDateTime& strDateAdded);
   void SetCompilation(bool compilation);
+  void SetBoxset(bool boxset);
   void SetCoverArtInfo(size_t size, const std::string &mimeType);
   void SetReplayGain(const ReplayGain& aGain);
   void SetAlbumReleaseType(CAlbum::ReleaseType releaseType);
   void SetType(const MediaType mediaType);
+  void SetDiscSubtitle(const std::string& strDiscSubtitle);
+  void SetTotalDiscs(int iDiscTotal);
 
   /*! \brief Append a unique artist to the artist list
    Checks if we have this artist already added, and if not adds it to the songs artist list.
@@ -198,6 +204,7 @@ class CMusicInfoTag final : public IArchivable, public ISerializable, public ISo
   std::string m_strRecordLabel;
   std::string m_strLyrics;
   std::string m_cuesheet;
+  std::string m_strDiscSubtitle;
   CDateTime m_lastPlayed;
   CDateTime m_dateAdded;
   bool m_bCompilation;
@@ -212,6 +219,8 @@ class CMusicInfoTag final : public IArchivable, public ISerializable, public ISo
   int m_listeners;
   int m_iTimesPlayed;
   int m_iAlbumId;
+  int m_iDiscTotal;
+  bool m_bBoxset;
   SYSTEMTIME m_dwReleaseDate;
   CAlbum::ReleaseType m_albumReleaseType;
 
diff --git a/xbmc/music/tags/MusicInfoTagLoaderFFmpeg.cpp b/xbmc/music/tags/MusicInfoTagLoaderFFmpeg.cpp
index c61338df2957..1175918157a2 100644
--- a/xbmc/music/tags/MusicInfoTagLoaderFFmpeg.cpp
+++ b/xbmc/music/tags/MusicInfoTagLoaderFFmpeg.cpp
@@ -135,6 +135,8 @@ bool CMusicInfoTagLoaderFFmpeg::Load(const std::string& strFileName, CMusicInfoT
                                      strcasecmp(avtag->key, "TSOP") == 0) {}
                             else if (strcasecmp(avtag->key, "TSO2") == 0) {}  // Album artist sort
                             else if (strcasecmp(avtag->key, "TSOC") == 0) {}  // composer sort
+                            else if (strcasecmp(avtag->key, "TSST") == 0)
+                              tag.SetDiscSubtitle(avtag->value);
                           };
 
   AVDictionaryEntry* avtag=nullptr;
diff --git a/xbmc/music/tags/TagLoaderTagLib.cpp b/xbmc/music/tags/TagLoaderTagLib.cpp
index 51e4be441733..a01dc4b16914 100644
--- a/xbmc/music/tags/TagLoaderTagLib.cpp
+++ b/xbmc/music/tags/TagLoaderTagLib.cpp
@@ -183,6 +183,8 @@ bool CTagLoaderTagLib::ParseTag(ASF::Tag *asf, EmbeddedArt *art, CMusicInfoTag&
     {} // Known unsupported, suppress warnings
     else if (it->first == "WM/Year")
       tag.SetYear(atoi(it->second.front().toString().toCString(true)));
+    else if (it->first == "WM/SetSubTitle")
+      tag.SetDiscSubtitle(it->second.front().toString().to8Bit(true));
     else if (it->first == "MusicBrainz/Artist Id")
       tag.SetMusicBrainzArtistID(SplitMBID(GetASFStringList(it->second)));
     else if (it->first == "MusicBrainz/Album Id")
@@ -308,6 +310,8 @@ bool CTagLoaderTagLib::ParseTag(ID3v2::Tag *id3v2, EmbeddedArt *art, MUSIC_INFO:
     else if (it->first == "TDTG")   {} // Tagging time
     else if (it->first == "TLAN")   {} // Languages
     else if (it->first == "TMOO")   tag.SetMood(it->second.front()->toString().to8Bit(true));
+    else if (it->first == "TSST")
+      tag.SetDiscSubtitle(it->second.front()->toString().to8Bit(true));
     else if (it->first == "USLT")
       // Loop through any lyrics frames. Could there be multiple frames, how to choose?
       for (ID3v2::FrameList::ConstIterator lt = it->second.begin(); lt != it->second.end(); ++lt)
@@ -500,6 +504,8 @@ bool CTagLoaderTagLib::ParseTag(APE::Tag *ape, EmbeddedArt *art, CMusicInfoTag&
       tag.SetDiscNumber(it->second.toString().toInt());
     else if (it->first == "YEAR")
       tag.SetYear(it->second.toString().toInt());
+    else if (it->first == "DISCSUBTITLE")
+      tag.SetDiscSubtitle(it->second.toString().to8Bit(true));
     else if (it->first == "GENRE")
       SetGenre(tag, StringListToVectorString(it->second.toStringList()));
     else if (it->first == "MOOD")
@@ -644,6 +650,8 @@ bool CTagLoaderTagLib::ParseTag(Ogg::XiphComment *xiph, EmbeddedArt *art, CMusic
       tag.SetComment(it->second.front().to8Bit(true));
     else if (it->first == "CUESHEET")
       tag.SetCueSheet(it->second.front().to8Bit(true));
+    else if (it->first == "DISCSUBTITLE")
+      tag.SetDiscSubtitle(it->second.front().to8Bit(true));
     else if (it->first == "ENCODEDBY")
     {} // Known but unsupported, suppress warnings
     else if (it->first == "COMPOSER")
@@ -844,6 +852,8 @@ bool CTagLoaderTagLib::ParseTag(MP4::Tag *mp4, EmbeddedArt *art, CMusicInfoTag&
     //No MP4 standard tag for musician credits
     else if (it->first == "----:com.apple.iTunes:LABEL")
       tag.SetRecordLabel(it->second.toStringList().front().to8Bit(true));
+    else if (it->first == "----:com.apple.iTunes:DISCSUBTITLE")
+      tag.SetDiscSubtitle(it->second.toStringList().front().to8Bit(true));
     else if (it->first == "cpil")
       tag.SetCompilation(it->second.toBool());
     else if (it->first == "trkn")
@@ -1062,6 +1072,14 @@ void CTagLoaderTagLib::AddArtistRole(CMusicInfoTag &tag, const std::string& strR
     tag.AddArtistRole(strRole, values);
 }
 
+void CTagLoaderTagLib::SetDiscSubtitle(CMusicInfoTag& tag, const std::vector<std::string>& values)
+{
+  if (values.size() == 1)
+    tag.SetDiscSubtitle(values[0]);
+  else
+    tag.SetDiscSubtitle(std::string());
+}
+
 void CTagLoaderTagLib::AddArtistRole(CMusicInfoTag &tag, const std::vector<std::string> &values)
 {
   // Values contains role, name pairs (as in ID3 standard for TIPL or TMCL tags)
diff --git a/xbmc/music/tags/TagLoaderTagLib.h b/xbmc/music/tags/TagLoaderTagLib.h
index febe8850e3e4..a4b82addf087 100644
--- a/xbmc/music/tags/TagLoaderTagLib.h
+++ b/xbmc/music/tags/TagLoaderTagLib.h
@@ -39,7 +39,9 @@ class CTagLoaderTagLib : public MUSIC_INFO::IMusicInfoTagLoader
   static void SetAlbumArtistSort(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
   static void SetAlbumArtistHints(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
   static void SetComposerSort(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
-  static void SetGenre(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
+  static void SetDiscSubtitle(MUSIC_INFO::CMusicInfoTag& tag,
+                              const std::vector<std::string>& values);
+  static void SetGenre(MUSIC_INFO::CMusicInfoTag& tag, const std::vector<std::string>& values);
   static void SetReleaseType(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
   static void AddArtistRole(MUSIC_INFO::CMusicInfoTag &tag, const std::string& strRole, const std::vector<std::string> &values);
   static void AddArtistRole(MUSIC_INFO::CMusicInfoTag &tag, const std::vector<std::string> &values);
diff --git a/xbmc/music/windows/GUIWindowMusicNav.cpp b/xbmc/music/windows/GUIWindowMusicNav.cpp
index dafcab56dc23..6fcaa9d4646e 100644
--- a/xbmc/music/windows/GUIWindowMusicNav.cpp
+++ b/xbmc/music/windows/GUIWindowMusicNav.cpp
@@ -371,7 +371,58 @@ bool CGUIWindowMusicNav::GetDirectory(const std::string &strDirectory, CFileItem
   if (strDirectory.empty())
     AddSearchFolder();
 
-  bool bResult = CGUIWindowMusicBase::GetDirectory(strDirectory, items);
+  bool bResult = false;
+  if (URIUtils::IsMusicDb(strDirectory))
+  {
+    XFILE::CMusicDatabaseDirectory dir;
+    CQueryParams params;
+    MUSICDATABASEDIRECTORY::NODE_TYPE type;
+    MUSICDATABASEDIRECTORY::NODE_TYPE childtype;
+    dir.GetDirectoryNodeInfo(strDirectory, type, childtype, params);
+
+    //Control navigation from albums to discs or directly to songs
+    if (childtype == NODE_TYPE_DISC)
+    {
+      bool bFlatten = false;
+
+      if (params.GetAlbumId() < 0)
+        bFlatten = true; // Showing *all albums next always songs
+      else
+      {
+        // Option to show discs for ordinary albums (not just boxed sets)
+        bFlatten = !CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(
+            CSettings::SETTING_MUSICLIBRARY_SHOWDISCS);
+        CMusicDatabase musicdatabase;
+        if (musicdatabase.Open())
+        {
+          if (bFlatten) // Check for boxed set
+            bFlatten = !musicdatabase.IsAlbumBoxset(params.GetAlbumId());
+          if (!bFlatten)
+          { // Check we will get more than 1 disc when filter applied
+            int iDiscTotal = -1;
+            if (musicdatabase.GetDiscsByWhere(strDirectory, CDatabase::Filter(), items,
+                                              SortDescription(), true))
+              iDiscTotal = items.GetProperty("total").asInteger();
+            bFlatten = iDiscTotal <= 1;
+          }
+        }
+        musicdatabase.Close();
+      }
+      if (bFlatten)
+      { // Skip discs level and show songs
+        CMusicDbUrl musicUrl;
+        if (!musicUrl.FromString(strDirectory))
+          return false;
+
+        musicUrl.AppendPath("-2/"); // Flattened so adjust list label etc.
+        bResult = CGUIWindowMusicBase::GetDirectory(musicUrl.ToString(), items);
+      }
+    }
+  }
+
+  if (!bResult)
+    bResult = CGUIWindowMusicBase::GetDirectory(strDirectory, items);
+
   if (bResult)
   {
     if (items.IsPlayList())
@@ -412,7 +463,8 @@ bool CGUIWindowMusicNav::GetDirectory(const std::string &strDirectory, CFileItem
     if (node == NODE_TYPE_ALBUM ||
         node == NODE_TYPE_ALBUM_RECENTLY_ADDED ||
         node == NODE_TYPE_ALBUM_RECENTLY_PLAYED ||
-        node == NODE_TYPE_ALBUM_TOP100)
+        node == NODE_TYPE_ALBUM_TOP100 ||
+        node == NODE_TYPE_DISC)  // ! @todo: own content type "discs"??
       items.SetContent("albums");
     else if (node == NODE_TYPE_ARTIST)
       items.SetContent("artists");
@@ -914,6 +966,8 @@ std::string CGUIWindowMusicNav::GetStartFolder(const std::string &dir)
     return "musicdb://years/";
   else if (lower == "files")
     return "sources://music/";
+  else if (lower == "boxsets")
+    return "musicdb://boxsets/";
 
   return CGUIWindowMusicBase::GetStartFolder(dir);
 }
diff --git a/xbmc/music/windows/MusicFileItemListModifier.cpp b/xbmc/music/windows/MusicFileItemListModifier.cpp
index dc03a8f6a008..c78de793fd87 100644
--- a/xbmc/music/windows/MusicFileItemListModifier.cpp
+++ b/xbmc/music/windows/MusicFileItemListModifier.cpp
@@ -89,6 +89,13 @@ void CMusicFileItemListModifier::AddQueuingFolder(CFileItemList& items)
     pItem->SetPath(musicUrl.ToString());
     break;
 
+  //  Disc node
+  case NODE_TYPE_DISC:
+    pItem.reset(new CFileItem(g_localizeStrings.Get(38075)));  // "All Discs"
+    musicUrl.AppendPath("-1/");
+    pItem->SetPath(musicUrl.ToString());
+    break;
+
   default:
     break;
   }
diff --git a/xbmc/playlists/SmartPlayList.cpp b/xbmc/playlists/SmartPlayList.cpp
index 0ab9592ba2f3..05e4cd8bee0e 100644
--- a/xbmc/playlists/SmartPlayList.cpp
+++ b/xbmc/playlists/SmartPlayList.cpp
@@ -113,7 +113,11 @@ static const translateField fields[] = {
   { "artisttype",        FieldArtistType,              CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 564 },
   { "gender",            FieldGender,                  CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 39025 },
   { "disambiguation",    FieldDisambiguation,          CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 false, 39026 },
-  { "source",            FieldSource,                  CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 true,  39030 }
+  { "source",            FieldSource,                  CDatabaseQueryRule::TEXT_FIELD,     NULL,                                 true,  39030 },
+  { "disctitle", FieldDiscTitle, CDatabaseQueryRule::TEXT_FIELD, NULL, false, 38076 },
+  { "isboxset", FieldIsBoxset, CDatabaseQueryRule::BOOLEAN_FIELD, NULL, false, 38074 },
+  { "totaldiscs", FieldTotalDiscs, CDatabaseQueryRule::NUMERIC_FIELD,
+    StringValidation::IsPositiveInteger,  false, 38077 },
 };
 
 typedef struct
@@ -291,6 +295,7 @@ std::vector<Field> CSmartPlaylistRule::GetFields(const std::string &type)
     fields.push_back(FieldGenre);
     fields.push_back(FieldSource);
     fields.push_back(FieldAlbum);
+    fields.push_back(FieldDiscTitle);
     fields.push_back(FieldArtist);
     fields.push_back(FieldAlbumArtist);
     fields.push_back(FieldTitle);
@@ -311,6 +316,9 @@ std::vector<Field> CSmartPlaylistRule::GetFields(const std::string &type)
     fields.push_back(FieldGenre);
     fields.push_back(FieldSource);
     fields.push_back(FieldAlbum);
+    fields.push_back(FieldDiscTitle);
+    fields.push_back(FieldTotalDiscs);
+    fields.push_back(FieldIsBoxset);
     fields.push_back(FieldArtist);        // any artist
     fields.push_back(FieldAlbumArtist);  // album artist
     fields.push_back(FieldYear);
@@ -507,6 +515,7 @@ std::vector<SortBy> CSmartPlaylistRule::GetOrders(const std::string &type)
   {
     orders.push_back(SortByGenre);
     orders.push_back(SortByAlbum);
+    orders.push_back(SortByTotalDiscs);
     orders.push_back(SortByArtist);        // any artist
     orders.push_back(SortByYear);
     //orders.push_back(SortByThemes);
@@ -739,6 +748,8 @@ std::string CSmartPlaylistRule::GetBooleanQuery(const std::string &negate, const
   {
     if (m_field == FieldCompilation)
       return negate + GetField(m_field, strType);
+    if (m_field == FieldIsBoxset)
+      return negate + "albumview.bBoxedSet = 1";
   }
   return "";
 }
@@ -815,6 +826,10 @@ std::string CSmartPlaylistRule::FormatWhereClause(const std::string &negate, con
       query = GetField(m_field, strType) + " is NULL or " + GetField(m_field, strType) + parameter;
     else if (m_field == FieldSource)
       query = negate + " EXISTS (SELECT 1 FROM album_source, source WHERE album_source.idAlbum = " + GetField(FieldId, strType) + " AND album_source.idSource = source.idSource AND source.strName" + parameter + ")";
+    else if (m_field == FieldDiscTitle)
+      query = negate +
+              " EXISTS (SELECT 1 FROM song WHERE song.idAlbum = " + GetField(FieldId, strType) +
+              " AND song.strDiscSubtitle" + parameter + ")";
   }
   else if (strType == "artists")
   {
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 47db97b623ad..ca2f50e1f54f 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -228,6 +228,7 @@ const std::string CSettings::SETTING_PVRPARENTAL_DURATION = "pvrparental.duratio
 const std::string CSettings::SETTING_PVRCLIENT_MENUHOOK = "pvrclient.menuhook";
 const std::string CSettings::SETTING_PVRTIMERS_HIDEDISABLEDTIMERS = "pvrtimers.hidedisabledtimers";
 const std::string CSettings::SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS = "musiclibrary.showcompilationartists";
+const std::string CSettings::SETTING_MUSICLIBRARY_SHOWDISCS = "musiclibrary.showdiscs";
 const std::string CSettings::SETTING_MUSICLIBRARY_USEARTISTSORTNAME = "musiclibrary.useartistsortname";
 const std::string CSettings::SETTING_MUSICLIBRARY_DOWNLOADINFO = "musiclibrary.downloadinfo";
 const std::string CSettings::SETTING_MUSICLIBRARY_ARTISTSFOLDER = "musiclibrary.artistsfolder";
diff --git a/xbmc/settings/Settings.h b/xbmc/settings/Settings.h
index c57a104f4858..289d53706743 100644
--- a/xbmc/settings/Settings.h
+++ b/xbmc/settings/Settings.h
@@ -194,6 +194,7 @@ class CSettings : public CSettingsBase, public CSettingCreator, public CSettingC
   static const std::string SETTING_PVRCLIENT_MENUHOOK;
   static const std::string SETTING_PVRTIMERS_HIDEDISABLEDTIMERS;
   static const std::string SETTING_MUSICLIBRARY_SHOWCOMPILATIONARTISTS;
+  static const std::string SETTING_MUSICLIBRARY_SHOWDISCS;
   static const std::string SETTING_MUSICLIBRARY_USEARTISTSORTNAME;
   static const std::string SETTING_MUSICLIBRARY_DOWNLOADINFO;
   static const std::string SETTING_MUSICLIBRARY_ARTISTSFOLDER;
diff --git a/xbmc/utils/DatabaseUtils.cpp b/xbmc/utils/DatabaseUtils.cpp
index 5b8fa970cf75..678b541d6bce 100644
--- a/xbmc/utils/DatabaseUtils.cpp
+++ b/xbmc/utils/DatabaseUtils.cpp
@@ -69,6 +69,8 @@ std::string DatabaseUtils::GetField(Field field, const MediaType &mediaType, Dat
     else if (field == FieldDateAdded) return "albumview.dateAdded";
     else if (field == FieldPlaycount) return "albumview.iTimesPlayed";
     else if (field == FieldLastPlayed) return "albumview.lastPlayed";
+    else if (field == FieldTotalDiscs)
+      return "albumview.iDiscTotal";
   }
   else if (mediaType == MediaTypeSong)
   {
@@ -92,6 +94,8 @@ std::string DatabaseUtils::GetField(Field field, const MediaType &mediaType, Dat
     else if (field == FieldArtist || field == FieldAlbumArtist) return "songview.strArtists";
     else if (field == FieldGenre) return "songview.strGenre";
     else if (field == FieldDateAdded) return "songview.dateAdded";
+    else if (field == FieldDiscTitle)
+      return "songview.strDiscSubtitle";
   }
   else if (mediaType == MediaTypeArtist)
   {
@@ -492,6 +496,8 @@ int DatabaseUtils::GetField(Field field, const MediaType &mediaType, bool asInde
     else if (field == FieldPlaycount) return CMusicDatabase::album_iTimesPlayed;
     else if (field == FieldLastPlayed) return CMusicDatabase::album_dtLastPlayed;
     else if (field == FieldDateAdded) return CMusicDatabase::album_dtDateAdded;
+    else if (field == FieldTotalDiscs)
+      return CMusicDatabase::album_iTotalDiscs;
   }
   else if (mediaType == MediaTypeSong)
   {
diff --git a/xbmc/utils/DatabaseUtils.h b/xbmc/utils/DatabaseUtils.h
index 21f5a19cbf2a..cad56a04f802 100644
--- a/xbmc/utils/DatabaseUtils.h
+++ b/xbmc/utils/DatabaseUtils.h
@@ -59,6 +59,9 @@ typedef enum {
   FieldId,
   FieldGenre,
   FieldAlbum,
+  FieldDiscTitle,
+  FieldIsBoxset,
+  FieldTotalDiscs,
   FieldArtist,
   FieldArtistSort,
   FieldAlbumArtist,
diff --git a/xbmc/utils/LabelFormatter.cpp b/xbmc/utils/LabelFormatter.cpp
index 299a982a2cac..65cb0948581d 100644
--- a/xbmc/utils/LabelFormatter.cpp
+++ b/xbmc/utils/LabelFormatter.cpp
@@ -91,6 +91,7 @@ using namespace MUSIC_INFO;
  *  %Y - Year
  *  %Z - tvshow title
  *  %a - Date Added
+ *  %b - Total number of discs
  *  %c - Relevance - Used for actors' appearances
  *  %d - Date and Time
  *  %p - Last Played
@@ -98,7 +99,7 @@ using namespace MUSIC_INFO;
  *  *t - Date Taken (suitable for Pictures)
  */
 
-#define MASK_CHARS "NSATBGYFLDIJRCKMEPHZOQUVXWacdiprstuv"
+#define MASK_CHARS "NSATBGYFLDIJRCKMEPHZOQUVXWabcdiprstuv"
 
 CLabelFormatter::CLabelFormatter(const std::string &mask, const std::string &mask2)
 {
@@ -316,6 +317,10 @@ std::string CLabelFormatter::GetMaskContent(const CMaskString &mask, const CFile
     if (music && music->GetDateAdded().IsValid())
       value = music->GetDateAdded().GetAsLocalizedDate();
     break;
+  case 'b': // Total number of discs
+    if (music)
+      value = StringUtils::Format("%i", music->GetTotalDiscs());
+    break;
   case 'd': // date and time
     if (item->m_dateTime.IsValid())
       value = item->m_dateTime.GetAsLocalizedDateTime();
@@ -451,6 +456,9 @@ void CLabelFormatter::FillMusicMaskContent(const char mask, const std::string &v
   case 'r': // userrating
     tag->SetUserrating(value[0]);
     break;
+  case 'b': // total discs
+    tag->SetTotalDiscs(atol(value.c_str()));
+    break;
   }
 }
 
diff --git a/xbmc/utils/SortUtils.cpp b/xbmc/utils/SortUtils.cpp
index 6c74f0b8462c..96fced883908 100644
--- a/xbmc/utils/SortUtils.cpp
+++ b/xbmc/utils/SortUtils.cpp
@@ -179,6 +179,11 @@ std::string ByTrackNumber(SortAttribute attributes, const SortItem &values)
   return StringUtils::Format("%i", (int)values.at(FieldTrackNumber).asInteger());
 }
 
+std::string ByTotalDiscs(SortAttribute attributes, const SortItem& values)
+{
+  return StringUtils::Format("%d %s", static_cast<int>(values.at(FieldTotalDiscs).asInteger()),
+                             ByLabel(attributes, values));
+}
 std::string ByTime(SortAttribute attributes, const SortItem &values)
 {
   std::string label;
@@ -612,6 +617,7 @@ std::map<SortBy, SortUtils::SortPreparator> fillPreparators()
   preparators[SortByInstallDate]              = ByInstallDate;
   preparators[SortByLastUpdated]              = ByLastUpdated;
   preparators[SortByLastUsed]                 = ByLastUsed;
+  preparators[SortByTotalDiscs] = ByTotalDiscs;
 
   return preparators;
 }
@@ -698,6 +704,7 @@ std::map<SortBy, Fields> fillSortingFields()
   sortingFields[SortByInstallDate].insert(FieldInstallDate);
   sortingFields[SortByLastUpdated].insert(FieldLastUpdated);
   sortingFields[SortByLastUsed].insert(FieldLastUsed);
+  sortingFields[SortByTotalDiscs].insert(FieldTotalDiscs);
   sortingFields.insert(std::pair<SortBy, Fields>(SortByRandom, Fields()));
 
   return sortingFields;
@@ -915,6 +922,8 @@ const sort_map table[] = {
   { SortByChannel,                  SORT_METHOD_CLIENT_CHANNEL_ORDER,         SortAttributeNone,          19315 },
   { SortByDateTaken,                SORT_METHOD_DATE_TAKEN,                   SortAttributeIgnoreFolders, 577 },
   { SortByNone,                     SORT_METHOD_NONE,                         SortAttributeNone,          16018 },
+  { SortByTotalDiscs, SORT_METHOD_TOTAL_DISCS, SortAttributeNone, 38077 },
+
   // the following have no corresponding SORT_METHOD_*
   { SortByAlbumType,                SORT_METHOD_NONE,                         SortAttributeNone,          564 },
   { SortByVotes,                    SORT_METHOD_NONE,                         SortAttributeNone,          205 },
@@ -1063,6 +1072,7 @@ const std::map<std::string, SortBy> sortMethods = {
   { "installdate",      SortByInstallDate },
   { "lastupdated",      SortByLastUpdated },
   { "lastused",         SortByLastUsed },
+  { "totaldiscs",       SortByTotalDiscs },
 };
 
 SortBy SortUtils::SortMethodFromString(const std::string& sortMethod)
diff --git a/xbmc/utils/SortUtils.h b/xbmc/utils/SortUtils.h
index 2f2c0ab3d2ea..3b0ba6660af9 100644
--- a/xbmc/utils/SortUtils.h
+++ b/xbmc/utils/SortUtils.h
@@ -155,6 +155,8 @@ typedef enum {
   SortByLastUsed,
   /// __53__ : Sort by client channel order       <em>(String: <b><c>ClientChannelOrder</c></b>)</em>
   SortByClientChannelOrder,
+  /// __54__ : Sort by total number of discs      <em>(String: <b><c>totaldiscs</c></b>)</em>
+  SortByTotalDiscs,
 } SortBy;
 ///@}
 
