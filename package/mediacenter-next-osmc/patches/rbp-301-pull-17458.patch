From 05fe0c8370f453368eaaca4ded458797206d38c1 Mon Sep 17 00:00:00 2001
From: Zhouyang Jia <jiazhouyang@nudt.edu.cn>
Date: Tue, 10 Mar 2020 13:59:59 -0400
Subject: [PATCH] Add error handling code for some external APIs

Check the return value of socket and add a log message when socket fails.

Add error handling for fopen, or the program will crash at "while (fgets(buf, sizeof (buf), fp))" since fp is null.

Change NULL to nullptr in this file for consistency.
---
 xbmc/network/Socket.cpp                      | 29 ++++++++++++++------
 xbmc/platform/linux/storage/UDevProvider.cpp | 20 ++++++++------
 2 files changed, 31 insertions(+), 18 deletions(-)

diff --git a/xbmc/network/Socket.cpp b/xbmc/network/Socket.cpp
index 4dd9fb91d4f3..ef0894ca934e 100644
--- a/xbmc/network/Socket.cpp
+++ b/xbmc/network/Socket.cpp
@@ -52,20 +52,31 @@ bool CPosixUDPSocket::Bind(bool localOnly, int port, int range)
         m_addr = CAddress("::");
 
         SOCKET testSocket = socket(AF_INET6, SOCK_DGRAM, IPPROTO_UDP);
-        setsockopt(testSocket, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(&zero));
-        // Try to bind a socket to validate ipv6 status
-        for (m_iPort = port; m_iPort <= port + range; ++m_iPort)
+        if (testSocket != INVALID_SOCKET)
         {
-          m_addr.saddr.saddr6.sin6_port = htons(m_iPort);
-          if (bind(testSocket, (struct sockaddr*)&m_addr.saddr, m_addr.size) >= 0)
+          setsockopt(testSocket, IPPROTO_IPV6, IPV6_V6ONLY, &zero, sizeof(&zero));
+          // Try to bind a socket to validate ipv6 status
+          for (m_iPort = port; m_iPort <= port + range; ++m_iPort)
           {
-            m_ipv6Socket = true;
-            break;
+            m_addr.saddr.saddr6.sin6_port = htons(m_iPort);
+            if (bind(testSocket, reinterpret_cast<struct sockaddr*>(&m_addr.saddr), m_addr.size) >= 0)
+            {
+              m_ipv6Socket = true;
+              break;
+            }
           }
+          if (!m_ipv6Socket)
+          {
+            CLog::Log(LOGWARNING, "UDP: Unable to bind to advertised ipv6, fallback to ipv4");
+            close(m_iSock);
+            m_iSock = INVALID_SOCKET;
+          }
+
+          closesocket(testSocket);
         }
-        if (!m_ipv6Socket)
+        else
         {
-          CLog::Log(LOGWARNING, "UDP: Unable to bind to advertised ipv6, fallback to ipv4");
+          CLog::Log(LOGWARNING, "UDP: Could not create testSocket");
           close(m_iSock);
           m_iSock = INVALID_SOCKET;
         }
diff --git a/xbmc/platform/linux/storage/UDevProvider.cpp b/xbmc/platform/linux/storage/UDevProvider.cpp
index d71e2d923111..1b6a68fc3497 100644
--- a/xbmc/platform/linux/storage/UDevProvider.cpp
+++ b/xbmc/platform/linux/storage/UDevProvider.cpp
@@ -21,20 +21,22 @@ static const char *get_mountpoint(const char *devnode)
 {
   static char buf[4096];
   const char *delim = " ";
-  const char *mountpoint = NULL;
+  const char *mountpoint = nullptr;
   FILE *fp = fopen("/proc/mounts", "r");
+  if (!fp)
+    return nullptr;
 
   while (fgets(buf, sizeof (buf), fp))
   {
     const char *node = strtok(buf, delim);
     if (strcmp(node, devnode) == 0)
     {
-      mountpoint = strtok(NULL, delim);
+      mountpoint = strtok(nullptr, delim);
       break;
     }
   }
 
-  if (mountpoint != NULL)
+  if (mountpoint)
   {
     // If mount point contain characters like space, it is converted to
     // "\040". This situation should be handled.
@@ -60,8 +62,8 @@ static const char *get_mountpoint(const char *devnode)
 
 CUDevProvider::CUDevProvider()
 {
-  m_udev    = NULL;
-  m_udevMon = NULL;
+  m_udev = nullptr;
+  m_udevMon = nullptr;
 }
 
 void CUDevProvider::Initialize()
@@ -80,7 +82,7 @@ void CUDevProvider::Initialize()
   udev_monitor_filter_add_match_subsystem_devtype(m_udevMon, "block", "partition");
   udev_monitor_enable_receiving(m_udevMon);
 
-  PumpDriveChangeEvents(NULL);
+  PumpDriveChangeEvents(nullptr);
 }
 
 void CUDevProvider::Stop()
@@ -93,7 +95,7 @@ void CUDevProvider::GetDisks(VECSOURCES& disks, bool removable)
 {
   // enumerate existing block devices
   struct udev_enumerate *u_enum = udev_enumerate_new(m_udev);
-  if (u_enum == NULL)
+  if (!u_enum)
   {
     fprintf(stderr, "Error: udev_enumerate_new(udev)\n");
     return;
@@ -112,7 +114,7 @@ void CUDevProvider::GetDisks(VECSOURCES& disks, bool removable)
     const char *name = udev_list_entry_get_name(u_list_ent);
     struct udev *context = udev_enumerate_get_udev(u_enum);
     struct udev_device *device = udev_device_new_from_syspath(context, name);
-    if (device == NULL)
+    if (!device)
       continue;
 
     // filter out devices that are not mounted
@@ -217,7 +219,7 @@ bool CUDevProvider::PumpDriveChangeEvents(IStorageEventsCallback *callback)
 
   // non-blocking, check the file descriptor for received data
   struct timeval tv = {0};
-  int count = select(udev_monitor_get_fd(m_udevMon) + 1, &readfds, NULL, NULL, &tv);
+  int count = select(udev_monitor_get_fd(m_udevMon) + 1, &readfds, nullptr, nullptr, &tv);
   if (count < 0)
     return false;
 
