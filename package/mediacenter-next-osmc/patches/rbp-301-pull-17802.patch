From 93b25d01871ae5c93fb6a0186335258f19ed9b0a Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Mon, 4 May 2020 19:45:17 +0200
Subject: [PATCH 1/4] [PVR] Speed up persisting EPG container to database.
 First, only queue all INSERT queries and after that do one commit.

---
 xbmc/pvr/epg/Epg.cpp          |  8 ++++----
 xbmc/pvr/epg/Epg.h            |  3 ++-
 xbmc/pvr/epg/EpgContainer.cpp | 38 ++++++++++++++++++++++++-----------
 3 files changed, 32 insertions(+), 17 deletions(-)

diff --git a/xbmc/pvr/epg/Epg.cpp b/xbmc/pvr/epg/Epg.cpp
index cacdde3d0afa..3743fb4a321a 100644
--- a/xbmc/pvr/epg/Epg.cpp
+++ b/xbmc/pvr/epg/Epg.cpp
@@ -291,7 +291,7 @@ std::vector<std::shared_ptr<CPVREpgInfoTag>> CPVREpg::GetTags() const
   return m_tags.GetAllTags();
 }
 
-bool CPVREpg::Persist(const std::shared_ptr<CPVREpgDatabase>& database)
+bool CPVREpg::Persist(const std::shared_ptr<CPVREpgDatabase>& database, bool bQueueWrite)
 {
   if (!database)
   {
@@ -315,10 +315,10 @@ bool CPVREpg::Persist(const std::shared_ptr<CPVREpgDatabase>& database)
     }
 
     if (m_tags.NeedsSave())
-      m_tags.Persist(false);
+      m_tags.Persist(!bQueueWrite);
 
     if (m_bUpdateLastScanTime)
-      database->PersistLastEpgScanTime(m_iEpgID, m_lastScanTime, true);
+      database->PersistLastEpgScanTime(m_iEpgID, m_lastScanTime, bQueueWrite);
 
     if (bEpgIdChanged)
       m_tags.SetEpgID(m_iEpgID);
@@ -327,7 +327,7 @@ bool CPVREpg::Persist(const std::shared_ptr<CPVREpgDatabase>& database)
     m_bUpdateLastScanTime = false;
   }
 
-  bool bRet = database->CommitInsertQueries();
+  bool bRet = bQueueWrite || database->CommitInsertQueries();
 
   database->Unlock();
 
diff --git a/xbmc/pvr/epg/Epg.h b/xbmc/pvr/epg/Epg.h
index a02ca92e9a07..e8371de7b5d4 100644
--- a/xbmc/pvr/epg/Epg.h
+++ b/xbmc/pvr/epg/Epg.h
@@ -205,9 +205,10 @@ namespace PVR
     /*!
      * @brief Persist this table in the given database
      * @param database The database.
+     * @param bQueueWrite Don't execute the query immediately but queue it if true.
      * @return True if the table was persisted, false otherwise.
      */
-    bool Persist(const std::shared_ptr<CPVREpgDatabase>& database);
+    bool Persist(const std::shared_ptr<CPVREpgDatabase>& database, bool bQueueWrite);
 
     /*!
      * @brief Delete this table from the given database
diff --git a/xbmc/pvr/epg/EpgContainer.cpp b/xbmc/pvr/epg/EpgContainer.cpp
index fbd921356f78..f7c6d2d5c138 100644
--- a/xbmc/pvr/epg/EpgContainer.cpp
+++ b/xbmc/pvr/epg/EpgContainer.cpp
@@ -269,27 +269,41 @@ void CPVREpgContainer::LoadFromDB()
 
 bool CPVREpgContainer::PersistAll(unsigned int iMaxTimeslice) const
 {
-  bool bReturn = true;
+  const std::shared_ptr<CPVREpgDatabase> database = GetEpgDatabase();
+  if (!database)
+  {
+    CLog::LogF(LOGERROR, "No EPG database");
+    return false;
+  }
 
-  m_critSection.lock();
-  const auto epgs = m_epgIdToEpgMap;
-  m_critSection.unlock();
+  std::vector<std::shared_ptr<CPVREpg>> changedEpgs;
+  {
+    CSingleLock lock(m_critSection);
+    for (const auto& epg : m_epgIdToEpgMap)
+    {
+      if (epg.second && epg.second->NeedsSave())
+        changedEpgs.emplace_back(epg.second);
+    }
+  }
 
-  const std::shared_ptr<CPVREpgDatabase> database = GetEpgDatabase();
-  XbmcThreads::EndTime processTimeslice(iMaxTimeslice);
+  bool bReturn = true;
 
-  for (const auto& epg : epgs)
+  if (!changedEpgs.empty())
   {
-    if (epg.second && epg.second->NeedsSave())
+    XbmcThreads::EndTime processTimeslice(iMaxTimeslice);
+    for (const auto& epg : changedEpgs)
     {
       CLog::Log(LOGDEBUG, "EPG Container: Persisting events for channel '%s'...",
-                epg.second->GetChannelData()->ChannelName().c_str());
+                epg->GetChannelData()->ChannelName().c_str());
+
+      bReturn &= epg->Persist(database, true);
 
-      bReturn &= epg.second->Persist(database);
+      if (processTimeslice.IsTimePast())
+        break;
     }
 
-    if (processTimeslice.IsTimePast())
-      break;
+    if (bReturn)
+      database->CommitInsertQueries();
   }
 
   return bReturn;

From cf83149d12841276816b2a8253b33832073a428f Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 11:14:54 +0200
Subject: [PATCH 2/4] [PVR] CPVREpgDatabase: Remove some default parameters.

---
 xbmc/pvr/epg/EpgDatabase.cpp | 6 ++++--
 xbmc/pvr/epg/EpgDatabase.h   | 4 ++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/xbmc/pvr/epg/EpgDatabase.cpp b/xbmc/pvr/epg/EpgDatabase.cpp
index a833e71701df..0328db330ce8 100644
--- a/xbmc/pvr/epg/EpgDatabase.cpp
+++ b/xbmc/pvr/epg/EpgDatabase.cpp
@@ -958,7 +958,9 @@ bool CPVREpgDatabase::GetLastEpgScanTime(int iEpgId, CDateTime* lastScan)
   return bReturn;
 }
 
-bool CPVREpgDatabase::PersistLastEpgScanTime(int iEpgId, const CDateTime& lastScanTime, bool bQueueWrite /* = false */)
+bool CPVREpgDatabase::PersistLastEpgScanTime(int iEpgId,
+                                             const CDateTime& lastScanTime,
+                                             bool bQueueWrite)
 {
   CSingleLock lock(m_critSection);
   std::string strQuery = PrepareSQL("REPLACE INTO lastepgscan(idEpg, sLastScan) VALUES (%u, '%s');",
@@ -967,7 +969,7 @@ bool CPVREpgDatabase::PersistLastEpgScanTime(int iEpgId, const CDateTime& lastSc
   return bQueueWrite ? QueueInsertQuery(strQuery) : ExecuteQuery(strQuery);
 }
 
-int CPVREpgDatabase::Persist(const CPVREpg& epg, bool bQueueWrite /* = false */)
+int CPVREpgDatabase::Persist(const CPVREpg& epg, bool bQueueWrite)
 {
   int iReturn(-1);
   std::string strQuery;
diff --git a/xbmc/pvr/epg/EpgDatabase.h b/xbmc/pvr/epg/EpgDatabase.h
index e4e91c194c26..253c4d14ce59 100644
--- a/xbmc/pvr/epg/EpgDatabase.h
+++ b/xbmc/pvr/epg/EpgDatabase.h
@@ -224,7 +224,7 @@ namespace PVR
      * @param bQueueWrite Don't execute the query immediately but queue it if true.
      * @return True if it was updated successfully, false otherwise.
      */
-    bool PersistLastEpgScanTime(int iEpgId, const CDateTime& lastScanTime, bool bQueueWrite = false);
+    bool PersistLastEpgScanTime(int iEpgId, const CDateTime& lastScanTime, bool bQueueWrite);
 
     /*!
      * @brief Persist an EPG table. It's entries are not persisted.
@@ -232,7 +232,7 @@ namespace PVR
      * @param bQueueWrite Don't execute the query immediately but queue it if true.
      * @return The database ID of this entry or 0 if bSingleUpdate is false and the query was queued.
      */
-    int Persist(const CPVREpg& epg, bool bQueueWrite = false);
+    int Persist(const CPVREpg& epg, bool bQueueWrite);
 
     /*!
      * @brief Erase all EPG tags with the given epg ID and an end time less than the given time.

From 383bcdbc67f58f8defbc7960c3fefebb4779eae8 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 11:59:28 +0200
Subject: [PATCH 3/4] [PVR] CPVREpgDatabase: Replace c-style casts with
 c++-style casts.

---
 xbmc/pvr/epg/EpgDatabase.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/pvr/epg/EpgDatabase.cpp b/xbmc/pvr/epg/EpgDatabase.cpp
index 0328db330ce8..9bf5fdec2df4 100644
--- a/xbmc/pvr/epg/EpgDatabase.cpp
+++ b/xbmc/pvr/epg/EpgDatabase.cpp
@@ -990,7 +990,7 @@ int CPVREpgDatabase::Persist(const CPVREpg& epg, bool bQueueWrite)
   else
   {
     if (ExecuteQuery(strQuery))
-      iReturn = epg.EpgID() <= 0 ? (int) m_pDS->lastinsertid() : epg.EpgID();
+      iReturn = epg.EpgID() <= 0 ? static_cast<int>(m_pDS->lastinsertid()) : epg.EpgID();
   }
 
   return iReturn;
@@ -1080,7 +1080,7 @@ int CPVREpgDatabase::Persist(const CPVREpgInfoTag& tag, bool bSingleUpdate /* =
   if (bSingleUpdate)
   {
     if (ExecuteQuery(strQuery))
-      iReturn = (int) m_pDS->lastinsertid();
+      iReturn = static_cast<int>(m_pDS->lastinsertid());
   }
   else
   {

From fcf1e5f670b7d464be2b41e21120cb51ef9913aa Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 12:43:42 +0200
Subject: [PATCH 4/4] [PVR] Fix deadlock in CPVREpg::Persist. Never lock epg
 instance after epgdb instance.

---
 xbmc/pvr/epg/Epg.cpp         | 53 +++++++++++++++++++++++-------------
 xbmc/pvr/epg/EpgDatabase.cpp | 15 ++++++----
 xbmc/pvr/epg/EpgDatabase.h   | 10 ++++---
 3 files changed, 49 insertions(+), 29 deletions(-)

diff --git a/xbmc/pvr/epg/Epg.cpp b/xbmc/pvr/epg/Epg.cpp
index 3743fb4a321a..7f87d69829a9 100644
--- a/xbmc/pvr/epg/Epg.cpp
+++ b/xbmc/pvr/epg/Epg.cpp
@@ -299,38 +299,53 @@ bool CPVREpg::Persist(const std::shared_ptr<CPVREpgDatabase>& database, bool bQu
     return false;
   }
 
-  database->Lock();
+  bool bLastScanTimeNeedsSave = false;
+  bool bTagsNeedSave = false;
+  bool bEpgNeedsSave = false;
+  int iEpgID = -1;
+  std::string name;
+  std::string scraper;
+  CDateTime lastScanTime;
 
   {
     CSingleLock lock(m_critSection);
-    bool bEpgIdChanged = false;
-    if (m_iEpgID <= 0 || m_bChanged)
-    {
-      int iId = database->Persist(*this, m_iEpgID > 0);
-      if (iId > 0 && m_iEpgID != iId)
-      {
-        m_iEpgID = iId;
-        bEpgIdChanged = true;
-      }
-    }
 
-    if (m_tags.NeedsSave())
-      m_tags.Persist(!bQueueWrite);
-
-    if (m_bUpdateLastScanTime)
-      database->PersistLastEpgScanTime(m_iEpgID, m_lastScanTime, bQueueWrite);
-
-    if (bEpgIdChanged)
-      m_tags.SetEpgID(m_iEpgID);
+    bLastScanTimeNeedsSave = m_bUpdateLastScanTime;
+    bTagsNeedSave = m_tags.NeedsSave();
+    bEpgNeedsSave = m_iEpgID <= 0 || m_bChanged;
+    iEpgID = m_iEpgID;
+    name = m_strName;
+    scraper = m_strScraperName;
+    lastScanTime = m_lastScanTime;
 
     m_bChanged = false;
     m_bUpdateLastScanTime = false;
   }
 
+  database->Lock();
+
+  int iNewEpgID = iEpgID;
+  if (bEpgNeedsSave)
+    iNewEpgID = database->Persist(iEpgID, name, scraper, iEpgID > 0);
+
+  if (bLastScanTimeNeedsSave)
+    database->PersistLastEpgScanTime(iNewEpgID, lastScanTime, bQueueWrite);
+
   bool bRet = bQueueWrite || database->CommitInsertQueries();
 
   database->Unlock();
 
+  if (iNewEpgID > 0 && iNewEpgID != iEpgID)
+  {
+    CSingleLock lock(m_critSection);
+
+    m_iEpgID = iNewEpgID;
+    m_tags.SetEpgID(iNewEpgID);
+  }
+
+  if (bTagsNeedSave)
+    m_tags.Persist(!bQueueWrite);
+
   return bRet;
 }
 
diff --git a/xbmc/pvr/epg/EpgDatabase.cpp b/xbmc/pvr/epg/EpgDatabase.cpp
index 9bf5fdec2df4..24a842835a1f 100644
--- a/xbmc/pvr/epg/EpgDatabase.cpp
+++ b/xbmc/pvr/epg/EpgDatabase.cpp
@@ -969,28 +969,31 @@ bool CPVREpgDatabase::PersistLastEpgScanTime(int iEpgId,
   return bQueueWrite ? QueueInsertQuery(strQuery) : ExecuteQuery(strQuery);
 }
 
-int CPVREpgDatabase::Persist(const CPVREpg& epg, bool bQueueWrite)
+int CPVREpgDatabase::Persist(int iEpgId,
+                             const std::string& name,
+                             const std::string& scraper,
+                             bool bQueueWrite)
 {
   int iReturn(-1);
   std::string strQuery;
 
   CSingleLock lock(m_critSection);
-  if (epg.EpgID() > 0)
+  if (iEpgId > 0)
     strQuery = PrepareSQL("REPLACE INTO epg (idEpg, sName, sScraperName) "
-        "VALUES (%u, '%s', '%s');", epg.EpgID(), epg.Name().c_str(), epg.ScraperName().c_str());
+        "VALUES (%u, '%s', '%s');", iEpgId, name.c_str(), scraper.c_str());
   else
     strQuery = PrepareSQL("INSERT INTO epg (sName, sScraperName) "
-        "VALUES ('%s', '%s');", epg.Name().c_str(), epg.ScraperName().c_str());
+        "VALUES ('%s', '%s');", name.c_str(), scraper.c_str());
 
   if (bQueueWrite)
   {
     if (QueueInsertQuery(strQuery))
-      iReturn = epg.EpgID() <= 0 ? 0 : epg.EpgID();
+      iReturn = iEpgId <= 0 ? 0 : iEpgId;
   }
   else
   {
     if (ExecuteQuery(strQuery))
-      iReturn = epg.EpgID() <= 0 ? static_cast<int>(m_pDS->lastinsertid()) : epg.EpgID();
+      iReturn = iEpgId <= 0 ? static_cast<int>(m_pDS->lastinsertid()) : iEpgId;
   }
 
   return iReturn;
diff --git a/xbmc/pvr/epg/EpgDatabase.h b/xbmc/pvr/epg/EpgDatabase.h
index 253c4d14ce59..078a718a9787 100644
--- a/xbmc/pvr/epg/EpgDatabase.h
+++ b/xbmc/pvr/epg/EpgDatabase.h
@@ -228,15 +228,17 @@ namespace PVR
 
     /*!
      * @brief Persist an EPG table. It's entries are not persisted.
-     * @param epg The table to persist.
+     * @param iEpgId The ID of the EPG.
+     * @param name The name of the EPG.
+     * @param scraper The name of the scraper of the EPG.
      * @param bQueueWrite Don't execute the query immediately but queue it if true.
      * @return The database ID of this entry or 0 if bSingleUpdate is false and the query was queued.
      */
-    int Persist(const CPVREpg& epg, bool bQueueWrite);
+    int Persist(int iEpgId, const std::string& name, const std::string& scraper, bool bQueueWrite);
 
     /*!
      * @brief Erase all EPG tags with the given epg ID and an end time less than the given time.
-     * @param iEpgID The ID of the EPG.
+     * @param iEpgId The ID of the EPG.
      * @param maxEndTime The maximum allowed end time.
      * @return True if the entries were removed successfully, false otherwise.
      */
@@ -244,7 +246,7 @@ namespace PVR
 
     /*!
      * @brief Erase all EPG tags with the given epg ID.
-     * @param iEpgID The ID of the EPG.
+     * @param iEpgId The ID of the EPG.
      * @return True if the entries were removed successfully, false otherwise.
      */
     bool DeleteEpgTags(int iEpgId);
