From 068318187dcf42642bfd066ff54a407b475c727b Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Thu, 20 Sep 2018 14:54:15 +0200
Subject: [PATCH] [PVR] Fetch EPG tags for timers if timer start not in
 configured EPG window.

---
 xbmc/addons/PVRClient.h                       | 24 +++++---
 .../include/kodi/versions.h                   |  2 +-
 .../include/kodi/xbmc_pvr_types.h             |  1 +
 xbmc/pvr/epg/Epg.cpp                          | 55 ++++++++++++++++---
 xbmc/pvr/epg/Epg.h                            |  9 ++-
 xbmc/pvr/timers/PVRTimerInfoTag.cpp           | 48 ++++++++--------
 xbmc/pvr/windows/GUIWindowPVRGuide.cpp        | 12 +++-
 7 files changed, 104 insertions(+), 47 deletions(-)

diff --git a/xbmc/addons/PVRClient.h b/xbmc/addons/PVRClient.h
index ced1d95858c0..611ddaae2acd 100644
--- a/xbmc/addons/PVRClient.h
+++ b/xbmc/addons/PVRClient.h
@@ -56,37 +56,37 @@ namespace PVR
 
     /*!
      * @brief Check whether this add-on supports TV channels.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsTV() const { return m_addonCapabilities && m_addonCapabilities->bSupportsTV; }
 
     /*!
      * @brief Check whether this add-on supports radio channels.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsRadio() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRadio; }
 
     /*!
      * @brief Check whether this add-on supports channel groups.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsChannelGroups() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelGroups; }
 
     /*!
      * @brief Check whether this add-on supports scanning for new channels on the backend.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsChannelScan() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelScan; }
 
     /*!
      * @brief Check whether this add-on supports the following functions: DeleteChannel, RenameChannel, DialogChannelSettings and DialogAddChannel.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsChannelSettings() const { return m_addonCapabilities && m_addonCapabilities->bSupportsChannelSettings; }
 
     /*!
      * @brief Check whether this add-on supports descramble information for playing channels.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsDescrambleInfo() const { return m_addonCapabilities && m_addonCapabilities->bSupportsDescrambleInfo; }
 
@@ -98,10 +98,16 @@ namespace PVR
 
     /*!
      * @brief Check whether this add-on provides EPG information.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsEPG() const { return m_addonCapabilities && m_addonCapabilities->bSupportsEPG; }
 
+    /*!
+     * @brief Check whether this add-on supports asynchronous transfer of epg events.
+     * @return True if supported, false otherwise.
+     */
+    bool SupportsAsyncEPGTransfer() const { return m_addonCapabilities && m_addonCapabilities->bSupportsAsyncEPGTransfer; }
+
     /////////////////////////////////////////////////////////////////////////////////
     //
     // Timers
@@ -110,7 +116,7 @@ namespace PVR
 
     /*!
      * @brief Check whether this add-on supports the creation and editing of timers.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsTimers() const { return m_addonCapabilities && m_addonCapabilities->bSupportsTimers; }
 
@@ -122,7 +128,7 @@ namespace PVR
 
     /*!
      * @brief Check whether this add-on supports recordings.
-     * @return True if recordings are supported, false otherwise.
+     * @return True if supported, false otherwise.
      */
     bool SupportsRecordings() const { return m_addonCapabilities && m_addonCapabilities->bSupportsRecordings; }
 
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index 227717c87a4c..3b57b183124c 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -98,7 +98,7 @@
 #define ADDON_INSTANCE_VERSION_PERIPHERAL_DEPENDS     "addon-instance/Peripheral.h" \
                                                       "addon-instance/PeripheralUtils.h"
 
-#define ADDON_INSTANCE_VERSION_PVR                    "5.10.1"
+#define ADDON_INSTANCE_VERSION_PVR                    "5.10.2"
 #define ADDON_INSTANCE_VERSION_PVR_MIN                "5.10.0"
 #define ADDON_INSTANCE_VERSION_PVR_XML_ID             "kodi.binary.instance.pvr"
 #define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "xbmc_pvr_dll.h" \
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
index e1d30893f797..99152e60f0a2 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_pvr_types.h
@@ -309,6 +309,7 @@ extern "C" {
     bool bSupportsRecordingsRename;     /*!< @brief true if the backend supports renaming recordings. */
     bool bSupportsRecordingsLifetimeChange; /*!< @brief true if the backend supports changing lifetime for recordings. */
     bool bSupportsDescrambleInfo;       /*!< @brief true if the backend supports descramble information for playing channels. */
+    bool bSupportsAsyncEPGTransfer;     /*!< @brief true if this addon-on supports asynchronous transfer of epg events to Kodi using the callback function EpgEventStateChange. */
 
     unsigned int iRecordingsLifetimesSize; /*!< @brief (required) Count of possible values for PVR_RECORDING.iLifetime. 0 means lifetime is not supported for recordings or no own value definition wanted, but to use Kodi defaults of 1..365. */
     PVR_ATTRIBUTE_INT_VALUE recordingsLifetimeValues[PVR_ADDON_ATTRIBUTE_VALUES_ARRAY_SIZE]; /*!< @brief (optional) Array containing the possible values for PVR_RECORDING.iLifetime. Must be filled if iLifetimesSize > 0 */
diff --git a/xbmc/pvr/epg/Epg.cpp b/xbmc/pvr/epg/Epg.cpp
index 6582134bad2f..2cc28f05375e 100644
--- a/xbmc/pvr/epg/Epg.cpp
+++ b/xbmc/pvr/epg/Epg.cpp
@@ -254,16 +254,50 @@ CPVREpgInfoTagPtr CPVREpg::GetTagByBroadcastId(unsigned int iUniqueBroadcastId)
   return CPVREpgInfoTagPtr();
 }
 
-CPVREpgInfoTagPtr CPVREpg::GetTagBetween(const CDateTime &beginTime, const CDateTime &endTime) const
+CPVREpgInfoTagPtr CPVREpg::GetTagBetween(const CDateTime &beginTime, const CDateTime &endTime, bool bUpdateFromClient /* = false */)
 {
+  CPVREpgInfoTagPtr tag;
+
   CSingleLock lock(m_critSection);
   for (std::map<CDateTime, CPVREpgInfoTagPtr>::const_iterator it = m_tags.begin(); it != m_tags.end(); ++it)
   {
     if (it->second->StartAsUTC() >= beginTime && it->second->EndAsUTC() <= endTime)
-      return it->second;
+    {
+      tag = it->second;
+      break;
+    }
   }
 
-  return CPVREpgInfoTagPtr();
+  if (!tag && bUpdateFromClient)
+  {
+    // not found locally; try to fetch from client
+    time_t b;
+    beginTime.GetAsTime(b);
+    time_t e;
+    endTime.GetAsTime(e);
+
+    const CPVRChannelPtr channel = Channel();
+    if (channel)
+    {
+      CPVREpg tmpEpg(channel);
+      if (tmpEpg.UpdateFromScraper(b, e, true))
+        tag = tmpEpg.GetTagBetween(beginTime, endTime, false);
+    }
+    else
+    {
+      CPVREpg tmpEpg(m_iEpgID, m_strName, m_strScraperName);
+      if (tmpEpg.UpdateFromScraper(b, e, true))
+       tag = tmpEpg.GetTagBetween(beginTime, endTime, false);
+    }
+
+    if (tag)
+    {
+      m_tags.insert(make_pair(tag->StartAsUTC(), tag));
+      UpdateEntry(tag, !CServiceBroker::GetSettings()->GetBool(CSettings::SETTING_EPG_IGNOREDBFORCLIENT));
+    }
+  }
+
+  return tag;
 }
 
 std::vector<CPVREpgInfoTagPtr> CPVREpg::GetTagsBetween(const CDateTime &beginTime, const CDateTime &endTime) const
@@ -524,7 +558,7 @@ bool CPVREpg::Update(const time_t start, const time_t end, int iUpdateTime, bool
     bUpdate = true;
 
   if (bUpdate)
-    bGrabSuccess = LoadFromClients(start, end);
+    bGrabSuccess = LoadFromClients(start, end, bForceUpdate);
 
   if (bGrabSuccess)
     m_bLoaded = true;
@@ -683,7 +717,7 @@ bool CPVREpg::FixOverlappingEvents(bool bUpdateDb /* = false */)
   return bReturn;
 }
 
-bool CPVREpg::UpdateFromScraper(time_t start, time_t end)
+bool CPVREpg::UpdateFromScraper(time_t start, time_t end, bool bForceUpdate)
 {
   if (m_strScraperName.empty())
   {
@@ -708,6 +742,11 @@ bool CPVREpg::UpdateFromScraper(time_t start, time_t end)
           CLog::LogF(LOGERROR, "The backend for channel '%s' on client '%i' does not support EPGs",
                      channel->ChannelName().c_str(), channel->ClientID());
         }
+        else if (!bForceUpdate && client->GetClientCapabilities().SupportsAsyncEPGTransfer())
+        {
+          // nothing to do. client will provide epg updates asynchrounously
+          return true;
+        }
         else
         {
           CLog::LogFC(LOGDEBUG, LOGEPG, "Updating EPG for channel '%s' from client '%i'",
@@ -784,20 +823,20 @@ const std::string &CPVREpg::ConvertGenreIdToString(int iID, int iSubID)
   return g_localizeStrings.Get(iLabelId);
 }
 
-bool CPVREpg::LoadFromClients(time_t start, time_t end)
+bool CPVREpg::LoadFromClients(time_t start, time_t end, bool bForceUpdate)
 {
   bool bReturn(false);
   CPVRChannelPtr channel = Channel();
   if (channel)
   {
     CPVREpg tmpEpg(channel);
-    if (tmpEpg.UpdateFromScraper(start, end))
+    if (tmpEpg.UpdateFromScraper(start, end, bForceUpdate))
       bReturn = UpdateEntries(tmpEpg, !CServiceBroker::GetSettings()->GetBool(CSettings::SETTING_EPG_IGNOREDBFORCLIENT));
   }
   else
   {
     CPVREpg tmpEpg(m_iEpgID, m_strName, m_strScraperName);
-    if (tmpEpg.UpdateFromScraper(start, end))
+    if (tmpEpg.UpdateFromScraper(start, end, bForceUpdate))
       bReturn = UpdateEntries(tmpEpg, !CServiceBroker::GetSettings()->GetBool(CSettings::SETTING_EPG_IGNOREDBFORCLIENT));
   }
 
diff --git a/xbmc/pvr/epg/Epg.h b/xbmc/pvr/epg/Epg.h
index baf9edcb9fd2..8dd62b92cee1 100644
--- a/xbmc/pvr/epg/Epg.h
+++ b/xbmc/pvr/epg/Epg.h
@@ -161,9 +161,10 @@ namespace PVR
      * Get the event that occurs between the given begin and end time.
      * @param beginTime Minimum start time in UTC of the event.
      * @param endTime Maximum end time in UTC of the event.
+     * @param bUpdateFromClient if true, try to fetch the event from the client if not found locally.
      * @return The found tag or NULL if it wasn't found.
      */
-    CPVREpgInfoTagPtr GetTagBetween(const CDateTime &beginTime, const CDateTime &endTime) const;
+    CPVREpgInfoTagPtr GetTagBetween(const CDateTime &beginTime, const CDateTime &endTime, bool bUpdateFromClient = false);
 
     /*!
      * Get all events occurring between the given begin and end time.
@@ -286,9 +287,10 @@ namespace PVR
      * @todo not implemented yet for non-pvr EPGs
      * @param start Get entries with a start date after this time.
      * @param end Get entries with an end date before this time.
+     * @param bForceUpdate Force update from client even if it's not the time to
      * @return True if the update was successful, false otherwise.
      */
-    bool UpdateFromScraper(time_t start, time_t end);
+    bool UpdateFromScraper(time_t start, time_t end, bool bForceUpdate);
 
     /*!
      * @brief Fix overlapping events from the tables.
@@ -307,9 +309,10 @@ namespace PVR
      * @brief Load all EPG entries from clients into a temporary table and update this table with the contents of that temporary table.
      * @param start Only get entries after this start time. Use 0 to get all entries before "end".
      * @param end Only get entries before this end time. Use 0 to get all entries after "begin". If both "begin" and "end" are 0, all entries will be updated.
+     * @param bForceUpdate Force update from client even if it's not the time to
      * @return True if the update was successful, false otherwise.
      */
-    bool LoadFromClients(time_t start, time_t end);
+    bool LoadFromClients(time_t start, time_t end, bool bForceUpdate);
 
     /*!
      * @brief Update the contents of this table with the contents provided in "epg"
diff --git a/xbmc/pvr/timers/PVRTimerInfoTag.cpp b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
index a8e11a2d90d5..4ed51d6bbd8c 100644
--- a/xbmc/pvr/timers/PVRTimerInfoTag.cpp
+++ b/xbmc/pvr/timers/PVRTimerInfoTag.cpp
@@ -929,37 +929,37 @@ CPVREpgInfoTagPtr CPVRTimerInfoTag::GetEpgInfoTag(bool bCreate /* = true */) con
           {
             m_epgTag = epg->GetTagByBroadcastId(m_iEpgUid);
           }
-          else
-          {
-            time_t startTime = 0;
-            time_t endTime = 0;
+        }
+
+        if (!m_epgTag)
+        {
+          time_t startTime = 0;
+          time_t endTime = 0;
 
-            StartAsUTC().GetAsTime(startTime);
-            if (startTime > 0)
-              EndAsUTC().GetAsTime(endTime);
+          StartAsUTC().GetAsTime(startTime);
+          if (startTime > 0)
+            EndAsUTC().GetAsTime(endTime);
 
-            if (startTime > 0 && endTime > 0)
+          if (startTime > 0 && endTime > 0)
+          {
+            const CPVREpgInfoTagPtr epgTag = epg->GetTagBetween(StartAsUTC() - CDateTimeSpan(0, 0, 2, 0), EndAsUTC() + CDateTimeSpan(0, 0, 2, 0), true);
+            if (epgTag)
             {
-              // if no epg uid present, try to find a tag according to timer's start/end time
-              CPVREpgInfoTagPtr epgTag = epg->GetTagBetween(StartAsUTC() - CDateTimeSpan(0, 0, 2, 0), EndAsUTC() + CDateTimeSpan(0, 0, 2, 0));
-              if (epgTag)
+              bool bTagMatches = !IsTimerRule();
+              if (!bTagMatches)
               {
-                bool bTagMatches = !IsTimerRule();
-                if (!bTagMatches)
+                // Check whether the tag actually is an event that belongs to a child of this timer rule
+                const CPVRTimerInfoTagPtr timer = epgTag->Timer();
+                if (timer && (timer->GetTimerRuleId() == m_iClientIndex))
                 {
-                  // Check whether the tag actually is an event that belongs to a child of this timer rule
-                  const CPVRTimerInfoTagPtr timer = epgTag->Timer();
-                  if (timer && (timer->GetTimerRuleId() == m_iClientIndex))
-                  {
-                    bTagMatches = true;
-                  }
+                  bTagMatches = true;
                 }
+              }
 
-                if (bTagMatches)
-                {
-                  m_epgTag = epgTag;
-                  m_iEpgUid = m_epgTag->UniqueBroadcastID();
-                }
+              if (bTagMatches)
+              {
+                m_epgTag = epgTag;
+                m_iEpgUid = m_epgTag->UniqueBroadcastID();
               }
             }
           }
diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
index 81dd05c24c0a..aee3c7eba2ea 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -615,12 +615,20 @@ bool CGUIWindowPVRGuideBase::RefreshTimelineItems()
       if (!endDate.IsValid() || endDate < startDate)
         endDate = startDate;
 
-      // limit start to linger time
-      int iPastDays = CServiceBroker::GetPVRManager().EpgContainer().GetPastDaysToDisplay();
+      CPVREpgContainer& epgContainer = CServiceBroker::GetPVRManager().EpgContainer();
+
+      // limit start to past days to display
+      int iPastDays = epgContainer.GetPastDaysToDisplay();
       const CDateTime maxPastDate(currentDate - CDateTimeSpan(iPastDays, 0, 0, 0));
       if (startDate < maxPastDate)
         startDate = maxPastDate;
 
+      // limit end to future days to display
+      int iFutureDays = epgContainer.GetFutureDaysToDisplay();
+      const CDateTime maxFutureDate(currentDate + CDateTimeSpan(iFutureDays, 0, 0, 0));
+      if (endDate > maxFutureDate)
+        endDate = maxFutureDate;
+
       if (m_guiState.get())
         timeline->Sort(m_guiState->GetSortMethod());
 
