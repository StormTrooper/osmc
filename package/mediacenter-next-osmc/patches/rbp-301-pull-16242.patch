From b8d1d5355bf91199ee9ab24cc437b978d789ec85 Mon Sep 17 00:00:00 2001
From: "James D. Smith" <smithjd15@gmail.com>
Date: Wed, 5 Jun 2019 20:35:20 -0600
Subject: [PATCH 1/2] Read APE tag embedded cover art

---
 xbmc/music/tags/TagLoaderTagLib.cpp | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/xbmc/music/tags/TagLoaderTagLib.cpp b/xbmc/music/tags/TagLoaderTagLib.cpp
index d4813dafebb0..33da1f644717 100644
--- a/xbmc/music/tags/TagLoaderTagLib.cpp
+++ b/xbmc/music/tags/TagLoaderTagLib.cpp
@@ -565,6 +565,28 @@ bool CTagLoaderTagLib::ParseTag(APE::Tag *ape, EmbeddedArt *art, CMusicInfoTag&
       tag.SetMusicBrainzTrackID(it->second.toString().to8Bit(true));
     else if (it->first == "MUSICBRAINZ_ALBUMTYPE")
       SetReleaseType(tag, StringListToVectorString(it->second.toStringList()));
+    else if (it->first == "COVER ART (FRONT)")
+    {
+      TagLib::ByteVector tdata = it->second.binaryData();
+      // The image data follows a null byte, which can optionally be preceded by a filename
+      const uint offset = tdata.find('\0') + 1;
+      ByteVector bv(tdata.data() + offset, tdata.size() - offset);
+      // Determine mimetype from file signature
+      std::string mime{};
+      if (bv.startsWith("\xFF\xD8\xFF"))
+        mime = "image/jpeg";
+      else if (bv.startsWith("\x89\x50\x4E\x47"))
+        mime = "image/png";
+      else if (bv.startsWith("\x47\x49\x46\x38"))
+        mime = "image/gif";
+      else if (bv.startsWith("\x42\x4D"))
+        mime = "image/bmp";
+      if ((offset > 0) && (offset < tdata.size()) && (mime.size() > 0)) {
+        tag.SetCoverArtInfo(bv.size(), mime);
+        if (art)
+          art->Set(reinterpret_cast<const uint8_t *>(bv.data()), bv.size(), mime);
+      }
+    }
     else if (CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_logLevel == LOG_LEVEL_MAX)
       CLog::Log(LOGDEBUG, "unrecognized APE tag: %s", it->first.toCString(true));
   }

From 2706c8ad967e9d132d69c6f4e15520e7ebc37e16 Mon Sep 17 00:00:00 2001
From: "James D. Smith" <smithjd15@gmail.com>
Date: Thu, 6 Jun 2019 17:57:20 -0600
Subject: [PATCH 2/2] Require the offset to be less than or equal to the data
 size

---
 xbmc/music/tags/TagLoaderTagLib.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/music/tags/TagLoaderTagLib.cpp b/xbmc/music/tags/TagLoaderTagLib.cpp
index 33da1f644717..43d04846f29c 100644
--- a/xbmc/music/tags/TagLoaderTagLib.cpp
+++ b/xbmc/music/tags/TagLoaderTagLib.cpp
@@ -571,7 +571,7 @@ bool CTagLoaderTagLib::ParseTag(APE::Tag *ape, EmbeddedArt *art, CMusicInfoTag&
       // The image data follows a null byte, which can optionally be preceded by a filename
       const uint offset = tdata.find('\0') + 1;
       ByteVector bv(tdata.data() + offset, tdata.size() - offset);
-      // Determine mimetype from file signature
+      // Infer the mimetype
       std::string mime{};
       if (bv.startsWith("\xFF\xD8\xFF"))
         mime = "image/jpeg";
@@ -581,7 +581,7 @@ bool CTagLoaderTagLib::ParseTag(APE::Tag *ape, EmbeddedArt *art, CMusicInfoTag&
         mime = "image/gif";
       else if (bv.startsWith("\x42\x4D"))
         mime = "image/bmp";
-      if ((offset > 0) && (offset < tdata.size()) && (mime.size() > 0)) {
+      if ((offset > 0) && (offset <= tdata.size()) && (mime.size() > 0)) {
         tag.SetCoverArtInfo(bv.size(), mime);
         if (art)
           art->Set(reinterpret_cast<const uint8_t *>(bv.data()), bv.size(), mime);
