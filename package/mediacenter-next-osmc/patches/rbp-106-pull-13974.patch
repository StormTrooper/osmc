From cdbea5f0aeb63377ae254a995adaf54c2226d810 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <anightik@gmail.com>
Date: Sun, 3 Jun 2018 10:22:40 +0300
Subject: [PATCH 1/3] [d3d11] fix crash if driver doesn't support 10bit
 swapchain

---
 xbmc/rendering/dx/DeviceResources.cpp | 56 +++++++++++++++++++++--------------
 xbmc/rendering/dx/DeviceResources.h   |  1 -
 2 files changed, 33 insertions(+), 24 deletions(-)

diff --git a/xbmc/rendering/dx/DeviceResources.cpp b/xbmc/rendering/dx/DeviceResources.cpp
index 1cea44c95503..176fe50398fb 100644
--- a/xbmc/rendering/dx/DeviceResources.cpp
+++ b/xbmc/rendering/dx/DeviceResources.cpp
@@ -422,21 +422,23 @@ void DX::DeviceResources::ReleaseBackBuffer()
 {
   CLog::LogF(LOGDEBUG, "release buffers.");
 
-  // Clear the previous window size specific context.
-  ID3D11RenderTargetView* nullViews[] = { nullptr, nullptr, nullptr, nullptr };
-  m_deferrContext->OMSetRenderTargets(4, nullViews, nullptr);
-  FinishCommandList(false);
-
   m_backBufferTex.Release();
   m_d3dDepthStencilView = nullptr;
-  m_deferrContext->Flush();
-  m_d3dContext->Flush();
-  m_query = nullptr;
+  if (m_deferrContext) 
+  {
+    // Clear the previous window size specific context.
+    ID3D11RenderTargetView* nullViews[] = { nullptr, nullptr, nullptr, nullptr };
+    m_deferrContext->OMSetRenderTargets(4, nullViews, nullptr);
+    FinishCommandList(false);
+
+    m_deferrContext->Flush();
+    m_d3dContext->Flush();
+  }
 }
 
 void DX::DeviceResources::CreateBackBuffer()
 {
-  if (!m_bDeviceCreated)
+  if (!m_bDeviceCreated || !m_swapChain)
     return;
 
   CLog::LogF(LOGDEBUG, "create buffers.");
@@ -521,6 +523,7 @@ void DX::DeviceResources::ResizeBuffers()
 
   bool bHWStereoEnabled = RENDER_STEREO_MODE_HARDWAREBASED == CServiceBroker::GetWinSystem()->GetGfxContext().GetStereoMode();
   bool windowed = true;
+  HRESULT hr = E_FAIL;
 
   DXGI_SWAP_CHAIN_DESC1 scDesc = { 0 };
   if (m_swapChain)
@@ -548,7 +551,7 @@ void DX::DeviceResources::ResizeBuffers()
   {
     // If the swap chain already exists, resize it.
     m_swapChain->GetDesc1(&scDesc);
-    HRESULT hr = m_swapChain->ResizeBuffers(
+    hr = m_swapChain->ResizeBuffers(
       scDesc.BufferCount,
       lround(m_outputSize.Width),
       lround(m_outputSize.Height),
@@ -570,21 +573,10 @@ void DX::DeviceResources::ResizeBuffers()
   else
   {
     // Otherwise, create a new one using the same adapter as the existing Direct3D device.
-
-    DXGI_FORMAT backBufferFormat = DXGI_FORMAT_B8G8R8A8_UNORM;
-    uint32_t is10bitSupported;
-
-    if ( m_d3dFeatureLevel >= D3D_FEATURE_LEVEL_11_0
-      && SUCCEEDED(m_d3dDevice->CheckFormatSupport(DXGI_FORMAT_R10G10B10A2_UNORM, &is10bitSupported))
-      && (is10bitSupported & D3D11_FORMAT_SUPPORT_RENDER_TARGET))
-    {
-      backBufferFormat = DXGI_FORMAT_R10G10B10A2_UNORM;
-    }
-
     DXGI_SWAP_CHAIN_DESC1 swapChainDesc = { 0 };
     swapChainDesc.Width = lround(m_outputSize.Width);
     swapChainDesc.Height = lround(m_outputSize.Height);
-    swapChainDesc.Format = backBufferFormat;
+    swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
     swapChainDesc.Stereo = bHWStereoEnabled;
     swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
     swapChainDesc.BufferCount = 3 * (1 + bHWStereoEnabled);
@@ -599,7 +591,19 @@ void DX::DeviceResources::ResizeBuffers()
     scFSDesc.Windowed = windowed;
 
     ComPtr<IDXGISwapChain1> swapChain;
-    HRESULT hr = CreateSwapChain(swapChainDesc, scFSDesc, &swapChain);
+    if (m_d3dFeatureLevel >= D3D_FEATURE_LEVEL_11_0 && !bHWStereoEnabled)
+    {
+      swapChainDesc.Format = DXGI_FORMAT_R10G10B10A2_UNORM;
+      hr = CreateSwapChain(swapChainDesc, scFSDesc, &swapChain);
+      if (FAILED(hr))
+      {
+        CLog::LogF(LOGWARNING, "creating 10bit swapchain failed, fallback to 8bit.");
+        swapChainDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
+      }
+    }
+
+    if (!swapChain)
+      hr = CreateSwapChain(swapChainDesc, scFSDesc, &swapChain);
 
     if (FAILED(hr) && bHWStereoEnabled)
     {
@@ -616,6 +620,12 @@ void DX::DeviceResources::ResizeBuffers()
       CServiceBroker::GetWinSystem()->GetGfxContext().SetStereoMode(RENDER_STEREO_MODE_SPLIT_HORIZONTAL);
     }
 
+    if (FAILED(hr))
+    {
+      CLog::LogF(LOGERROR, "unable to create swapchain.");
+      return;
+    }
+
     hr = swapChain.As(&m_swapChain); CHECK_ERR();
     m_stereoEnabled = bHWStereoEnabled;
 
diff --git a/xbmc/rendering/dx/DeviceResources.h b/xbmc/rendering/dx/DeviceResources.h
index e1c9ac445700..b4066aee2c06 100644
--- a/xbmc/rendering/dx/DeviceResources.h
+++ b/xbmc/rendering/dx/DeviceResources.h
@@ -166,7 +166,6 @@ namespace DX
     Microsoft::WRL::ComPtr<ID3D11DeviceContext1> m_d3dContext;
     Microsoft::WRL::ComPtr<ID3D11DeviceContext1> m_deferrContext;
     Microsoft::WRL::ComPtr<IDXGISwapChain1> m_swapChain;
-    Microsoft::WRL::ComPtr<ID3D11Query> m_query;
 #ifdef _DEBUG
     Microsoft::WRL::ComPtr<ID3D11Debug> m_d3dDebug;
 #endif

From 2450560e83c45635c666f28f41c6892adee035a8 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <anightik@gmail.com>
Date: Sun, 3 Jun 2018 12:36:02 +0300
Subject: [PATCH 2/3] [d3d11] screenshot: fix screenshot in case of 10bit back
 buffer

---
 xbmc/utils/Screenshot.cpp | 50 +++++++++++++++++++++++++++++++----------------
 1 file changed, 33 insertions(+), 17 deletions(-)

diff --git a/xbmc/utils/Screenshot.cpp b/xbmc/utils/Screenshot.cpp
index 985ca292a42c..3282d77250a1 100644
--- a/xbmc/utils/Screenshot.cpp
+++ b/xbmc/utils/Screenshot.cpp
@@ -88,32 +88,22 @@ bool CScreenshotSurface::capture()
   deviceResources->FinishCommandList();
 
   ComPtr<ID3D11DeviceContext> pImdContext = deviceResources->GetImmediateContext();
-  ComPtr<ID3D11DeviceContext> pContext = deviceResources->GetD3DContext();
   ComPtr<ID3D11Device> pDevice = deviceResources->GetD3DDevice();
-
-  ComPtr<ID3D11RenderTargetView> pRTView = nullptr;
-  pContext->OMGetRenderTargets(1, pRTView.GetAddressOf(), nullptr);
-  if (pRTView == nullptr)
-    return false;
-
-  ComPtr<ID3D11Resource> pRTResource = nullptr;
-  pRTView->GetResource(pRTResource.GetAddressOf());
-
-  ComPtr<ID3D11Texture2D> pCopyTexture = nullptr;
-  ComPtr<ID3D11Texture2D> pRTTexture = nullptr;
-  if (FAILED(pRTResource.As(&pRTTexture)))
+  CD3DTexture* backbuffer = deviceResources->GetBackBuffer();
+  if (!backbuffer)
     return false;
 
   D3D11_TEXTURE2D_DESC desc = { 0 };
-  pRTTexture->GetDesc(&desc);
+  backbuffer->GetDesc(&desc);
   desc.Usage = D3D11_USAGE_STAGING;
   desc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
   desc.BindFlags = 0;
 
-  if (SUCCEEDED(pDevice->CreateTexture2D(&desc, nullptr, pCopyTexture.GetAddressOf())))
+  ComPtr<ID3D11Texture2D> pCopyTexture = nullptr;
+  if (SUCCEEDED(pDevice->CreateTexture2D(&desc, nullptr, &pCopyTexture)))
   {
     // take copy
-    pImdContext->CopyResource(pCopyTexture.Get(), pRTTexture.Get());
+    pImdContext->CopyResource(pCopyTexture.Get(), backbuffer->Get());
 
     D3D11_MAPPED_SUBRESOURCE res;
     if (SUCCEEDED(pImdContext->Map(pCopyTexture.Get(), 0, D3D11_MAP_READ, 0, &res)))
@@ -122,7 +112,33 @@ bool CScreenshotSurface::capture()
       m_height = desc.Height;
       m_stride = res.RowPitch;
       m_buffer = new unsigned char[m_height * m_stride];
-      memcpy(m_buffer, res.pData, m_height * m_stride);
+      if (desc.Format == DXGI_FORMAT_R10G10B10A2_UNORM)
+      {
+        // convert R10G10B10A2 -> B8G8R8A8
+        for (int y = 0; y < m_height; y++)
+        {
+          uint32_t* pixels10 = reinterpret_cast<uint32_t*>(static_cast<uint8_t*>(res.pData) + y * res.RowPitch);
+          uint8_t* pixels8 = m_buffer + y * m_stride;
+
+          for (int x = 0; x < m_width; x++, pixels10++, pixels8 += 4)
+          {
+            // actual bit per channel is A2B10G10R10
+            uint32_t pixel = *pixels10;
+            // R
+            pixels8[2] = static_cast<uint8_t>((pixel & 0x3FF) * 255 / 1023);
+            // G
+            pixel >>= 10;
+            pixels8[1] = static_cast<uint8_t>((pixel & 0x3FF) * 255 / 1023);
+            // B
+            pixel >>= 10;
+            pixels8[0] = static_cast<uint8_t>((pixel & 0x3FF) * 255 / 1023);
+            // A
+            pixels8[3] = 0xFF;
+          }
+        }
+      }
+      else
+        memcpy(m_buffer, res.pData, m_height * m_stride);
       pImdContext->Unmap(pCopyTexture.Get(), 0);
     }
     else

From 847d8d59a99df4a5a33e214e7814543309c09d19 Mon Sep 17 00:00:00 2001
From: Anton Fedchin <anightik@gmail.com>
Date: Sun, 3 Jun 2018 23:04:25 +0300
Subject: [PATCH 3/3] [d3d11] enable 10bit rendering via advanced settings
 (default is off)

---
 xbmc/rendering/dx/DeviceResources.cpp | 4 +++-
 xbmc/settings/AdvancedSettings.cpp    | 2 ++
 xbmc/settings/AdvancedSettings.h      | 1 +
 3 files changed, 6 insertions(+), 1 deletion(-)

diff --git a/xbmc/rendering/dx/DeviceResources.cpp b/xbmc/rendering/dx/DeviceResources.cpp
index 176fe50398fb..520f5e94d0ff 100644
--- a/xbmc/rendering/dx/DeviceResources.cpp
+++ b/xbmc/rendering/dx/DeviceResources.cpp
@@ -591,7 +591,9 @@ void DX::DeviceResources::ResizeBuffers()
     scFSDesc.Windowed = windowed;
 
     ComPtr<IDXGISwapChain1> swapChain;
-    if (m_d3dFeatureLevel >= D3D_FEATURE_LEVEL_11_0 && !bHWStereoEnabled)
+    if ( m_d3dFeatureLevel >= D3D_FEATURE_LEVEL_11_0 
+      && !bHWStereoEnabled 
+      && g_advancedSettings.m_bTry10bitOutput)
     {
       swapChainDesc.Format = DXGI_FORMAT_R10G10B10A2_UNORM;
       hr = CreateSwapChain(swapChainDesc, scFSDesc, &swapChain);
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index 1fbf48c1694e..294c419046bb 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -343,6 +343,7 @@ void CAdvancedSettings::Initialize()
   m_sleepBeforeFlip = 0;
   m_bVirtualShares = true;
   m_bAllowDeferredRendering = true;
+  m_bTry10bitOutput = false;
 
   m_cpuTempCmd = "";
   m_gpuTempCmd = "";
@@ -900,6 +901,7 @@ void CAdvancedSettings::ParseSettingsFile(const std::string &file)
   XMLUtils::GetBoolean(pRootElement,"virtualshares", m_bVirtualShares);
   XMLUtils::GetUInt(pRootElement, "packagefoldersize", m_addonPackageFolderSize);
   XMLUtils::GetBoolean(pRootElement, "allowdeferredrendering", m_bAllowDeferredRendering);
+  XMLUtils::GetBoolean(pRootElement, "try10bitoutput", m_bTry10bitOutput);
 
   // EPG
   pElement = pRootElement->FirstChildElement("epg");
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 5553812a7879..4364c2d0efd9 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -318,6 +318,7 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     float m_sleepBeforeFlip; ///< if greater than zero, XBMC waits for raster to be this amount through the frame prior to calling the flip
     bool m_bVirtualShares;
     bool m_bAllowDeferredRendering;
+    bool m_bTry10bitOutput;
 
     std::string m_cpuTempCmd;
     std::string m_gpuTempCmd;
