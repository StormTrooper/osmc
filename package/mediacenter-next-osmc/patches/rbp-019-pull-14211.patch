From e81d915fc06441711fd49fc09843d4aca8eccb14 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 22 Jul 2018 11:06:17 +0200
Subject: [PATCH] X11: some fixes to OML timings

---
 xbmc/windowing/X11/GLContextEGL.cpp | 26 +++++++++++++++++++-------
 1 file changed, 19 insertions(+), 7 deletions(-)

diff --git a/xbmc/windowing/X11/GLContextEGL.cpp b/xbmc/windowing/X11/GLContextEGL.cpp
index ab42a7b27acb..ca1c595f4fe7 100644
--- a/xbmc/windowing/X11/GLContextEGL.cpp
+++ b/xbmc/windowing/X11/GLContextEGL.cpp
@@ -337,11 +337,16 @@ void CGLContextEGL::SwapBuffers()
   uint64_t ust1, ust2;
   uint64_t msc1, msc2;
   uint64_t sbc1, sbc2;
+  struct timespec nowTs;
+  uint64_t now;
 
   eglGetSyncValuesCHROMIUM(m_eglDisplay, m_eglSurface, &ust1, &msc1, &sbc1);
 
   eglSwapBuffers(m_eglDisplay, m_eglSurface);
 
+  clock_gettime(CLOCK_MONOTONIC, &nowTs);
+  now = nowTs.tv_sec * 1000000000 + nowTs.tv_nsec;
+
   eglGetSyncValuesCHROMIUM(m_eglDisplay, m_eglSurface, &ust2, &msc2, &sbc2);
 
   if ((msc1 - m_sync.msc1) > 2)
@@ -349,11 +354,6 @@ void CGLContextEGL::SwapBuffers()
     m_sync.cont = 0;
   }
 
-  struct timespec nowTs;
-  uint64_t now;
-  clock_gettime(CLOCK_MONOTONIC, &nowTs);
-  now = nowTs.tv_sec * 1000000000 + nowTs.tv_nsec;
-
   // we want to block in SwapBuffers
   // if a vertical retrace occurs 5 times in a row outside
   // of this function, we take action
@@ -373,7 +373,13 @@ void CGLContextEGL::SwapBuffers()
   {
     // if no vertical retrace has occurred in eglSwapBuffers,
     // sleep until next vertical retrace
-    uint64_t sleeptime = m_sync.interval - (now / 1000 - ust2);
+    uint64_t lastIncrement = (now / 1000 - ust2);
+    uint64_t sleeptime = m_sync.interval - lastIncrement;
+    if (lastIncrement > m_sync.interval)
+    {
+      lastIncrement = m_sync.interval;
+      CLog::Log(LOGWARNING, "CGLContextEGL::SwapBuffers: last msc time greater than interval");
+    }
     usleep(sleeptime);
     m_sync.cont++;
     msc2++;
@@ -382,7 +388,13 @@ void CGLContextEGL::SwapBuffers()
   {
     // sleep until next vertical retrace
     // this avoids blocking outside of this function
-    uint64_t sleeptime = m_sync.interval - (now / 1000 - ust2);
+    uint64_t lastIncrement = (now / 1000 - ust2);
+    uint64_t sleeptime = m_sync.interval - lastIncrement;
+    if (lastIncrement > m_sync.interval)
+    {
+      lastIncrement = m_sync.interval;
+      CLog::Log(LOGWARNING, "CGLContextEGL::SwapBuffers: last msc time greater than interval (1)");
+    }
     usleep(sleeptime);
     msc2++;
   }
