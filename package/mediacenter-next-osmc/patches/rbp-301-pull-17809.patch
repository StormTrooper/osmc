From c55380b90da1ca13a0c3f8de011651910fd7c5cb Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 20:00:23 +0200
Subject: [PATCH 1/7] [video][PVR] Recordings folders: Add support for 'Play'
 context menu item.

---
 xbmc/video/ContextMenus.cpp | 89 +++++++++++++++++++++++++++++++++++--
 1 file changed, 86 insertions(+), 3 deletions(-)

diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index 4e02c38ff58e..137c5dee0ff2 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -10,10 +10,15 @@
 
 #include "Application.h"
 #include "Autorun.h"
+#include "ServiceBroker.h"
+#include "filesystem/Directory.h"
+#include "guilib/GUIComponent.h"
+#include "guilib/GUIWindowManager.h"
+#include "settings/MediaSettings.h"
 #include "utils/URIUtils.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
 #include "video/windows/GUIWindowVideoBase.h"
-
+#include "view/GUIViewState.h"
 
 namespace CONTEXTMENU
 {
@@ -119,7 +124,54 @@ bool CResume::IsVisible(const CFileItem& itemIn) const
   return CGUIWindowVideoBase::HasResumeItemOffset(&item);
 }
 
-static void SetPathAndPlay(CFileItem& item)
+namespace
+{
+
+void AddRecordingsToPlayList(const std::shared_ptr<CFileItem>& item, CFileItemList& queuedItems)
+{
+  if (item->m_bIsFolder)
+  {
+    CFileItemList items;
+    XFILE::CDirectory::GetDirectory(item->GetPath(), items, "", XFILE::DIR_FLAG_DEFAULTS);
+
+    const int watchedMode = CMediaSettings::GetInstance().GetWatchedMode("recordings");
+    const bool unwatchedOnly = watchedMode == WatchedModeUnwatched;
+    const bool watchedOnly = watchedMode == WatchedModeWatched;
+    for (const auto& currItem : items)
+    {
+      if (currItem->HasVideoInfoTag() &&
+          ((unwatchedOnly && currItem->GetVideoInfoTag()->GetPlayCount() > 0) ||
+           (watchedOnly && currItem->GetVideoInfoTag()->GetPlayCount() <= 0)))
+        continue;
+
+      AddRecordingsToPlayList(currItem, queuedItems);
+    }
+  }
+  else
+  {
+    queuedItems.Add(item);
+  }
+}
+
+void AddRecordingsToPlayListAndSort(const std::shared_ptr<CFileItem>& item,
+                                    CFileItemList& queuedItems)
+{
+  queuedItems.SetPath(item->GetPath());
+  AddRecordingsToPlayList(item, queuedItems);
+
+  if (!queuedItems.IsEmpty())
+  {
+    const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
+    if (windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS)
+    {
+      const CGUIViewState* viewState = CGUIViewState::GetViewState(windowId, queuedItems);
+      if (viewState)
+        queuedItems.Sort(viewState->GetSortMethod());
+    }
+  }
+}
+
+void SetPathAndPlay(CFileItem& item)
 {
   if (item.IsVideoDb())
   {
@@ -129,11 +181,32 @@ static void SetPathAndPlay(CFileItem& item)
   item.SetProperty("check_resume", false);
 
   if (item.IsLiveTV()) // pvr tv or pvr radio?
+  {
     g_application.PlayMedia(item, "", PLAYLIST_NONE);
+  }
+  else if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+  {
+    // recursively add items to play list
+    CFileItemList queuedItems;
+    AddRecordingsToPlayListAndSort(std::make_shared<CFileItem>(item), queuedItems);
+
+    PLAYLIST::CPlayListPlayer& player = CServiceBroker::GetPlaylistPlayer();
+
+    player.ClearPlaylist(PLAYLIST_VIDEO);
+    player.Reset();
+    player.Add(PLAYLIST_VIDEO, queuedItems);
+    player.SetCurrentPlaylist(PLAYLIST_VIDEO);
+
+    player.Play();
+  }
   else
+  {
     CServiceBroker::GetPlaylistPlayer().Play(std::make_shared<CFileItem>(item), "");
+  }
 }
 
+} // unnamed namespace
+
 bool CResume::Execute(const CFileItemPtr& itemIn) const
 {
   CFileItem item(itemIn->GetItemToPlay());
@@ -164,7 +237,17 @@ bool CPlay::IsVisible(const CFileItem& itemIn) const
     return false;
 
   if (item.m_bIsFolder)
-    return false; //! @todo implement
+  {
+    if (StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+    {
+      // Note: Recordings contained in the folder must be sorted properly, thus this
+      //       item is only available if one of the recordings windows is active.
+      const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
+      return windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS;
+    }
+    else
+      return false; //! @todo implement
+  }
 
   return item.IsVideo() || item.IsLiveTV() || item.IsDVD() || item.IsCDDA();
 }

From 948cf75388a36df153bc4274dca8039ccadb7a6b Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 20:58:24 +0200
Subject: [PATCH 2/7] [video][PVR] Recordings folders: Add support for 'Play
 next' and 'Queue item' context menu items.

---
 .../resources/strings.po                      |  3 +
 xbmc/ContextMenuManager.cpp                   |  2 +
 xbmc/video/ContextMenus.cpp                   | 63 +++++++++++++++++++
 xbmc/video/ContextMenus.h                     | 15 +++++
 4 files changed, 83 insertions(+)

diff --git a/addons/resource.language.en_gb/resources/strings.po b/addons/resource.language.en_gb/resources/strings.po
index 5d5ad0715689..32894012d893 100644
--- a/addons/resource.language.en_gb/resources/strings.po
+++ b/addons/resource.language.en_gb/resources/strings.po
@@ -4818,6 +4818,7 @@ msgid "System information"
 msgstr ""
 
 #: xbmc/music/windows/GUIWindowMusicBase.cpp
+#: xbmc/video/ContextMenus.cpp
 #: xbmc/video/windows/GUIWindowVideoBase.cpp
 msgctxt "#10008"
 msgid "Play next"
@@ -6752,6 +6753,8 @@ msgid "Movie information"
 msgstr ""
 
 #: system/settings/settings.xml
+#: xbmc/video/ContextMenus.cpp
+#: xbmc/video/windows/GUIWindowVideoBase.cpp
 msgctxt "#13347"
 msgid "Queue item"
 msgstr ""
diff --git a/xbmc/ContextMenuManager.cpp b/xbmc/ContextMenuManager.cpp
index 3db001652c56..95a3327f9aa6 100644
--- a/xbmc/ContextMenuManager.cpp
+++ b/xbmc/ContextMenuManager.cpp
@@ -55,6 +55,8 @@ void CContextMenuManager::Init()
   m_items = {
       std::make_shared<CONTEXTMENU::CResume>(),
       std::make_shared<CONTEXTMENU::CPlay>(),
+      std::make_shared<CONTEXTMENU::CPlayNext>(),
+      std::make_shared<CONTEXTMENU::CQueue>(),
       std::make_shared<CONTEXTMENU::CAddonInfo>(),
       std::make_shared<CONTEXTMENU::CEnableAddon>(),
       std::make_shared<CONTEXTMENU::CDisableAddon>(),
diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index 137c5dee0ff2..bf22ee683ba0 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -171,6 +171,28 @@ void AddRecordingsToPlayListAndSort(const std::shared_ptr<CFileItem>& item,
   }
 }
 
+void QueueRecordings(const std::shared_ptr<CFileItem>& item, bool bPlayNext)
+{
+  CFileItemList queuedItems;
+  AddRecordingsToPlayListAndSort(item, queuedItems);
+
+  PLAYLIST::CPlayListPlayer& player = CServiceBroker::GetPlaylistPlayer();
+
+  // Determine the proper list to queue this element
+  int playlist = player.GetCurrentPlaylist();
+  if (playlist == PLAYLIST_NONE)
+    playlist = g_application.GetAppPlayer().GetPreferredPlaylist();
+  if (playlist == PLAYLIST_NONE)
+    playlist = PLAYLIST_VIDEO;
+
+  if (bPlayNext && g_application.GetAppPlayer().IsPlaying())
+    player.Insert(playlist, queuedItems, player.GetCurrentSong() + 1);
+  else
+    player.Add(playlist, queuedItems);
+
+  player.SetCurrentPlaylist(playlist);
+}
+
 void SetPathAndPlay(CFileItem& item)
 {
   if (item.IsVideoDb())
@@ -263,4 +285,45 @@ bool CPlay::Execute(const CFileItemPtr& itemIn) const
   return true;
 };
 
+bool CQueue::IsVisible(const CFileItem& item) const
+{
+  if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+    return true;
+
+  return false; //! @todo implement
 }
+
+bool CQueue::Execute(const CFileItemPtr& item) const
+{
+  if (item->m_bIsFolder && StringUtils::StartsWith(item->GetPath(), "pvr://recordings/"))
+  {
+    // recursively add items to play list
+    QueueRecordings(item, false);
+    return true;
+  }
+
+  return true; //! @todo implement
+};
+
+bool CPlayNext::IsVisible(const CFileItem& item) const
+{
+  if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+    return true;
+
+  return false; //! @todo implement
+}
+
+bool CPlayNext::Execute(const CFileItemPtr& item) const
+{
+  if (item->m_bIsFolder && StringUtils::StartsWith(item->GetPath(), "pvr://recordings/"))
+  {
+    // recursively add items to play list
+    QueueRecordings(item, true);
+    return true;
+  }
+
+  return true; //! @todo implement
+};
+
+}
+
diff --git a/xbmc/video/ContextMenus.h b/xbmc/video/ContextMenus.h
index e5eace22f6c8..3fc5449e5ab1 100644
--- a/xbmc/video/ContextMenus.h
+++ b/xbmc/video/ContextMenus.h
@@ -78,4 +78,19 @@ struct CPlay : IContextMenuItem
   bool IsVisible(const CFileItem& item) const override;
   bool Execute(const CFileItemPtr& _item) const override;
 };
+
+struct CQueue : CStaticContextMenuAction
+{
+  CQueue() : CStaticContextMenuAction(13347) {} // Queue item
+  bool IsVisible(const CFileItem& item) const override;
+  bool Execute(const CFileItemPtr& item) const override;
+};
+
+struct CPlayNext : CStaticContextMenuAction
+{
+  CPlayNext() : CStaticContextMenuAction(10008) {} // Play next
+  bool IsVisible(const CFileItem& item) const override;
+  bool Execute(const CFileItemPtr& item) const override;
+};
+
 }

From 336afff4a15713c4467ba57ceff77746ac6ffdce Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 23:44:14 +0200
Subject: [PATCH 3/7] [video][PVR] Recordings: Add support for 'Play next' and
 'Queue item' context menu items.

---
 xbmc/video/ContextMenus.cpp | 51 ++++++++++++++++++++++++-------------
 1 file changed, 34 insertions(+), 17 deletions(-)

diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index bf22ee683ba0..f4cb4f687771 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -193,6 +193,19 @@ void QueueRecordings(const std::shared_ptr<CFileItem>& item, bool bPlayNext)
   player.SetCurrentPlaylist(playlist);
 }
 
+bool IsActiveRecordingsFolder(const CFileItem& item)
+{
+  if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+  {
+    // Note: Recordings contained in the folder must be sorted properly, thus this
+    //       item is only available if one of the recordings windows is active.
+    const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
+    return windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS;
+  }
+
+  return false;
+}
+
 void SetPathAndPlay(CFileItem& item)
 {
   if (item.IsVideoDb())
@@ -206,7 +219,7 @@ void SetPathAndPlay(CFileItem& item)
   {
     g_application.PlayMedia(item, "", PLAYLIST_NONE);
   }
-  else if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+  else if (IsActiveRecordingsFolder(item))
   {
     // recursively add items to play list
     CFileItemList queuedItems;
@@ -258,18 +271,11 @@ bool CPlay::IsVisible(const CFileItem& itemIn) const
   if (item.IsDeleted()) // e.g. trashed pvr recording
     return false;
 
+  if (IsActiveRecordingsFolder(item))
+    return true;
+
   if (item.m_bIsFolder)
-  {
-    if (StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
-    {
-      // Note: Recordings contained in the folder must be sorted properly, thus this
-      //       item is only available if one of the recordings windows is active.
-      const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
-      return windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS;
-    }
-    else
-      return false; //! @todo implement
-  }
+    return false; //! @todo implement
 
   return item.IsVideo() || item.IsLiveTV() || item.IsDVD() || item.IsCDDA();
 }
@@ -287,7 +293,10 @@ bool CPlay::Execute(const CFileItemPtr& itemIn) const
 
 bool CQueue::IsVisible(const CFileItem& item) const
 {
-  if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+  if (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if (item.IsUsablePVRRecording() || IsActiveRecordingsFolder(item))
     return true;
 
   return false; //! @todo implement
@@ -295,7 +304,10 @@ bool CQueue::IsVisible(const CFileItem& item) const
 
 bool CQueue::Execute(const CFileItemPtr& item) const
 {
-  if (item->m_bIsFolder && StringUtils::StartsWith(item->GetPath(), "pvr://recordings/"))
+  if (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if (item->IsUsablePVRRecording() || IsActiveRecordingsFolder(*item))
   {
     // recursively add items to play list
     QueueRecordings(item, false);
@@ -307,7 +319,10 @@ bool CQueue::Execute(const CFileItemPtr& item) const
 
 bool CPlayNext::IsVisible(const CFileItem& item) const
 {
-  if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
+  if (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if (item.IsUsablePVRRecording() || IsActiveRecordingsFolder(item))
     return true;
 
   return false; //! @todo implement
@@ -315,7 +330,10 @@ bool CPlayNext::IsVisible(const CFileItem& item) const
 
 bool CPlayNext::Execute(const CFileItemPtr& item) const
 {
-  if (item->m_bIsFolder && StringUtils::StartsWith(item->GetPath(), "pvr://recordings/"))
+  if (CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow() == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if (item->IsUsablePVRRecording() || IsActiveRecordingsFolder(*item))
   {
     // recursively add items to play list
     QueueRecordings(item, true);
@@ -326,4 +344,3 @@ bool CPlayNext::Execute(const CFileItemPtr& item) const
 };
 
 }
-

From c9f6d45c9d4f4b639c1759b188969645189cb9d7 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Fri, 8 May 2020 17:31:22 +0200
Subject: [PATCH 4/7] [video][PVR] Recordings: Add support for 'Play from here'
 context menu item.

---
 xbmc/ContextMenuManager.cpp |  1 +
 xbmc/video/ContextMenus.cpp | 69 +++++++++++++++++++++++++++++++++++++
 xbmc/video/ContextMenus.h   |  7 ++++
 3 files changed, 77 insertions(+)

diff --git a/xbmc/ContextMenuManager.cpp b/xbmc/ContextMenuManager.cpp
index 95a3327f9aa6..871da53d39a4 100644
--- a/xbmc/ContextMenuManager.cpp
+++ b/xbmc/ContextMenuManager.cpp
@@ -55,6 +55,7 @@ void CContextMenuManager::Init()
   m_items = {
       std::make_shared<CONTEXTMENU::CResume>(),
       std::make_shared<CONTEXTMENU::CPlay>(),
+      std::make_shared<CONTEXTMENU::CPlayAndQueue>(),
       std::make_shared<CONTEXTMENU::CPlayNext>(),
       std::make_shared<CONTEXTMENU::CQueue>(),
       std::make_shared<CONTEXTMENU::CAddonInfo>(),
diff --git a/xbmc/video/ContextMenus.cpp b/xbmc/video/ContextMenus.cpp
index f4cb4f687771..459804096997 100644
--- a/xbmc/video/ContextMenus.cpp
+++ b/xbmc/video/ContextMenus.cpp
@@ -14,6 +14,7 @@
 #include "filesystem/Directory.h"
 #include "guilib/GUIComponent.h"
 #include "guilib/GUIWindowManager.h"
+#include "playlists/PlayList.h"
 #include "settings/MediaSettings.h"
 #include "utils/URIUtils.h"
 #include "video/dialogs/GUIDialogVideoInfo.h"
@@ -193,6 +194,44 @@ void QueueRecordings(const std::shared_ptr<CFileItem>& item, bool bPlayNext)
   player.SetCurrentPlaylist(playlist);
 }
 
+void PlayAndQueueRecordings(const std::shared_ptr<CFileItem>& item, int windowId)
+{
+  const std::shared_ptr<CFileItem> parentFolderItem =
+      std::make_shared<CFileItem>(URIUtils::GetParentPath(item->GetPath()), true);
+
+  // add all items of given item's directory to a temporary playlist, start playback of given item
+  CFileItemList queuedItems;
+  AddRecordingsToPlayListAndSort(parentFolderItem, queuedItems);
+
+  PLAYLIST::CPlayListPlayer& player = CServiceBroker::GetPlaylistPlayer();
+
+  player.ClearPlaylist(PLAYLIST_VIDEO);
+  player.Reset();
+  player.Add(PLAYLIST_VIDEO, queuedItems);
+
+  // figure out where to start playback
+  PLAYLIST::CPlayList& playList = player.GetPlaylist(PLAYLIST_VIDEO);
+  int itemToPlay = 0;
+
+  for (int i = 0; i < queuedItems.Size(); ++i)
+  {
+    if (item->IsSamePath(queuedItems.Get(i).get()))
+    {
+      itemToPlay = i;
+      break;
+    }
+  }
+
+  if (player.IsShuffled(PLAYLIST_VIDEO))
+  {
+    playList.Swap(0, playList.FindOrder(itemToPlay));
+    itemToPlay = 0;
+  }
+
+  player.SetCurrentPlaylist(PLAYLIST_VIDEO);
+  player.Play(itemToPlay, "");
+}
+
 bool IsActiveRecordingsFolder(const CFileItem& item)
 {
   if (item.m_bIsFolder && StringUtils::StartsWith(item.GetPath(), "pvr://recordings/"))
@@ -343,4 +382,34 @@ bool CPlayNext::Execute(const CFileItemPtr& item) const
   return true; //! @todo implement
 };
 
+bool CPlayAndQueue::IsVisible(const CFileItem& item) const
+{
+  const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
+  if (windowId == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if ((windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS) &&
+      item.IsUsablePVRRecording())
+    return true;
+
+  return false; //! @todo implement
+}
+
+bool CPlayAndQueue::Execute(const CFileItemPtr& item) const
+{
+  const int windowId = CServiceBroker::GetGUI()->GetWindowManager().GetActiveWindow();
+  if (windowId == WINDOW_VIDEO_PLAYLIST)
+    return false; // Already queued
+
+  if ((windowId == WINDOW_TV_RECORDINGS || windowId == WINDOW_RADIO_RECORDINGS) &&
+      item->IsUsablePVRRecording())
+  {
+    // recursively add items located in the same folder as item to play list, starting with item
+    PlayAndQueueRecordings(item, windowId);
+    return true;
+  }
+
+  return true; //! @todo implement
+};
+
 }
diff --git a/xbmc/video/ContextMenus.h b/xbmc/video/ContextMenus.h
index 3fc5449e5ab1..f000f5246cb9 100644
--- a/xbmc/video/ContextMenus.h
+++ b/xbmc/video/ContextMenus.h
@@ -93,4 +93,11 @@ struct CPlayNext : CStaticContextMenuAction
   bool Execute(const CFileItemPtr& item) const override;
 };
 
+struct CPlayAndQueue : CStaticContextMenuAction
+{
+  CPlayAndQueue() : CStaticContextMenuAction(13412) {} // Play from here
+  bool IsVisible(const CFileItem& item) const override;
+  bool Execute(const CFileItemPtr& item) const override;
+};
+
 }

From 35ce7e7efe7ecf74f98cf539e0196301d9e26fd3 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Fri, 8 May 2020 11:20:19 +0200
Subject: [PATCH 5/7] [video] Fix playlist window not playing the clicked item
 if 'autoplay next item' is enabled for 'Uncategorised' content in Kodi
 settings.

---
 xbmc/video/GUIViewStateVideo.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/video/GUIViewStateVideo.h b/xbmc/video/GUIViewStateVideo.h
index 11b04d6fc9d7..6cc0edc391eb 100644
--- a/xbmc/video/GUIViewStateVideo.h
+++ b/xbmc/video/GUIViewStateVideo.h
@@ -44,6 +44,7 @@ class CGUIViewStateWindowVideoPlaylist : public CGUIViewStateWindowVideo
   bool HideExtensions() override;
   bool HideParentDirItems() override;
   VECSOURCES& GetSources() override;
+  bool AutoPlayNextItem() override { return false; }
 };
 
 class CGUIViewStateVideoMovies : public CGUIViewStateWindowVideo

From 9e72512102a9644a3428d418c5efba291d53a973 Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Tue, 5 May 2020 21:54:59 +0200
Subject: [PATCH 6/7] [Estuary][PVR] Recordings window: Add 'Go to playlist' to
 side blade.

---
 addons/skin.estuary/xml/Includes_MediaMenu.xml | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/addons/skin.estuary/xml/Includes_MediaMenu.xml b/addons/skin.estuary/xml/Includes_MediaMenu.xml
index f064257c7aa7..09fd27e9e501 100644
--- a/addons/skin.estuary/xml/Includes_MediaMenu.xml
+++ b/addons/skin.estuary/xml/Includes_MediaMenu.xml
@@ -198,6 +198,18 @@
 					<label>$LOCALIZE[19077]</label>
 					<visible>Window.IsActive(MyPVRTimers.xml)</visible>
 				</control>
+				<control type="label" id="301">
+					<include>MediaMenuLabelCommon</include>
+					<label>$LOCALIZE[31020]</label>
+					<visible>Control.IsVisible(302)</visible>
+				</control>
+				<control type="button" id="302">
+					<description>Go to playlist</description>
+					<include>MediaMenuItemsCommon</include>
+					<label>$LOCALIZE[31056]</label>
+					<onclick>ActivateWindow(videoplaylist)</onclick>
+					<visible>Window.IsActive(MyPVRRecordings.xml) + Integer.IsGreater(Playlist.Length(video),0)</visible>
+				</control>
 				<control type="group" id="141000">
 					<control type="grouplist" id="14100">
 						<animation effect="fade" start="0" end="100" time="400">WindowOpen</animation>
@@ -207,7 +219,7 @@
 						<itemgap>-17</itemgap>
 						<left>5</left>
 						<onleft>14100</onleft>
-						<onup>8</onup>
+						<onup>302</onup>
 						<ondown>6056</ondown>
 						<visible>Player.HasMedia + [$EXP[sidebar_visible]]</visible>
 						<visible>!System.HasActiveModalDialog</visible>

From 0d42fdc5ac22a624596ca5736bfd1d71a10cdf1b Mon Sep 17 00:00:00 2001
From: Kai Sommerfeld <kai.sommerfeld@gmx.com>
Date: Fri, 8 May 2020 00:46:05 +0200
Subject: [PATCH 7/7] [Estuary] Playlist window: Add support for PVR
 recordings.

---
 addons/skin.estuary/xml/Variables.xml | 1 +
 1 file changed, 1 insertion(+)

diff --git a/addons/skin.estuary/xml/Variables.xml b/addons/skin.estuary/xml/Variables.xml
index d75dd5ac9e24..4b09b9968116 100644
--- a/addons/skin.estuary/xml/Variables.xml
+++ b/addons/skin.estuary/xml/Variables.xml
@@ -78,6 +78,7 @@
 	<variable name="ListLabelVar">
 		<value condition="String.IsEqual(ListItem.DbType,episode) + Window.IsActive(videoplaylist)">$INFO[ListItem.TVShowtitle,,: ]$INFO[ListItem.Season,,x]$INFO[ListItem.Episode,,. ]$INFO[ListItem.Title]</value>
 		<value condition="String.IsEqual(ListItem.DbType,musicvideo) + Window.IsActive(videoplaylist)">$INFO[ListItem.Artist,, - ]$INFO[ListItem.Title]</value>
+		<value condition="[!String.IsEmpty(ListItem.Season) | !String.IsEmpty(ListItem.Episode) | !String.IsEmpty(ListItem.EpisodeName)] + Window.IsActive(videoplaylist)">$INFO[ListItem.Title,,: ]$VAR[SeasonEpisodeLabel]$INFO[ListItem.EpisodeName]</value>
 		<value>$INFO[ListItem.Label]</value>
 	</variable>
 	<variable name="ListLabel2Var">
