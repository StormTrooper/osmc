From d59b9f3754126919cc982566772506b87c59da2e Mon Sep 17 00:00:00 2001
From: peak3d <pfau@peak3d.de>
Date: Mon, 2 Jul 2018 21:27:46 +0200
Subject: [PATCH] Fix segfault on shutdown caused by busy python addons

---
 xbmc/interfaces/generic/LanguageInvokerThread.cpp   |  4 ++--
 xbmc/interfaces/generic/ScriptInvocationManager.cpp |  4 +++-
 xbmc/interfaces/python/PythonInvoker.cpp            | 16 +++++++---------
 3 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/xbmc/interfaces/generic/LanguageInvokerThread.cpp b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
index dab0944eee2b..1560d49520de 100644
--- a/xbmc/interfaces/generic/LanguageInvokerThread.cpp
+++ b/xbmc/interfaces/generic/LanguageInvokerThread.cpp
@@ -85,9 +85,9 @@ bool CLanguageInvokerThread::stop(bool wait)
   {
     // stop the language-specific invoker
     result = m_invoker->Stop(wait);
-    // stop the thread
-    CThread::StopThread(wait);
   }
+  // stop the thread
+  CThread::StopThread(wait);
 
   return result;
 }
diff --git a/xbmc/interfaces/generic/ScriptInvocationManager.cpp b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
index 24fe1c68aa82..feab66f89ef5 100644
--- a/xbmc/interfaces/generic/ScriptInvocationManager.cpp
+++ b/xbmc/interfaces/generic/ScriptInvocationManager.cpp
@@ -115,9 +115,11 @@ void CScriptInvocationManager::Uninitialize()
     if (!it->done)
       it->thread->Stop(true);
   }
-  tempList.clear();
 
   lock.Enter();
+
+  tempList.clear();
+
   // uninitialize all invocation handlers and then remove them
   for (LanguageInvocationHandlerMap::iterator it = m_invocationHandlers.begin(); it != m_invocationHandlers.end(); ++it)
     it->second->Uninitialize();
diff --git a/xbmc/interfaces/python/PythonInvoker.cpp b/xbmc/interfaces/python/PythonInvoker.cpp
index 44874b41ee4c..aae46e9a8b73 100644
--- a/xbmc/interfaces/python/PythonInvoker.cpp
+++ b/xbmc/interfaces/python/PythonInvoker.cpp
@@ -434,7 +434,6 @@ bool CPythonInvoker::stop(bool abort)
 
   if (m_threadState != NULL)
   {
-    PyThreadState* old(nullptr);
     if (IsRunning())
     {
       setState(InvokerStateStopping);
@@ -442,11 +441,14 @@ bool CPythonInvoker::stop(bool abort)
       lock.Leave();
 
       PyEval_AcquireLock();
-      old = PyThreadState_Swap((PyThreadState*)m_threadState);
+      PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
 
       //tell xbmc.Monitor to call onAbortRequested()
-      if (m_addon != NULL)
+      if (m_addon)
+      {
+        CLog::Log(LOGDEBUG, "CPythonInvoker(%d, %s): trigger Monitor abort request", GetId(), m_sourceFile.c_str());
         onAbortRequested();
+      }
 
       PyObject *m;
       m = PyImport_AddModule((char*)"xbmc");
@@ -454,7 +456,6 @@ bool CPythonInvoker::stop(bool abort)
         CLog::Log(LOGERROR, "CPythonInvoker(%d, %s): failed to set abortRequested", GetId(), m_sourceFile.c_str());
 
       PyThreadState_Swap(old);
-      old = NULL;
       PyEval_ReleaseLock();
     }
     else
@@ -494,7 +495,7 @@ bool CPythonInvoker::stop(bool abort)
     // so we need to recheck for m_threadState == NULL
     if (m_threadState != NULL)
     {
-      old = PyThreadState_Swap((PyThreadState*)m_threadState);
+      PyThreadState* old = PyThreadState_Swap((PyThreadState*)m_threadState);
       for (PyThreadState* state = ((PyThreadState*)m_threadState)->interp->tstate_head; state; state = state->next)
       {
         // Raise a SystemExit exception in python threads
@@ -502,15 +503,12 @@ bool CPythonInvoker::stop(bool abort)
         state->async_exc = PyExc_SystemExit;
         Py_XINCREF(state->async_exc);
       }
+      PyThreadState_Swap(old);
 
       // If a dialog entered its doModal(), we need to wake it to see the exception
       pulseGlobalEvent();
       m_threadState = nullptr;
     }
-
-    if (old != NULL)
-      PyThreadState_Swap(old);
-
     lock.Leave();
     PyEval_ReleaseLock();
 
