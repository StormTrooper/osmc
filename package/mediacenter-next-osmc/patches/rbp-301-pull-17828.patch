From 2e33eb967384310f25c17744c2b88a6f8d94bdb5 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 5 May 2020 20:28:48 +0200
Subject: [PATCH 01/10] [utils] CScraperUrl: remove unused m_spoof

---
 xbmc/utils/ScraperUrl.cpp   | 1 -
 xbmc/utils/ScraperUrl.h     | 1 -
 xbmc/video/VideoDatabase.h  | 8 ++++----
 xbmc/video/VideoInfoTag.cpp | 2 --
 4 files changed, 4 insertions(+), 8 deletions(-)

diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index 5e2baad7aade..c644ca4bd178 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -49,7 +49,6 @@ CScraperUrl::~CScraperUrl() = default;
 void CScraperUrl::Clear()
 {
   m_url.clear();
-  m_spoof.clear();
   m_xml.clear();
   relevance = 0;
 }
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 39a47328248d..61ab080a8cc8 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -69,7 +69,6 @@ class CScraperUrl
                  const std::string& cacheContext);
 
   std::string m_xml;
-  std::string m_spoof; // for backwards compatibility only!
   std::string strTitle;
   std::string strId;
   double relevance;
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index 8356a3d139e2..de21a3c2d634 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -215,7 +215,7 @@ const struct SDbTableOffsets
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_genre) },
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_director) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strOriginalTitle) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_spoof) },
+  { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_studio) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strTrailer) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_fanart.m_xml) },
@@ -256,7 +256,7 @@ const struct SDbTableOffsets DbTvShowOffsets[] =
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdRating) },
   { VIDEODB_TYPE_DATE, my_offsetof(CVideoInfoTag,m_premiered) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_spoof) },
+  { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_genre) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strOriginalTitle)},
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strEpisodeGuide)},
@@ -326,7 +326,7 @@ const struct SDbTableOffsets DbEpisodeOffsets[] =
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_writingCredits) },
   { VIDEODB_TYPE_DATE, my_offsetof(CVideoInfoTag,m_firstAired) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_spoof) },
+  { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_duration) },
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_director) },
@@ -367,7 +367,7 @@ const struct SDbTableOffsets DbMusicVideoOffsets[] =
 {
   { VIDEODB_TYPE_STRING, my_offsetof(class CVideoInfoTag,m_strTitle) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_spoof) },
+  { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_duration) },
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_director) },
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 80c1a4639dcd..b4c8cb4901d6 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -332,7 +332,6 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar << m_strTagLine;
     ar << m_strPlotOutline;
     ar << m_strPlot;
-    ar << m_strPictureURL.m_spoof;
     ar << m_strPictureURL.m_xml;
     ar << m_fanart.m_xml;
     ar << m_strTitle;
@@ -427,7 +426,6 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar >> m_strTagLine;
     ar >> m_strPlotOutline;
     ar >> m_strPlot;
-    ar >> m_strPictureURL.m_spoof;
     ar >> m_strPictureURL.m_xml;
     ar >> m_fanart.m_xml;
     ar >> m_strTitle;

From 50f59f9d58f993a3680fee95ab0a11fb8218744e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 14 May 2020 09:45:47 +0200
Subject: [PATCH 02/10] [utils] CScraperUrl: follow coding guidelines

---
 xbmc/addons/Scraper.cpp                       |  38 ++--
 xbmc/utils/ScraperUrl.cpp                     | 197 ++++++++++--------
 xbmc/utils/ScraperUrl.h                       |  64 +++---
 xbmc/utils/test/TestScraperUrl.cpp            |   2 +-
 xbmc/video/VideoDatabase.cpp                  |  10 +-
 xbmc/video/VideoInfoScanner.cpp               |  17 +-
 xbmc/video/jobs/VideoLibraryRefreshingJob.cpp |   7 +-
 7 files changed, 185 insertions(+), 150 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index bd9f8277a61e..7bbe9c600174 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -440,7 +440,7 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
       CLog::Log(LOGWARNING, "%s: scraper returned multiple results; using first", __FUNCTION__);
 
     CScraperUrl::SUrlEntry surl;
-    surl.m_type = CScraperUrl::URL_TYPE_GENERAL;
+    surl.m_type = CScraperUrl::UrlType::General;
     surl.m_url = items[0]->GetDynPath();
     scurlRet.m_url.emplace_back(surl);
     return scurlRet;
@@ -487,7 +487,7 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
         pxeUrl = doc.FirstChildElement("url");
       }
       if (pId && pId->FirstChild())
-        scurlRet.strId = pId->FirstChild()->Value();
+        scurlRet.m_id = pId->FirstChild()->Value();
 
       if (pxeUrl && pxeUrl->Attribute("function"))
         continue;
@@ -563,7 +563,7 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
         pxeUrl = doc.FirstChildElement("url");
       }
       if (pId && pId->FirstChild())
-        scurlRet.strId = pId->FirstChild()->Value();
+        scurlRet.m_id = pId->FirstChild()->Value();
 
       if (pxeUrl && pxeUrl->Attribute("function"))
         continue;
@@ -582,7 +582,7 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
 
 static bool RelevanceSortFunction(const CScraperUrl &left, const CScraperUrl &right)
 {
-  return left.relevance > right.relevance;
+  return left.m_relevance > right.m_relevance;
 }
 
 template<class T>
@@ -593,11 +593,11 @@ CScraperUrl FromFileItem<CScraperUrl>(const CFileItem &item)
 {
   CScraperUrl url;
 
-  url.strTitle = item.GetLabel();
+  url.m_title = item.GetLabel();
   if (item.HasProperty("relevance"))
-    url.relevance = item.GetProperty("relevance").asDouble();
+    url.m_relevance = item.GetProperty("relevance").asDouble();
   CScraperUrl::SUrlEntry surl;
-  surl.m_type = CScraperUrl::URL_TYPE_GENERAL;
+  surl.m_type = CScraperUrl::UrlType::General;
   surl.m_url = item.GetDynPath();
   url.m_url.push_back(surl);
 
@@ -935,14 +935,14 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
       TiXmlElement *pxeLink = pxeMovie->FirstChildElement("url");
       if (pxnTitle && pxnTitle->FirstChild() && pxeLink && pxeLink->FirstChild())
       {
-        scurlMovie.strTitle = pxnTitle->FirstChild()->Value();
-        XMLUtils::GetString(pxeMovie, "id", scurlMovie.strId);
+        scurlMovie.m_title = pxnTitle->FirstChild()->Value();
+        XMLUtils::GetString(pxeMovie, "id", scurlMovie.m_id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlMovie.ParseElement(pxeLink);
 
         // calculate the relevance of this hit
-        std::string sCompareTitle = scurlMovie.strTitle;
+        std::string sCompareTitle = scurlMovie.m_title;
         StringUtils::ToLower(sCompareTitle);
         std::string sMatchTitle = sTitle;
         StringUtils::ToLower(sMatchTitle);
@@ -961,18 +961,18 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
           yearScore =
               std::max(0.0, 1 - 0.5 * abs(atoi(sYear.c_str()) - atoi(sCompareYear.c_str())));
 
-        scurlMovie.relevance = fstrcmp(sMatchTitle.c_str(), sCompareTitle.c_str()) + yearScore;
+        scurlMovie.m_relevance = fstrcmp(sMatchTitle.c_str(), sCompareTitle.c_str()) + yearScore;
 
         // reconstruct a title for the user
         if (!sCompareYear.empty())
-          scurlMovie.strTitle += StringUtils::Format(" (%s)", sCompareYear.c_str());
+          scurlMovie.m_title += StringUtils::Format(" (%s)", sCompareYear.c_str());
 
         std::string sLanguage;
         if (XMLUtils::GetString(pxeMovie, "language", sLanguage) && !sLanguage.empty())
-          scurlMovie.strTitle += StringUtils::Format(" (%s)", sLanguage.c_str());
+          scurlMovie.m_title += StringUtils::Format(" (%s)", sLanguage.c_str());
 
         // filter for dupes from naughty scrapers
-        if (stsDupeCheck.insert(scurlMovie.m_url[0].m_url + " " + scurlMovie.strTitle).second)
+        if (stsDupeCheck.insert(scurlMovie.m_url[0].m_url + " " + scurlMovie.m_title).second)
           vcscurl.push_back(scurlMovie);
       }
     }
@@ -1212,7 +1212,7 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
       ep.cDate = tag.m_firstAired;
       ep.iSubepisode = items[i]->GetProperty("video.sub_episode").asInteger();
       CScraperUrl::SUrlEntry surl;
-      surl.m_type = CScraperUrl::URL_TYPE_GENERAL;
+      surl.m_type = CScraperUrl::UrlType::General;
       surl.m_url = items[i]->GetURL().Get();
       ep.cScraperUrl.m_url.push_back(surl);
       vcep.push_back(ep);
@@ -1250,9 +1250,9 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
         size_t dot = strEpNum.find(".");
         ep.iEpisode = atoi(strEpNum.c_str());
         ep.iSubepisode = (dot != std::string::npos) ? atoi(strEpNum.substr(dot + 1).c_str()) : 0;
-        if (!XMLUtils::GetString(pxeMovie, "title", scurlEp.strTitle) || scurlEp.strTitle.empty())
-          scurlEp.strTitle = g_localizeStrings.Get(10005); // Not available
-        XMLUtils::GetString(pxeMovie, "id", scurlEp.strId);
+        if (!XMLUtils::GetString(pxeMovie, "title", scurlEp.m_title) || scurlEp.m_title.empty())
+          scurlEp.m_title = g_localizeStrings.Get(10005); // Not available
+        XMLUtils::GetString(pxeMovie, "id", scurlEp.m_id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlEp.ParseElement(pxeLink);
@@ -1295,7 +1295,7 @@ bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl,
 
   std::string sFunc = fMovie ? "GetDetails" : "GetEpisodeDetails";
   std::vector<std::string> vcsIn;
-  vcsIn.push_back(scurl.strId);
+  vcsIn.push_back(scurl.m_id);
   vcsIn.push_back(scurl.m_url[0].m_url);
   std::vector<std::string> vcsOut = RunNoThrow(sFunc, scurl, fcurl, &vcsIn);
 
diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index c644ca4bd178..73c1c77ef5b5 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -27,21 +27,18 @@
 #include <cstring>
 #include <sstream>
 
-CScraperUrl::CScraperUrl(const std::string& strUrl)
+CScraperUrl::CScraperUrl() : m_relevance(0.0)
 {
-  relevance = 0;
-  ParseString(strUrl);
 }
 
-CScraperUrl::CScraperUrl(const TiXmlElement* element)
+CScraperUrl::CScraperUrl(std::string strUrl) : CScraperUrl()
 {
-  relevance = 0;
-  ParseElement(element);
+  ParseString(std::move(strUrl));
 }
 
-CScraperUrl::CScraperUrl()
+CScraperUrl::CScraperUrl(const TiXmlElement* element) : CScraperUrl()
 {
-  relevance = 0;
+  ParseElement(element);
 }
 
 CScraperUrl::~CScraperUrl() = default;
@@ -50,20 +47,20 @@ void CScraperUrl::Clear()
 {
   m_url.clear();
   m_xml.clear();
-  relevance = 0;
+  m_relevance = 0.0;
 }
 
 bool CScraperUrl::Parse()
 {
-  std::string strToParse = m_xml;
+  auto strToParse = m_xml;
   m_xml.clear();
-  return ParseString(strToParse);
+  return ParseString(std::move(strToParse));
 }
 
 bool CScraperUrl::ParseElement(const TiXmlElement* element)
 {
-  if (!element || !element->FirstChild() ||
-      !element->FirstChild()->Value()) return false;
+  if (!element || !element->FirstChild() || !element->FirstChild()->Value())
+    return false;
 
   std::stringstream stream;
   stream << *element;
@@ -72,12 +69,12 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
   SUrlEntry url;
   url.m_url = element->FirstChild()->Value();
   url.m_spoof = XMLUtils::GetAttribute(element, "spoof");
-  const char* szPost=element->Attribute("post");
+  const char* szPost = element->Attribute("post");
   if (szPost && StringUtils::CompareNoCase(szPost, "yes") == 0)
     url.m_post = true;
   else
     url.m_post = false;
-  const char* szIsGz=element->Attribute("gzip");
+  const char* szIsGz = element->Attribute("gzip");
   if (szIsGz && StringUtils::CompareNoCase(szIsGz, "yes") == 0)
     url.m_isgz = true;
   else
@@ -85,11 +82,11 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
   url.m_cache = XMLUtils::GetAttribute(element, "cache");
 
   const char* szType = element->Attribute("type");
-  url.m_type = URL_TYPE_GENERAL;
+  url.m_type = UrlType::General;
   url.m_season = -1;
   if (szType && StringUtils::CompareNoCase(szType, "season") == 0)
   {
-    url.m_type = URL_TYPE_SEASON;
+    url.m_type = UrlType::Season;
     const char* szSeason = element->Attribute("season");
     if (szSeason)
       url.m_season = atoi(szSeason);
@@ -111,12 +108,12 @@ bool CScraperUrl::ParseString(std::string strUrl)
    * so strUrl is always in UTF-8 */
   doc.Parse(strUrl, TIXML_ENCODING_UTF8);
 
-  TiXmlElement* pElement = doc.RootElement();
-  if (!pElement)
+  auto pElement = doc.RootElement();
+  if (pElement == nullptr)
   {
     SUrlEntry url;
     url.m_url = strUrl;
-    url.m_type = URL_TYPE_GENERAL;
+    url.m_type = UrlType::General;
     url.m_season = -1;
     url.m_post = false;
     url.m_isgz = false;
@@ -125,7 +122,7 @@ bool CScraperUrl::ParseString(std::string strUrl)
   }
   else
   {
-    while (pElement)
+    while (pElement != nullptr)
     {
       ParseElement(pElement);
       pElement = pElement->NextSiblingElement(pElement->Value());
@@ -135,51 +132,45 @@ bool CScraperUrl::ParseString(std::string strUrl)
   return true;
 }
 
-const CScraperUrl::SUrlEntry CScraperUrl::GetFirstThumb(const std::string &type) const
+const CScraperUrl::SUrlEntry CScraperUrl::GetFirstThumb(const std::string& type) const
 {
-  for (std::vector<SUrlEntry>::const_iterator iter=m_url.begin();iter != m_url.end();++iter)
-  {
-    if (iter->m_type == URL_TYPE_GENERAL && (type.empty() || iter->m_aspect == type))
-      return *iter;
-  }
+  const auto url = std::find_if(m_url.begin(), m_url.end(), [type](const SUrlEntry& url) {
+    return url.m_type == UrlType::General && (type.empty() || url.m_aspect == type);
+  });
+  if (url != m_url.end())
+    return *url;
 
-  SUrlEntry result;
-  result.m_type = URL_TYPE_GENERAL;
-  result.m_post = false;
-  result.m_isgz = false;
-  result.m_season = -1;
-  return result;
+  return {};
 }
 
-const CScraperUrl::SUrlEntry CScraperUrl::GetSeasonThumb(int season, const std::string &type) const
+const CScraperUrl::SUrlEntry CScraperUrl::GetSeasonThumb(int season, const std::string& type) const
 {
-  for (std::vector<SUrlEntry>::const_iterator iter=m_url.begin();iter != m_url.end();++iter)
-  {
-    if (iter->m_type == URL_TYPE_SEASON && iter->m_season == season &&
-       (type.empty() || type == "thumb" || iter->m_aspect == type))
-      return *iter;
-  }
-
-  SUrlEntry result;
-  result.m_type = URL_TYPE_GENERAL;
-  result.m_post = false;
-  result.m_isgz = false;
-  result.m_season = -1;
-  return result;
+  const auto url = std::find_if(m_url.begin(), m_url.end(), [season, type](const SUrlEntry& url) {
+    return url.m_type == UrlType::Season && url.m_season == season &&
+           (type.empty() || type == "thumb" || url.m_aspect == type);
+  });
+  if (url != m_url.end())
+    return *url;
+
+  return {};
 }
 
 unsigned int CScraperUrl::GetMaxSeasonThumb() const
 {
   unsigned int maxSeason = 0;
-  for (std::vector<SUrlEntry>::const_iterator iter=m_url.begin();iter != m_url.end();++iter)
+  for (const auto& url : m_url)
   {
-    if (iter->m_type == URL_TYPE_SEASON && iter->m_season > 0 && (unsigned int)iter->m_season > maxSeason)
-      maxSeason = iter->m_season;
+    if (url.m_type == UrlType::Season && url.m_season > 0 &&
+        static_cast<unsigned int>(url.m_season) > maxSeason)
+      maxSeason = url.m_season;
   }
   return maxSeason;
 }
 
-bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCurlFile& http, const std::string& cacheContext)
+bool CScraperUrl::Get(const SUrlEntry& scrURL,
+                      std::string& strHTML,
+                      XFILE::CCurlFile& http,
+                      const std::string& cacheContext)
 {
   CURL url(scrURL.m_url);
   http.SetReferer(scrURL.m_spoof);
@@ -187,8 +178,9 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
 
   if (!scrURL.m_cache.empty())
   {
-    strCachePath = URIUtils::AddFileToFolder(CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_cachePath,
-                              "scrapers", cacheContext, scrURL.m_cache);
+    strCachePath = URIUtils::AddFileToFolder(
+        CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_cachePath, "scrapers",
+        cacheContext, scrURL.m_cache);
     if (XFILE::CFile::Exists(strCachePath))
     {
       XFILE::CFile file;
@@ -201,7 +193,7 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
     }
   }
 
-  std::string strHTML1(strHTML);
+  auto strHTML1 = strHTML;
 
   if (scrURL.m_post)
   {
@@ -212,13 +204,12 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
     if (!http.Post(url.Get(), strOptions, strHTML1))
       return false;
   }
-  else
-    if (!http.Get(url.Get(), strHTML1))
-      return false;
+  else if (!http.Get(url.Get(), strHTML1))
+    return false;
 
   strHTML = strHTML1;
 
-  std::string mimeType(http.GetProperty(XFILE::FILE_PROPERTY_MIME_TYPE));
+  const auto mimeType = http.GetProperty(XFILE::FILE_PROPERTY_MIME_TYPE);
   CMime::EFileType ftype = CMime::GetFileTypeFromMime(mimeType);
   if (ftype == CMime::FileTypeUnknown)
     ftype = CMime::GetFileTypeFromContent(strHTML);
@@ -227,24 +218,29 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
   {
     XFILE::CZipFile file;
     std::string strBuffer;
-    int iSize = file.UnpackFromMemory(strBuffer,strHTML,scrURL.m_isgz); // FIXME: use FileTypeGZip instead of scrURL.m_isgz?
+    auto iSize = file.UnpackFromMemory(
+        strBuffer, strHTML, scrURL.m_isgz); // FIXME: use FileTypeGZip instead of scrURL.m_isgz?
     if (iSize > 0)
     {
       strHTML = strBuffer;
-      CLog::Log(LOGDEBUG, "%s: Archive \"%s\" was unpacked in memory", __FUNCTION__, scrURL.m_url.c_str());
+      CLog::Log(LOGDEBUG, "{}: Archive \"{}\" was unpacked in memory", __FUNCTION__, scrURL.m_url);
     }
     else
-      CLog::Log(LOGWARNING, "%s: \"%s\" looks like archive, but cannot be unpacked", __FUNCTION__, scrURL.m_url.c_str());
+      CLog::Log(LOGWARNING, "{}: \"{}\" looks like archive but cannot be unpacked", __FUNCTION__,
+                scrURL.m_url);
   }
 
-  std::string reportedCharset(http.GetProperty(XFILE::FILE_PROPERTY_CONTENT_CHARSET));
+  const auto reportedCharset = http.GetProperty(XFILE::FILE_PROPERTY_CONTENT_CHARSET);
   if (ftype == CMime::FileTypeHtml)
   {
     std::string realHtmlCharset, converted;
     if (!CCharsetDetection::ConvertHtmlToUtf8(strHTML, converted, reportedCharset, realHtmlCharset))
-      CLog::Log(LOGWARNING, "%s: Can't find precise charset for HTML \"%s\", using \"%s\" as fallback", __FUNCTION__, scrURL.m_url.c_str(), realHtmlCharset.c_str());
+      CLog::Log(LOGWARNING,
+                "{}: Can't find precise charset for HTML \"{}\", using \"{}\" as fallback",
+                __FUNCTION__, scrURL.m_url, realHtmlCharset);
     else
-      CLog::Log(LOGDEBUG, "%s: Using \"%s\" charset for HTML \"%s\"", __FUNCTION__, realHtmlCharset.c_str(), scrURL.m_url.c_str());
+      CLog::Log(LOGDEBUG, "{}: Using \"{}\" charset for HTML \"{}\"", __FUNCTION__, realHtmlCharset,
+                scrURL.m_url);
 
     strHTML = converted;
   }
@@ -253,28 +249,36 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
     CXBMCTinyXML xmlDoc;
     xmlDoc.Parse(strHTML, reportedCharset);
 
-    std::string realXmlCharset(xmlDoc.GetUsedCharset());
+    const auto realXmlCharset = xmlDoc.GetUsedCharset();
     if (!realXmlCharset.empty())
     {
-      CLog::Log(LOGDEBUG, "%s: Using \"%s\" charset for XML \"%s\"", __FUNCTION__, realXmlCharset.c_str(), scrURL.m_url.c_str());
+      CLog::Log(LOGDEBUG, "{}: Using \"{}\" charset for XML \"{}\"", __FUNCTION__, realXmlCharset,
+                scrURL.m_url);
       std::string converted;
       g_charsetConverter.ToUtf8(realXmlCharset, strHTML, converted);
       strHTML = converted;
     }
   }
-  else if (ftype == CMime::FileTypePlainText || StringUtils::EqualsNoCase(mimeType.substr(0, 5), "text/"))
+  else if (ftype == CMime::FileTypePlainText ||
+           StringUtils::EqualsNoCase(mimeType.substr(0, 5), "text/"))
   {
-    std::string realTextCharset, converted;
+    std::string realTextCharset;
+    std::string converted;
     CCharsetDetection::ConvertPlainTextToUtf8(strHTML, converted, reportedCharset, realTextCharset);
     strHTML = converted;
     if (reportedCharset != realTextCharset)
-      CLog::Log(LOGWARNING, "%s: Using \"%s\" charset for plain text \"%s\" instead of server reported \"%s\" charset", __FUNCTION__, realTextCharset.c_str(), scrURL.m_url.c_str(), reportedCharset.c_str());
+      CLog::Log(LOGWARNING,
+                "{}: Using \"{}\" charset for plain text \"{}\" instead of server reported \"{}\" "
+                "charset",
+                __FUNCTION__, realTextCharset, scrURL.m_url, reportedCharset);
     else
-      CLog::Log(LOGDEBUG, "%s: Using \"%s\" charset for plain text \"%s\"", __FUNCTION__, realTextCharset.c_str(), scrURL.m_url.c_str());
+      CLog::Log(LOGDEBUG, "{}: Using \"{}\" charset for plain text \"{}\"", __FUNCTION__,
+                realTextCharset, scrURL.m_url);
   }
   else if (!reportedCharset.empty())
   {
-    CLog::Log(LOGDEBUG, "%s: Using \"%s\" charset for \"%s\"", __FUNCTION__, reportedCharset.c_str(), scrURL.m_url.c_str());
+    CLog::Log(LOGDEBUG, "{}: Using \"{}\" charset for \"{}\"", __FUNCTION__, reportedCharset,
+              scrURL.m_url);
     if (reportedCharset != "UTF-8")
     {
       std::string converted;
@@ -283,14 +287,17 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL, std::string& strHTML, XFILE::CCur
     }
   }
   else
-    CLog::Log(LOGDEBUG, "%s: Using content of \"%s\" as binary or text with \"UTF-8\" charset", __FUNCTION__, scrURL.m_url.c_str());
+    CLog::Log(LOGDEBUG, "{}: Using content of \"{}\" as binary or text with \"UTF-8\" charset",
+              __FUNCTION__, scrURL.m_url);
 
   if (!scrURL.m_cache.empty())
   {
-    std::string strCachePath = URIUtils::AddFileToFolder(CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_cachePath,
-                              "scrapers", cacheContext, scrURL.m_cache);
+    const auto strCachePath = URIUtils::AddFileToFolder(
+        CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_cachePath, "scrapers",
+        cacheContext, scrURL.m_cache);
     XFILE::CFile file;
-    if (!file.OpenForWrite(strCachePath, true) || file.Write(strHTML.data(), strHTML.size()) != static_cast<ssize_t>(strHTML.size()))
+    if (!file.OpenForWrite(strCachePath, true) ||
+        file.Write(strHTML.data(), strHTML.size()) != static_cast<ssize_t>(strHTML.size()))
       return false;
   }
   return true;
@@ -307,10 +314,10 @@ bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
   CXBMCTinyXML doc;
   /* strUrls is coming from internal sources so strUrls is always in UTF-8 */
   doc.Parse(strUrls, TIXML_ENCODING_UTF8);
-  if (doc.RootElement())
+  if (doc.RootElement() != nullptr)
   {
-    TiXmlHandle docHandle( &doc );
-    TiXmlElement *link = docHandle.FirstChild("episodeguide").Element();
+    TiXmlHandle docHandle(&doc);
+    auto link = docHandle.FirstChild("episodeguide").Element();
     if (link->FirstChildElement("url"))
     {
       for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
@@ -325,7 +332,14 @@ bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
   return true;
 }
 
-void CScraperUrl::AddElement(std::string url, std::string aspect, std::string preview, std::string referrer, std::string cache, bool post, bool isgz, int season)
+void CScraperUrl::AddElement(std::string url,
+                             std::string aspect,
+                             std::string preview,
+                             std::string referrer,
+                             std::string cache,
+                             bool post,
+                             bool isgz,
+                             int season)
 {
   TiXmlElement thumb("thumb");
   thumb.SetAttribute("spoof", referrer);
@@ -352,18 +366,18 @@ void CScraperUrl::AddElement(std::string url, std::string aspect, std::string pr
   nUrl.m_cache = cache;
   if (season >= 0)
   {
-    nUrl.m_type = URL_TYPE_SEASON;
+    nUrl.m_type = UrlType::Season;
     nUrl.m_season = season;
   }
   else
-    nUrl.m_type = URL_TYPE_GENERAL;
+    nUrl.m_type = UrlType::General;
 
   nUrl.m_aspect = aspect;
 
   m_url.push_back(nUrl);
 }
 
-std::string CScraperUrl::GetThumbURL(const CScraperUrl::SUrlEntry &entry)
+std::string CScraperUrl::GetThumbURL(const CScraperUrl::SUrlEntry& entry)
 {
   if (entry.m_spoof.empty())
     return entry.m_url;
@@ -371,18 +385,21 @@ std::string CScraperUrl::GetThumbURL(const CScraperUrl::SUrlEntry &entry)
   return entry.m_url + "|Referer=" + CURL::Encode(entry.m_spoof);
 }
 
-void CScraperUrl::GetThumbURLs(std::vector<std::string> &thumbs, const std::string &type, int season, bool unique) const
+void CScraperUrl::GetThumbURLs(std::vector<std::string>& thumbs,
+                               const std::string& type,
+                               int season,
+                               bool unique) const
 {
-  for (std::vector<SUrlEntry>::const_iterator iter = m_url.begin(); iter != m_url.end(); ++iter)
+  for (const auto& url : m_url)
   {
-    if (iter->m_aspect == type || type.empty() || iter->m_aspect.empty())
+    if (url.m_aspect == type || type.empty() || url.m_aspect.empty())
     {
-      if ((iter->m_type == CScraperUrl::URL_TYPE_GENERAL && season == -1)
-       || (iter->m_type == CScraperUrl::URL_TYPE_SEASON && iter->m_season == season))
+      if ((url.m_type == CScraperUrl::UrlType::General && season == -1) ||
+          (url.m_type == CScraperUrl::UrlType::Season && url.m_season == season))
       {
-        std::string url = GetThumbURL(*iter);
-        if (!unique || std::find(thumbs.begin(), thumbs.end(), url) == thumbs.end())
-          thumbs.push_back(url);
+        std::string thumbUrl = GetThumbURL(url);
+        if (!unique || std::find(thumbs.begin(), thumbs.end(), thumbUrl) == thumbs.end())
+          thumbs.push_back(thumbUrl);
       }
     }
   }
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 61ab080a8cc8..51663124e574 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -13,65 +13,81 @@
 #include <vector>
 
 class TiXmlElement;
-namespace XFILE { class CCurlFile; }
+namespace XFILE
+{
+class CCurlFile;
+}
 
 class CScraperUrl
 {
 public:
-  explicit CScraperUrl(const std::string&);
-  explicit CScraperUrl(const TiXmlElement*);
-  CScraperUrl();
-  ~CScraperUrl();
-
-  enum URLTYPES
+  enum class UrlType
   {
-    URL_TYPE_GENERAL = 1,
-    URL_TYPE_SEASON = 2
+    General = 1,
+    Season = 2
   };
 
   struct SUrlEntry
   {
+    SUrlEntry() : m_type(UrlType::General), m_post(false), m_isgz(false), m_season(-1) {}
+
     std::string m_spoof;
     std::string m_url;
     std::string m_cache;
     std::string m_aspect;
-    URLTYPES m_type;
+    UrlType m_type;
     bool m_post;
     bool m_isgz;
     int m_season;
   };
 
+  CScraperUrl();
+  explicit CScraperUrl(std::string strUrl);
+  explicit CScraperUrl(const TiXmlElement* element);
+  ~CScraperUrl();
+
   bool Parse();
-  bool ParseString(std::string); // copies by intention
-  bool ParseElement(const TiXmlElement*);
+  bool ParseString(std::string strUrl); // copies by intention
+  bool ParseElement(const TiXmlElement* element);
   bool ParseEpisodeGuide(std::string strUrls); // copies by intention
-  void AddElement(std::string url, std::string aspect = "", std::string preview = "", std::string referrer = "", std::string cache = "", bool post = false, bool isgz = false, int season = -1);
+  void AddElement(std::string url,
+                  std::string aspect = "",
+                  std::string preview = "",
+                  std::string referrer = "",
+                  std::string cache = "",
+                  bool post = false,
+                  bool isgz = false,
+                  int season = -1);
 
-  const SUrlEntry GetFirstThumb(const std::string &type = "") const;
-  const SUrlEntry GetSeasonThumb(int season, const std::string &type = "") const;
+  const SUrlEntry GetFirstThumb(const std::string& type = "") const;
+  const SUrlEntry GetSeasonThumb(int season, const std::string& type = "") const;
   unsigned int GetMaxSeasonThumb() const;
 
   /*! \brief fetch the full URL (including referrer) of a thumb
    \param URL entry to use to create the full URL
    \return the full URL, including referrer
    */
-  static std::string GetThumbURL(const CScraperUrl::SUrlEntry &entry);
+  static std::string GetThumbURL(const CScraperUrl::SUrlEntry& entry);
 
-  /*! \brief fetch the full URL (including referrer) of thumbs
+  /*! \brief fetch the full URLs (including referrer) of thumbs
    \param thumbs [out] vector of thumb URLs to fill
    \param type the type of thumb URLs to fetch, if empty (the default) picks any
    \param season number of season that we want thumbs for, -1 indicates no season (the default)
    \param unique avoid adding duplicate URLs when adding to a thumbs vector with existing items
    */
-  void GetThumbURLs(std::vector<std::string> &thumbs, const std::string &type = "", int season = -1, bool unique = false) const;
+  void GetThumbURLs(std::vector<std::string>& thumbs,
+                    const std::string& type = "",
+                    int season = -1,
+                    bool unique = false) const;
   void Clear();
-  static bool Get(const SUrlEntry&, std::string&, XFILE::CCurlFile& http,
-                 const std::string& cacheContext);
+  static bool Get(const SUrlEntry& scrURL,
+                  std::string& strHTML,
+                  XFILE::CCurlFile& http,
+                  const std::string& cacheContext);
 
   std::string m_xml;
-  std::string strTitle;
-  std::string strId;
-  double relevance;
+  std::string m_title;
+  std::string m_id;
+  double m_relevance;
   std::vector<SUrlEntry> m_url;
 };
-
diff --git a/xbmc/utils/test/TestScraperUrl.cpp b/xbmc/utils/test/TestScraperUrl.cpp
index 103777712bb6..521d40ca07d4 100644
--- a/xbmc/utils/test/TestScraperUrl.cpp
+++ b/xbmc/utils/test/TestScraperUrl.cpp
@@ -26,7 +26,7 @@ TEST(TestScraperUrl, General)
   EXPECT_STREQ("blah", a.GetFirstThumb().m_spoof.c_str());
   EXPECT_STREQ("someurl", a.GetFirstThumb().m_url.c_str());
   EXPECT_STREQ("", a.GetFirstThumb().m_cache.c_str());
-  EXPECT_EQ(CScraperUrl::URL_TYPE_GENERAL, a.GetFirstThumb().m_type);
+  EXPECT_EQ(CScraperUrl::UrlType::General, a.GetFirstThumb().m_type);
   EXPECT_FALSE(a.GetFirstThumb().m_post);
   EXPECT_TRUE(a.GetFirstThumb().m_isgz);
   EXPECT_EQ(-1, a.GetFirstThumb().m_season);
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 36f2f359f8b3..facb15cece30 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4778,9 +4778,9 @@ std::vector<std::string> GetBasicItemAvailableArtTypes(const CVideoInfoTag& tag)
     std::string artType = urlEntry.m_aspect;
     if (artType.empty())
       artType = tag.m_type == MediaTypeEpisode ? "thumb" : "poster";
-    if (urlEntry.m_type == CScraperUrl::URL_TYPE_GENERAL && // exclude season artwork for TV shows
-      !StringUtils::StartsWith(artType, "set.") && // exclude movie set artwork for movies
-      std::find(result.cbegin(), result.cend(), artType) == result.cend())
+    if (urlEntry.m_type == CScraperUrl::UrlType::General && // exclude season artwork for TV shows
+        !StringUtils::StartsWith(artType, "set.") && // exclude movie set artwork for movies
+        std::find(result.cbegin(), result.cend(), artType) == result.cend())
     {
       result.push_back(artType);
     }
@@ -4802,8 +4802,8 @@ std::vector<std::string> GetSeasonAvailableArtTypes(int mediaId, CVideoDatabase&
     std::string artType = urlEntry.m_aspect;
     if (artType.empty())
       artType = "poster";
-    if (urlEntry.m_type == CScraperUrl::URL_TYPE_SEASON && urlEntry.m_season == tag.m_iSeason &&
-      std::find(result.cbegin(), result.cend(), artType) == result.cend())
+    if (urlEntry.m_type == CScraperUrl::UrlType::Season && urlEntry.m_season == tag.m_iSeason &&
+        std::find(result.cbegin(), result.cend(), artType) == result.cend())
     {
       result.push_back(artType);
     }
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index c41f2f3a4a7f..feb5045ffc55 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1556,7 +1556,7 @@ namespace VIDEO
     // add online art
     for (const auto& url : pItem->GetVideoInfoTag()->m_strPictureURL.m_url)
     {
-      if (url.m_type != CScraperUrl::URLTYPES::URL_TYPE_GENERAL)
+      if (url.m_type != CScraperUrl::UrlType::General)
         continue;
       std::string aspect = url.m_aspect;
       if (aspect.empty())
@@ -1729,7 +1729,8 @@ namespace VIDEO
           matches.push_back(*guide);
           continue;
         }
-        if (!guide->cScraperUrl.strTitle.empty() && StringUtils::EqualsNoCase(guide->cScraperUrl.strTitle, file->strTitle))
+        if (!guide->cScraperUrl.m_title.empty() &&
+            StringUtils::EqualsNoCase(guide->cScraperUrl.m_title, file->strTitle))
         {
           bFound = true;
           break;
@@ -1765,8 +1766,8 @@ namespace VIDEO
           std::vector<std::string> titles;
           for (guide = candidates->begin(); guide != candidates->end(); ++guide)
           {
-            StringUtils::ToLower(guide->cScraperUrl.strTitle);
-            titles.push_back(guide->cScraperUrl.strTitle);
+            StringUtils::ToLower(guide->cScraperUrl.m_title);
+            titles.push_back(guide->cScraperUrl.m_title);
           }
 
           double matchscore;
@@ -1817,8 +1818,8 @@ namespace VIDEO
   {
     CVideoInfoTag movieDetails;
 
-    if (m_handle && !url.strTitle.empty())
-      m_handle->SetText(url.strTitle);
+    if (m_handle && !url.m_title.empty())
+      m_handle->SetText(url.m_title);
 
     CVideoInfoDownloader imdb(scraper);
     bool ret = imdb.GetDetails(url, movieDetails, pDialog);
@@ -1828,7 +1829,7 @@ namespace VIDEO
       if (loader)
         loader->Load(movieDetails, true);
 
-      if (m_handle && url.strTitle.empty())
+      if (m_handle && url.m_title.empty())
         m_handle->SetText(movieDetails.m_strTitle);
 
       if (pDialog)
@@ -2029,7 +2030,7 @@ namespace VIDEO
     // add online art
     for (const auto& url : show.m_strPictureURL.m_url)
     {
-      if (url.m_type != CScraperUrl::URLTYPES::URL_TYPE_SEASON)
+      if (url.m_type != CScraperUrl::UrlType::Season)
         continue;
       std::string aspect = url.m_aspect;
       if (aspect.empty())
diff --git a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
index 874037261998..ac8f73efbdca 100644
--- a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
+++ b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
@@ -188,7 +188,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
             selectDialog->Reset();
             selectDialog->SetHeading(scraper->Content() == CONTENT_TVSHOWS ? 20356 : 196);
             for (const auto& itemResult : itemResultList)
-              selectDialog->Add(itemResult.strTitle);
+              selectDialog->Add(itemResult.m_title);
             selectDialog->EnableButton(true, 413); // "Manual"
             selectDialog->Open();
 
@@ -212,7 +212,8 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
               return false;
           }
 
-          CLog::Log(LOGDEBUG, "CVideoLibraryRefreshingJob: user selected item '%s' with URL '%s'", scraperUrl.strTitle.c_str(), scraperUrl.m_url.at(0).m_url.c_str());
+          CLog::Log(LOGDEBUG, "CVideoLibraryRefreshingJob: user selected item '%s' with URL '%s'",
+                    scraperUrl.m_title.c_str(), scraperUrl.m_url.at(0).m_url.c_str());
         }
       }
       else if (result < 0 || !VIDEO::CVideoInfoScanner::DownloadFailed(GetProgressDialog()))
@@ -296,7 +297,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
 
     // prepare the progress dialog for downloading all the necessary information
     SetTitle(g_localizeStrings.Get(headingLabel));
-    SetText(scraperUrl.strTitle);
+    SetText(scraperUrl.m_title);
     SetProgress(0);
 
     // remove any existing data for the item we're going to refresh

From 82188bd1c8df2b1c8474925a84d19a40f7445e4e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Tue, 5 May 2020 23:50:32 +0200
Subject: [PATCH 03/10] [utils] CScraperUrl: add Get/SetRelevance()

---
 xbmc/addons/Scraper.cpp | 6 +++---
 xbmc/utils/ScraperUrl.h | 7 ++++++-
 2 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 7bbe9c600174..2c015535a3a7 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -582,7 +582,7 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
 
 static bool RelevanceSortFunction(const CScraperUrl &left, const CScraperUrl &right)
 {
-  return left.m_relevance > right.m_relevance;
+  return left.GetRelevance() > right.GetRelevance();
 }
 
 template<class T>
@@ -595,7 +595,7 @@ CScraperUrl FromFileItem<CScraperUrl>(const CFileItem &item)
 
   url.m_title = item.GetLabel();
   if (item.HasProperty("relevance"))
-    url.m_relevance = item.GetProperty("relevance").asDouble();
+    url.SetRelevance(item.GetProperty("relevance").asDouble());
   CScraperUrl::SUrlEntry surl;
   surl.m_type = CScraperUrl::UrlType::General;
   surl.m_url = item.GetDynPath();
@@ -961,7 +961,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
           yearScore =
               std::max(0.0, 1 - 0.5 * abs(atoi(sYear.c_str()) - atoi(sCompareYear.c_str())));
 
-        scurlMovie.m_relevance = fstrcmp(sMatchTitle.c_str(), sCompareTitle.c_str()) + yearScore;
+        scurlMovie.SetRelevance(fstrcmp(sMatchTitle.c_str(), sCompareTitle.c_str()) + yearScore);
 
         // reconstruct a title for the user
         if (!sCompareYear.empty())
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 51663124e574..7b68e27bb4f0 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -46,6 +46,9 @@ class CScraperUrl
   explicit CScraperUrl(const TiXmlElement* element);
   ~CScraperUrl();
 
+  double GetRelevance() const { return m_relevance; }
+  void SetRelevance(double relevance) { m_relevance = relevance; }
+
   bool Parse();
   bool ParseString(std::string strUrl); // copies by intention
   bool ParseElement(const TiXmlElement* element);
@@ -88,6 +91,8 @@ class CScraperUrl
   std::string m_xml;
   std::string m_title;
   std::string m_id;
-  double m_relevance;
   std::vector<SUrlEntry> m_url;
+
+private:
+  double m_relevance;
 };

From 549c5b06cb069f3566d0ad42b0244698e314be80 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 6 May 2020 00:04:10 +0200
Subject: [PATCH 04/10] [utils] CScraperUrl: add Get/SetTitle()

---
 xbmc/addons/Scraper.cpp                       | 23 +++++++++++--------
 xbmc/utils/ScraperUrl.h                       |  5 +++-
 xbmc/video/VideoInfoScanner.cpp               | 16 +++++++------
 xbmc/video/jobs/VideoLibraryRefreshingJob.cpp |  6 ++---
 4 files changed, 30 insertions(+), 20 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 2c015535a3a7..f39f1c98eb0f 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -593,7 +593,7 @@ CScraperUrl FromFileItem<CScraperUrl>(const CFileItem &item)
 {
   CScraperUrl url;
 
-  url.m_title = item.GetLabel();
+  url.SetTitle(item.GetLabel());
   if (item.HasProperty("relevance"))
     url.SetRelevance(item.GetProperty("relevance").asDouble());
   CScraperUrl::SUrlEntry surl;
@@ -930,19 +930,19 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
     for (TiXmlElement *pxeMovie = xhResults.FirstChild("entity").Element(); pxeMovie;
          pxeMovie = pxeMovie->NextSiblingElement())
     {
-      CScraperUrl scurlMovie;
       TiXmlNode *pxnTitle = pxeMovie->FirstChild("title");
       TiXmlElement *pxeLink = pxeMovie->FirstChildElement("url");
       if (pxnTitle && pxnTitle->FirstChild() && pxeLink && pxeLink->FirstChild())
       {
-        scurlMovie.m_title = pxnTitle->FirstChild()->Value();
+        CScraperUrl scurlMovie;
+        auto title = pxnTitle->FirstChild()->ValueStr();
         XMLUtils::GetString(pxeMovie, "id", scurlMovie.m_id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlMovie.ParseElement(pxeLink);
 
         // calculate the relevance of this hit
-        std::string sCompareTitle = scurlMovie.m_title;
+        std::string sCompareTitle = scurlMovie.GetTitle();
         StringUtils::ToLower(sCompareTitle);
         std::string sMatchTitle = sTitle;
         StringUtils::ToLower(sMatchTitle);
@@ -965,15 +965,18 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
 
         // reconstruct a title for the user
         if (!sCompareYear.empty())
-          scurlMovie.m_title += StringUtils::Format(" (%s)", sCompareYear.c_str());
+          title += StringUtils::Format(" (%s)", sCompareYear.c_str());
 
         std::string sLanguage;
         if (XMLUtils::GetString(pxeMovie, "language", sLanguage) && !sLanguage.empty())
-          scurlMovie.m_title += StringUtils::Format(" (%s)", sLanguage.c_str());
+          title += StringUtils::Format(" (%s)", sLanguage.c_str());
 
         // filter for dupes from naughty scrapers
-        if (stsDupeCheck.insert(scurlMovie.m_url[0].m_url + " " + scurlMovie.m_title).second)
+        if (stsDupeCheck.insert(scurlMovie.m_url[0].m_url + " " + title).second)
+        {
+          scurlMovie.SetTitle(title);
           vcscurl.push_back(scurlMovie);
+        }
       }
     }
   }
@@ -1250,8 +1253,10 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
         size_t dot = strEpNum.find(".");
         ep.iEpisode = atoi(strEpNum.c_str());
         ep.iSubepisode = (dot != std::string::npos) ? atoi(strEpNum.substr(dot + 1).c_str()) : 0;
-        if (!XMLUtils::GetString(pxeMovie, "title", scurlEp.m_title) || scurlEp.m_title.empty())
-          scurlEp.m_title = g_localizeStrings.Get(10005); // Not available
+        std::string title;
+        if (!XMLUtils::GetString(pxeMovie, "title", title) || title.empty())
+          title = g_localizeStrings.Get(10005); // Not available
+        scurlEp.SetTitle(title);
         XMLUtils::GetString(pxeMovie, "id", scurlEp.m_id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 7b68e27bb4f0..93f16c9c5a49 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -46,6 +46,9 @@ class CScraperUrl
   explicit CScraperUrl(const TiXmlElement* element);
   ~CScraperUrl();
 
+  const std::string& GetTitle() const { return m_title; }
+  void SetTitle(std::string title) { m_title = std::move(title); }
+
   double GetRelevance() const { return m_relevance; }
   void SetRelevance(double relevance) { m_relevance = relevance; }
 
@@ -89,10 +92,10 @@ class CScraperUrl
                   const std::string& cacheContext);
 
   std::string m_xml;
-  std::string m_title;
   std::string m_id;
   std::vector<SUrlEntry> m_url;
 
 private:
+  std::string m_title;
   double m_relevance;
 };
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index feb5045ffc55..f4677c7e67da 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1729,8 +1729,8 @@ namespace VIDEO
           matches.push_back(*guide);
           continue;
         }
-        if (!guide->cScraperUrl.m_title.empty() &&
-            StringUtils::EqualsNoCase(guide->cScraperUrl.m_title, file->strTitle))
+        if (!guide->cScraperUrl.GetTitle().empty() &&
+            StringUtils::EqualsNoCase(guide->cScraperUrl.GetTitle(), file->strTitle))
         {
           bFound = true;
           break;
@@ -1766,8 +1766,10 @@ namespace VIDEO
           std::vector<std::string> titles;
           for (guide = candidates->begin(); guide != candidates->end(); ++guide)
           {
-            StringUtils::ToLower(guide->cScraperUrl.m_title);
-            titles.push_back(guide->cScraperUrl.m_title);
+            auto title = guide->cScraperUrl.GetTitle();
+            StringUtils::ToLower(title);
+            guide->cScraperUrl.SetTitle(title);
+            titles.push_back(title);
           }
 
           double matchscore;
@@ -1818,8 +1820,8 @@ namespace VIDEO
   {
     CVideoInfoTag movieDetails;
 
-    if (m_handle && !url.m_title.empty())
-      m_handle->SetText(url.m_title);
+    if (m_handle && !url.GetTitle().empty())
+      m_handle->SetText(url.GetTitle());
 
     CVideoInfoDownloader imdb(scraper);
     bool ret = imdb.GetDetails(url, movieDetails, pDialog);
@@ -1829,7 +1831,7 @@ namespace VIDEO
       if (loader)
         loader->Load(movieDetails, true);
 
-      if (m_handle && url.m_title.empty())
+      if (m_handle && url.GetTitle().empty())
         m_handle->SetText(movieDetails.m_strTitle);
 
       if (pDialog)
diff --git a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
index ac8f73efbdca..13a9cf083031 100644
--- a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
+++ b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
@@ -188,7 +188,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
             selectDialog->Reset();
             selectDialog->SetHeading(scraper->Content() == CONTENT_TVSHOWS ? 20356 : 196);
             for (const auto& itemResult : itemResultList)
-              selectDialog->Add(itemResult.m_title);
+              selectDialog->Add(itemResult.GetTitle());
             selectDialog->EnableButton(true, 413); // "Manual"
             selectDialog->Open();
 
@@ -213,7 +213,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
           }
 
           CLog::Log(LOGDEBUG, "CVideoLibraryRefreshingJob: user selected item '%s' with URL '%s'",
-                    scraperUrl.m_title.c_str(), scraperUrl.m_url.at(0).m_url.c_str());
+                    scraperUrl.GetTitle().c_str(), scraperUrl.m_url.at(0).m_url.c_str());
         }
       }
       else if (result < 0 || !VIDEO::CVideoInfoScanner::DownloadFailed(GetProgressDialog()))
@@ -297,7 +297,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
 
     // prepare the progress dialog for downloading all the necessary information
     SetTitle(g_localizeStrings.Get(headingLabel));
-    SetText(scraperUrl.m_title);
+    SetText(scraperUrl.GetTitle());
     SetProgress(0);
 
     // remove any existing data for the item we're going to refresh

From 494f9219b50662fdb9162d5c8a224ab4de14283a Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 6 May 2020 00:08:52 +0200
Subject: [PATCH 05/10] [utils] CScraperUrl: add Get/SetId()

---
 xbmc/addons/Scraper.cpp | 14 +++++++++-----
 xbmc/utils/ScraperUrl.h |  5 ++++-
 2 files changed, 13 insertions(+), 6 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index f39f1c98eb0f..de24a3fd2f04 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -487,7 +487,7 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
         pxeUrl = doc.FirstChildElement("url");
       }
       if (pId && pId->FirstChild())
-        scurlRet.m_id = pId->FirstChild()->Value();
+        scurlRet.SetId(pId->FirstChild()->ValueStr());
 
       if (pxeUrl && pxeUrl->Attribute("function"))
         continue;
@@ -563,7 +563,7 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
         pxeUrl = doc.FirstChildElement("url");
       }
       if (pId && pId->FirstChild())
-        scurlRet.m_id = pId->FirstChild()->Value();
+        scurlRet.SetId(pId->FirstChild()->ValueStr());
 
       if (pxeUrl && pxeUrl->Attribute("function"))
         continue;
@@ -936,7 +936,9 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
       {
         CScraperUrl scurlMovie;
         auto title = pxnTitle->FirstChild()->ValueStr();
-        XMLUtils::GetString(pxeMovie, "id", scurlMovie.m_id);
+        std::string id;
+        if (XMLUtils::GetString(pxeMovie, "id", id))
+          scurlMovie.SetId(id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlMovie.ParseElement(pxeLink);
@@ -1257,7 +1259,9 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
         if (!XMLUtils::GetString(pxeMovie, "title", title) || title.empty())
           title = g_localizeStrings.Get(10005); // Not available
         scurlEp.SetTitle(title);
-        XMLUtils::GetString(pxeMovie, "id", scurlEp.m_id);
+        std::string id;
+        if (XMLUtils::GetString(pxeMovie, "id", id))
+          scurlEp.SetId(id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlEp.ParseElement(pxeLink);
@@ -1300,7 +1304,7 @@ bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl,
 
   std::string sFunc = fMovie ? "GetDetails" : "GetEpisodeDetails";
   std::vector<std::string> vcsIn;
-  vcsIn.push_back(scurl.m_id);
+  vcsIn.push_back(scurl.GetId());
   vcsIn.push_back(scurl.m_url[0].m_url);
   std::vector<std::string> vcsOut = RunNoThrow(sFunc, scurl, fcurl, &vcsIn);
 
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 93f16c9c5a49..9b7fdc06b32e 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -49,6 +49,9 @@ class CScraperUrl
   const std::string& GetTitle() const { return m_title; }
   void SetTitle(std::string title) { m_title = std::move(title); }
 
+  const std::string& GetId() const { return m_id; }
+  void SetId(std::string id) { m_id = std::move(id); }
+
   double GetRelevance() const { return m_relevance; }
   void SetRelevance(double relevance) { m_relevance = relevance; }
 
@@ -92,10 +95,10 @@ class CScraperUrl
                   const std::string& cacheContext);
 
   std::string m_xml;
-  std::string m_id;
   std::vector<SUrlEntry> m_url;
 
 private:
   std::string m_title;
+  std::string m_id;
   double m_relevance;
 };

From 8f91018742fc62d88f3ff2aa9aeb379d033eceeb Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 6 May 2020 00:27:56 +0200
Subject: [PATCH 06/10] [utils] CScraperUrl: add Has/Get/SetData()

---
 xbmc/addons/Scraper.cpp      |  4 ++--
 xbmc/music/Album.cpp         |  8 ++++----
 xbmc/music/Artist.cpp        |  8 ++++----
 xbmc/music/MusicDatabase.cpp |  4 ++--
 xbmc/utils/ScraperUrl.cpp    | 12 ++++++------
 xbmc/utils/ScraperUrl.h      |  8 +++++++-
 xbmc/video/VideoDatabase.cpp |  2 +-
 xbmc/video/VideoDatabase.h   |  8 ++++----
 xbmc/video/VideoInfoTag.cpp  | 16 +++++++++-------
 9 files changed, 39 insertions(+), 31 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index de24a3fd2f04..b060343f4b0e 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -1071,7 +1071,7 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
         TiXmlElement *pxeLink = pxeAlbum->FirstChildElement("url");
         CScraperUrl scurlAlbum;
         if (!pxeLink)
-          scurlAlbum.ParseString(scurl.m_xml);
+          scurlAlbum.ParseString(scurl.GetData());
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlAlbum.ParseElement(pxeLink);
 
@@ -1160,7 +1160,7 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
 
         TiXmlElement *pxeLink = pxeArtist->FirstChildElement("url");
         if (!pxeLink)
-          scurlArtist.ParseString(scurl.m_xml);
+          scurlArtist.ParseString(scurl.GetData());
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlArtist.ParseElement(pxeLink);
 
diff --git a/xbmc/music/Album.cpp b/xbmc/music/Album.cpp
index abf624743437..c3c04955e81e 100644
--- a/xbmc/music/Album.cpp
+++ b/xbmc/music/Album.cpp
@@ -529,7 +529,7 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
   XMLUtils::GetInt(album, "votes", iVotes);
 
   size_t iThumbCount = thumbURL.m_url.size();
-  std::string xmlAdd = thumbURL.m_xml;
+  std::string xmlAdd = thumbURL.GetData();
   const TiXmlElement* thumb = album->FirstChildElement("thumb");
   while (thumb)
   {
@@ -548,7 +548,7 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
     rotate(thumbURL.m_url.begin(),
            thumbURL.m_url.begin()+iThumbCount,
            thumbURL.m_url.end());
-    thumbURL.m_xml = xmlAdd;
+    thumbURL.SetData(xmlAdd);
   }
 
   const TiXmlElement* albumArtistCreditsNode = album->FirstChildElement("albumArtistCredits");
@@ -616,10 +616,10 @@ bool CAlbum::Save(TiXmlNode *node, const std::string &tag, const std::string& st
   XMLUtils::SetString(album, "releasedate", strReleaseDate);
   XMLUtils::SetString(album, "originalreleasedate", strOrigReleaseDate);
   XMLUtils::SetString(album,       "label", strLabel);
-  if (!thumbURL.m_xml.empty())
+  if (thumbURL.HasData())
   {
     CXBMCTinyXML doc;
-    doc.Parse(thumbURL.m_xml);
+    doc.Parse(thumbURL.GetData());
     const TiXmlNode* thumb = doc.FirstChild("thumb");
     while (thumb)
     {
diff --git a/xbmc/music/Artist.cpp b/xbmc/music/Artist.cpp
index bdc4f3b6dd39..16a82e26e435 100644
--- a/xbmc/music/Artist.cpp
+++ b/xbmc/music/Artist.cpp
@@ -92,7 +92,7 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
   XMLUtils::GetString(artist, "disbanded", strDisbanded);
 
   size_t iThumbCount = thumbURL.m_url.size();
-  std::string xmlAdd = thumbURL.m_xml;
+  std::string xmlAdd = thumbURL.GetData();
 
   // Available artist thumbs
   const TiXmlElement* thumb = artist->FirstChildElement("thumb");
@@ -113,7 +113,7 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
     rotate(thumbURL.m_url.begin(),
            thumbURL.m_url.begin()+iThumbCount,
            thumbURL.m_url.end());
-    thumbURL.m_xml = xmlAdd;
+    thumbURL.SetData(xmlAdd);
   }
 
   // Discography
@@ -191,10 +191,10 @@ bool CArtist::Save(TiXmlNode *node, const std::string &tag, const std::string& s
   XMLUtils::SetString(artist,                      "died", strDied);
   XMLUtils::SetString(artist,                 "disbanded", strDisbanded);
   // Available thumbs
-  if (!thumbURL.m_xml.empty())
+  if (thumbURL.HasData())
   {
     CXBMCTinyXML doc;
-    doc.Parse(thumbURL.m_xml);
+    doc.Parse(thumbURL.GetData());
     const TiXmlNode* thumb = doc.FirstChild("thumb");
     while (thumb)
     {
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index af3ae8f78a8c..0df7e627695d 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -592,7 +592,7 @@ bool CMusicDatabase::UpdateAlbum(CAlbum& album)
               StringUtils::Join(album.styles, itemSeparator),
               StringUtils::Join(album.themes, itemSeparator),
               album.strReview,
-              album.thumbURL.m_xml.c_str(),
+              album.thumbURL.GetData(),
               album.strLabel, album.strType,
               album.fRating, album.iUserrating, album.iVotes, 
               album.strReleaseDate, album.strOrigReleaseDate,
@@ -1311,7 +1311,7 @@ bool CMusicDatabase::UpdateArtist(const CArtist& artist)
                artist.strBiography, artist.strDied,
                artist.strDisbanded,
                StringUtils::Join(artist.yearsActive, itemSeparator).c_str(),
-               artist.thumbURL.m_xml.c_str(),
+               artist.thumbURL.GetData(),
                artist.fanart.m_xml.c_str());
 
   DeleteArtistDiscography(artist.idArtist);
diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index 73c1c77ef5b5..4c61a566cae8 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -46,14 +46,14 @@ CScraperUrl::~CScraperUrl() = default;
 void CScraperUrl::Clear()
 {
   m_url.clear();
-  m_xml.clear();
+  m_data.clear();
   m_relevance = 0.0;
 }
 
 bool CScraperUrl::Parse()
 {
-  auto strToParse = m_xml;
-  m_xml.clear();
+  auto strToParse = m_data;
+  m_data.clear();
   return ParseString(std::move(strToParse));
 }
 
@@ -64,7 +64,7 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
 
   std::stringstream stream;
   stream << *element;
-  m_xml += stream.str();
+  m_data += stream.str();
 
   SUrlEntry url;
   url.m_url = element->FirstChild()->Value();
@@ -118,7 +118,7 @@ bool CScraperUrl::ParseString(std::string strUrl)
     url.m_post = false;
     url.m_isgz = false;
     m_url.push_back(url);
-    m_xml = strUrl;
+    m_data = strUrl;
   }
   else
   {
@@ -357,7 +357,7 @@ void CScraperUrl::AddElement(std::string url,
   thumb.SetAttribute("preview", preview);
   TiXmlText text(url);
   thumb.InsertEndChild(text);
-  m_xml << thumb;
+  m_data << thumb;
   SUrlEntry nUrl;
   nUrl.m_url = url;
   nUrl.m_spoof = referrer;
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 9b7fdc06b32e..5e727b6c7cc5 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -46,6 +46,10 @@ class CScraperUrl
   explicit CScraperUrl(const TiXmlElement* element);
   ~CScraperUrl();
 
+  bool HasData() const { return !m_data.empty(); }
+  const std::string& GetData() const { return m_data; }
+  void SetData(std::string data) { m_data = std::move(data); }
+
   const std::string& GetTitle() const { return m_title; }
   void SetTitle(std::string title) { m_title = std::move(title); }
 
@@ -94,7 +98,9 @@ class CScraperUrl
                   XFILE::CCurlFile& http,
                   const std::string& cacheContext);
 
-  std::string m_xml;
+  // ATTENTION: this member MUST NOT be used directly except from databases
+  std::string m_data;
+
   std::vector<SUrlEntry> m_url;
 
 private:
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index facb15cece30..9dc9e3044928 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -1835,7 +1835,7 @@ void CVideoDatabase::AddCast(int mediaId, const char *mediaType, const std::vect
   int order = std::max_element(cast.begin(), cast.end())->order;
   for (const auto &i : cast)
   {
-    int idActor = AddActor(i.strName, i.thumbUrl.m_xml, i.thumb);
+    int idActor = AddActor(i.strName, i.thumbUrl.GetData(), i.thumb);
     AddLinkToActor(mediaId, mediaType, idActor, i.strRole, i.order >= 0 ? i.order : ++order);
   }
 }
diff --git a/xbmc/video/VideoDatabase.h b/xbmc/video/VideoDatabase.h
index de21a3c2d634..1480e4f9a3f1 100644
--- a/xbmc/video/VideoDatabase.h
+++ b/xbmc/video/VideoDatabase.h
@@ -206,7 +206,7 @@ const struct SDbTableOffsets
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdRating) },
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_writingCredits) },
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
+  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_data) },
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdUniqueID) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strSortTitle) },
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_duration) },
@@ -255,7 +255,7 @@ const struct SDbTableOffsets DbTvShowOffsets[] =
   { VIDEODB_TYPE_UNUSED, 0 }, //unused
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdRating) },
   { VIDEODB_TYPE_DATE, my_offsetof(CVideoInfoTag,m_premiered) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
+  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_data) },
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_genre) },
   { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strOriginalTitle)},
@@ -325,7 +325,7 @@ const struct SDbTableOffsets DbEpisodeOffsets[] =
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_iIdRating) },
   { VIDEODB_TYPE_STRINGARRAY, my_offsetof(CVideoInfoTag,m_writingCredits) },
   { VIDEODB_TYPE_DATE, my_offsetof(CVideoInfoTag,m_firstAired) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
+  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_data) },
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_duration) },
@@ -366,7 +366,7 @@ typedef enum // this enum MUST match the offset struct further down!! and make s
 const struct SDbTableOffsets DbMusicVideoOffsets[] =
 {
   { VIDEODB_TYPE_STRING, my_offsetof(class CVideoInfoTag,m_strTitle) },
-  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_xml) },
+  { VIDEODB_TYPE_STRING, my_offsetof(CVideoInfoTag,m_strPictureURL.m_data) },
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_UNUSED, 0 }, // unused
   { VIDEODB_TYPE_INT, my_offsetof(CVideoInfoTag,m_duration) },
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index b4c8cb4901d6..500280948744 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -161,10 +161,10 @@ bool CVideoInfoTag::Save(TiXmlNode *node, const std::string &tag, bool savePathI
   XMLUtils::SetString(movie, "plot", m_strPlot);
   XMLUtils::SetString(movie, "tagline", m_strTagLine);
   XMLUtils::SetInt(movie, "runtime", GetDuration() / 60);
-  if (!m_strPictureURL.m_xml.empty())
+  if (m_strPictureURL.HasData())
   {
     CXBMCTinyXML doc;
-    doc.Parse(m_strPictureURL.m_xml);
+    doc.Parse(m_strPictureURL.GetData());
     const TiXmlNode* thumb = doc.FirstChild("thumb");
     while (thumb)
     {
@@ -332,7 +332,7 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar << m_strTagLine;
     ar << m_strPlotOutline;
     ar << m_strPlot;
-    ar << m_strPictureURL.m_xml;
+    ar << m_strPictureURL.GetData();
     ar << m_fanart.m_xml;
     ar << m_strTitle;
     ar << m_strSortTitle;
@@ -345,7 +345,7 @@ void CVideoInfoTag::Archive(CArchive& ar)
       ar << m_cast[i].strRole;
       ar << m_cast[i].order;
       ar << m_cast[i].thumb;
-      ar << m_cast[i].thumbUrl.m_xml;
+      ar << m_cast[i].thumbUrl.GetData();
     }
 
     ar << m_set.title;
@@ -426,7 +426,9 @@ void CVideoInfoTag::Archive(CArchive& ar)
     ar >> m_strTagLine;
     ar >> m_strPlotOutline;
     ar >> m_strPlot;
-    ar >> m_strPictureURL.m_xml;
+    std::string data;
+    ar >> data;
+    m_strPictureURL.SetData(data);
     ar >> m_fanart.m_xml;
     ar >> m_strTitle;
     ar >> m_strSortTitle;
@@ -967,7 +969,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
     SetBasePath(value);
 
   size_t iThumbCount = m_strPictureURL.m_url.size();
-  std::string xmlAdd = m_strPictureURL.m_xml;
+  std::string xmlAdd = m_strPictureURL.GetData();
 
   const TiXmlElement* thumb = movie->FirstChildElement("thumb");
   while (thumb)
@@ -988,7 +990,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
     rotate(m_strPictureURL.m_url.begin(),
            m_strPictureURL.m_url.begin()+iThumbCount,
            m_strPictureURL.m_url.end());
-    m_strPictureURL.m_xml = xmlAdd;
+    m_strPictureURL.SetData(xmlAdd);
   }
 
   const std::string itemSeparator = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_videoItemSeparator;

From a9b51f116156680e9ec18a4953a7bfdcbc02d292 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Wed, 6 May 2020 23:32:01 +0200
Subject: [PATCH 07/10] [utils] CScraperUrl: add Has/Get/SetUrls()

---
 xbmc/NfoFile.cpp                              |   6 +-
 xbmc/addons/Scraper.cpp                       |  49 ++--
 xbmc/interfaces/legacy/InfoTagVideo.cpp       |   2 +-
 xbmc/music/Album.cpp                          |  10 +-
 xbmc/music/Artist.cpp                         |  10 +-
 xbmc/music/MusicDatabase.cpp                  |   4 +-
 xbmc/music/dialogs/GUIDialogMusicInfo.cpp     |   4 +-
 xbmc/music/infoscanner/MusicInfoScanner.cpp   |  38 +--
 xbmc/utils/ScraperUrl.cpp                     | 266 +++++++++---------
 xbmc/utils/ScraperUrl.h                       |  49 ++--
 xbmc/utils/test/TestScraperUrl.cpp            |  15 +-
 xbmc/video/VideoDatabase.cpp                  |   6 +-
 xbmc/video/VideoInfoDownloader.cpp            |  11 +-
 xbmc/video/VideoInfoScanner.cpp               |  24 +-
 xbmc/video/VideoInfoTag.cpp                   |  12 +-
 xbmc/video/dialogs/GUIDialogVideoInfo.cpp     |  10 +-
 xbmc/video/jobs/VideoLibraryRefreshingJob.cpp |   8 +-
 17 files changed, 275 insertions(+), 249 deletions(-)

diff --git a/xbmc/NfoFile.cpp b/xbmc/NfoFile.cpp
index c9aa48b642f7..78a692d07e9a 100644
--- a/xbmc/NfoFile.cpp
+++ b/xbmc/NfoFile.cpp
@@ -88,7 +88,7 @@ CInfoScanner::INFO_TYPE CNfoFile::Create(const std::string& strPath,
     return CInfoScanner::ERROR_NFO;
   if (bNfo)
   {
-    if (m_scurl.m_url.empty())
+    if (!m_scurl.HasUrls())
     {
       if (m_doc.find("[scrape url]") != std::string::npos)
         return CInfoScanner::OVERRIDE_NFO;
@@ -98,7 +98,7 @@ CInfoScanner::INFO_TYPE CNfoFile::Create(const std::string& strPath,
     else
       return CInfoScanner::COMBINED_NFO;
   }
-  return m_scurl.m_url.empty() ? CInfoScanner::NO_NFO : CInfoScanner::URL_NFO;
+  return m_scurl.HasUrls() ? CInfoScanner::URL_NFO : CInfoScanner::NO_NFO;
 }
 
 // return value: 0 - success; 1 - no result; skip; 2 - error
@@ -124,7 +124,7 @@ int CNfoFile::Scrape(ScraperPtr& scraper, CScraperUrl& url,
       return 2;
   }
 
-  return url.m_url.empty() ? 1 : 0;
+  return url.HasUrls() ? 0 : 1;
 }
 
 int CNfoFile::Load(const std::string& strFile)
diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index b060343f4b0e..958883382b3c 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -311,10 +311,11 @@ std::string CScraper::InternalRun(const std::string &function,
                                   const std::vector<std::string> *extras)
 {
   // walk the list of input URLs and fetch each into parser parameters
+  const auto& urls = scrURL.GetUrls();
   size_t i;
-  for (i = 0; i < scrURL.m_url.size(); ++i)
+  for (i = 0; i < urls.size(); ++i)
   {
-    if (!CScraperUrl::Get(scrURL.m_url[i], m_parser.m_param[i], http, ID()) ||
+    if (!CScraperUrl::Get(urls[i], m_parser.m_param[i], http, ID()) ||
         m_parser.m_param[i].empty())
       return "";
   }
@@ -442,7 +443,7 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
     CScraperUrl::SUrlEntry surl;
     surl.m_type = CScraperUrl::UrlType::General;
     surl.m_url = items[0]->GetDynPath();
-    scurlRet.m_url.emplace_back(surl);
+    scurlRet.AppendUrl(surl);
     return scurlRet;
   }
 
@@ -599,7 +600,7 @@ CScraperUrl FromFileItem<CScraperUrl>(const CFileItem &item)
   CScraperUrl::SUrlEntry surl;
   surl.m_type = CScraperUrl::UrlType::General;
   surl.m_url = item.GetDynPath();
-  url.m_url.push_back(surl);
+  url.AppendUrl(surl);
 
   return url;
 }
@@ -621,8 +622,7 @@ CMusicAlbumInfo FromFileItem<CMusicAlbumInfo>(const CFileItem &item)
     sAlbumName = StringUtils::Format("%s (%s)", sAlbumName.c_str(), sYear.c_str());
 
   CScraperUrl url;
-  url.m_url.resize(1);
-  url.m_url[0].m_url = item.GetDynPath();
+  url.AppendUrl(CScraperUrl::SUrlEntry(item.GetDynPath()));
 
   info = CMusicAlbumInfo(sTitle, sArtist, sAlbumName, url);
   if (item.HasProperty("relevance"))
@@ -638,8 +638,7 @@ CMusicArtistInfo FromFileItem<CMusicArtistInfo>(const CFileItem &item)
   std::string sTitle = item.GetLabel();
 
   CScraperUrl url;
-  url.m_url.resize(1);
-  url.m_url[0].m_url = item.GetDynPath();
+  url.AppendUrl(CScraperUrl::SUrlEntry(item.GetDynPath()));
 
   info = CMusicArtistInfo(sTitle, url);
   if (item.HasProperty("artist.genre"))
@@ -895,7 +894,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
 
   // do the search, and parse the result into a list
   vcsIn.clear();
-  vcsIn.push_back(scurl.m_url[0].m_url);
+  vcsIn.push_back(scurl.GetFirstThumbUrl());
   vcsOut = Run("GetSearchResults", scurl, fcurl, &vcsIn);
 
   bool fSort(true);
@@ -974,7 +973,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
           title += StringUtils::Format(" (%s)", sLanguage.c_str());
 
         // filter for dupes from naughty scrapers
-        if (stsDupeCheck.insert(scurlMovie.m_url[0].m_url + " " + title).second)
+        if (stsDupeCheck.insert(scurlMovie.GetFirstThumbUrl() + " " + title).second)
         {
           scurlMovie.SetTitle(title);
           vcscurl.push_back(scurlMovie);
@@ -1075,7 +1074,7 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlAlbum.ParseElement(pxeLink);
 
-        if (!scurlAlbum.m_url.size())
+        if (!scurlAlbum.HasUrls())
           continue;
 
         CMusicAlbumInfo ali(sTitle, sArtist, sAlbumName, scurlAlbum);
@@ -1164,7 +1163,7 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
           scurlArtist.ParseElement(pxeLink);
 
-        if (!scurlArtist.m_url.size())
+        if (!scurlArtist.HasUrls())
           continue;
 
         CMusicArtistInfo ari(pxnTitle->FirstChild()->Value(), scurlArtist);
@@ -1187,20 +1186,20 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
 EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl &scurl)
 {
   EPISODELIST vcep;
-  if (scurl.m_url.empty())
+  if (!scurl.HasUrls())
     return vcep;
 
   CLog::Log(LOGDEBUG,
             "%s: Searching '%s' using %s scraper "
             "(file: '%s', content: '%s', version: '%s')",
-            __FUNCTION__, scurl.m_url[0].m_url.c_str(), Name().c_str(), Path().c_str(),
+            __FUNCTION__, scurl.GetFirstThumbUrl(), Name().c_str(), Path().c_str(),
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
   {
     std::stringstream str;
     str << "plugin://" << ID()
-        << "?action=getepisodelist&url=" << CURL::Encode(scurl.m_url.front().m_url)
+        << "?action=getepisodelist&url=" << CURL::Encode(scurl.GetFirstThumbUrl())
         << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
 
     CFileItemList items;
@@ -1219,7 +1218,7 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
       CScraperUrl::SUrlEntry surl;
       surl.m_type = CScraperUrl::UrlType::General;
       surl.m_url = items[i]->GetURL().Get();
-      ep.cScraperUrl.m_url.push_back(surl);
+      ep.cScraperUrl.AppendUrl(surl);
       vcep.push_back(ep);
     }
 
@@ -1227,7 +1226,7 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   }
 
   std::vector<std::string> vcsIn;
-  vcsIn.push_back(scurl.m_url[0].m_url);
+  vcsIn.push_back(scurl.GetFirstThumbUrl());
   std::vector<std::string> vcsOut = RunNoThrow("GetEpisodeList", scurl, fcurl, &vcsIn);
 
   // parse the XML response
@@ -1292,20 +1291,20 @@ bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl,
   CLog::Log(LOGDEBUG,
             "%s: Reading %s '%s' using %s scraper "
             "(file: '%s', content: '%s', version: '%s')",
-            __FUNCTION__, fMovie ? MediaTypeMovie : MediaTypeEpisode, scurl.m_url[0].m_url.c_str(),
+            __FUNCTION__, fMovie ? MediaTypeMovie : MediaTypeEpisode, scurl.GetFirstThumbUrl(),
             Name().c_str(), Path().c_str(), ADDON::TranslateContent(Content()).c_str(),
             Version().asString().c_str());
 
   video.Reset();
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+    return PythonDetails(ID(), "url", scurl.GetFirstThumbUrl(),
       fMovie ? "getdetails" : "getepisodedetails", GetPathSettingsAsJSON(), video);
 
   std::string sFunc = fMovie ? "GetDetails" : "GetEpisodeDetails";
   std::vector<std::string> vcsIn;
   vcsIn.push_back(scurl.GetId());
-  vcsIn.push_back(scurl.m_url[0].m_url);
+  vcsIn.push_back(scurl.GetFirstThumbUrl());
   std::vector<std::string> vcsOut = RunNoThrow(sFunc, scurl, fcurl, &vcsIn);
 
   // parse XML output
@@ -1339,11 +1338,11 @@ bool CScraper::GetAlbumDetails(CCurlFile &fcurl, const CScraperUrl &scurl, CAlbu
   CLog::Log(LOGDEBUG,
             "%s: Reading '%s' using %s scraper "
             "(file: '%s', content: '%s', version: '%s')",
-            __FUNCTION__, scurl.m_url[0].m_url.c_str(), Name().c_str(), Path().c_str(),
+            __FUNCTION__, scurl.GetFirstThumbUrl(), Name().c_str(), Path().c_str(),
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+    return PythonDetails(ID(), "url", scurl.GetFirstThumbUrl(),
       "getdetails", GetPathSettingsAsJSON(), album);
 
   std::vector<std::string> vcsOut = RunNoThrow("GetAlbumDetails", scurl, fcurl);
@@ -1371,18 +1370,18 @@ bool CScraper::GetArtistDetails(CCurlFile &fcurl,
                                 const std::string &sSearch,
                                 CArtist &artist)
 {
-  if (!scurl.m_url.size())
+  if (!scurl.HasUrls())
     return false;
 
   CLog::Log(LOGDEBUG,
             "%s: Reading '%s' ('%s') using %s scraper "
             "(file: '%s', content: '%s', version: '%s')",
-            __FUNCTION__, scurl.m_url[0].m_url.c_str(), sSearch.c_str(), Name().c_str(),
+            __FUNCTION__, scurl.GetFirstThumbUrl(), sSearch.c_str(), Name().c_str(),
             Path().c_str(), ADDON::TranslateContent(Content()).c_str(),
             Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+    return PythonDetails(ID(), "url", scurl.GetFirstThumbUrl(),
       "getdetails", GetPathSettingsAsJSON(), artist);
 
   // pass in the original search string for chaining to search other sites
diff --git a/xbmc/interfaces/legacy/InfoTagVideo.cpp b/xbmc/interfaces/legacy/InfoTagVideo.cpp
index 6690596ba06b..7ea8957958c0 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.cpp
+++ b/xbmc/interfaces/legacy/InfoTagVideo.cpp
@@ -70,7 +70,7 @@ namespace XBMCAddon
 
     String InfoTagVideo::getPictureURL()
     {
-      return infoTag->m_strPictureURL.GetFirstThumb().m_url;
+      return infoTag->m_strPictureURL.GetFirstUrlByType().m_url;
     }
 
     String InfoTagVideo::getTVShowTitle()
diff --git a/xbmc/music/Album.cpp b/xbmc/music/Album.cpp
index c3c04955e81e..a5ddc9966208 100644
--- a/xbmc/music/Album.cpp
+++ b/xbmc/music/Album.cpp
@@ -528,7 +528,7 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
   }
   XMLUtils::GetInt(album, "votes", iVotes);
 
-  size_t iThumbCount = thumbURL.m_url.size();
+  size_t iThumbCount = thumbURL.GetUrls().size();
   std::string xmlAdd = thumbURL.GetData();
   const TiXmlElement* thumb = album->FirstChildElement("thumb");
   while (thumb)
@@ -543,11 +543,11 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
     thumb = thumb->NextSiblingElement("thumb");
   }
   // prioritise thumbs from nfos
-  if (prioritise && iThumbCount && iThumbCount != thumbURL.m_url.size())
+  if (prioritise && iThumbCount && iThumbCount != thumbURL.GetUrls().size())
   {
-    rotate(thumbURL.m_url.begin(),
-           thumbURL.m_url.begin()+iThumbCount,
-           thumbURL.m_url.end());
+    auto thumbUrls = thumbURL.GetUrls();
+    rotate(thumbUrls.begin(), thumbUrls.begin() + iThumbCount, thumbUrls.end());
+    thumbURL.SetUrls(thumbUrls);
     thumbURL.SetData(xmlAdd);
   }
 
diff --git a/xbmc/music/Artist.cpp b/xbmc/music/Artist.cpp
index 16a82e26e435..34ec5c2f9e91 100644
--- a/xbmc/music/Artist.cpp
+++ b/xbmc/music/Artist.cpp
@@ -91,7 +91,7 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
   XMLUtils::GetString(artist,      "died", strDied);
   XMLUtils::GetString(artist, "disbanded", strDisbanded);
 
-  size_t iThumbCount = thumbURL.m_url.size();
+  size_t iThumbCount = thumbURL.GetUrls().size();
   std::string xmlAdd = thumbURL.GetData();
 
   // Available artist thumbs
@@ -108,11 +108,11 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
     thumb = thumb->NextSiblingElement("thumb");
   }
   // prefix thumbs from nfos
-  if (prioritise && iThumbCount && iThumbCount != thumbURL.m_url.size())
+  if (prioritise && iThumbCount && iThumbCount != thumbURL.GetUrls().size())
   {
-    rotate(thumbURL.m_url.begin(),
-           thumbURL.m_url.begin()+iThumbCount,
-           thumbURL.m_url.end());
+    auto thumbUrls = thumbURL.GetUrls();
+    rotate(thumbUrls.begin(), thumbUrls.begin() + iThumbCount, thumbUrls.end());
+    thumbURL.SetUrls(thumbUrls);
     thumbURL.SetData(xmlAdd);
   }
 
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index 0df7e627695d..1631ce53777a 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -11304,7 +11304,7 @@ std::vector<std::string> CMusicDatabase::GetAvailableArtTypesForItem(int mediaId
         result.emplace_back("fanart");
 
       // all other images
-      for (const auto& urlEntry : artist.thumbURL.m_url)
+      for (const auto& urlEntry : artist.thumbURL.GetUrls())
       {
         std::string artType = urlEntry.m_aspect;
         if (artType.empty())
@@ -11319,7 +11319,7 @@ std::vector<std::string> CMusicDatabase::GetAvailableArtTypesForItem(int mediaId
     CAlbum album;
     if (GetAlbum(mediaId, album))
     {
-      for (const auto& urlEntry : album.thumbURL.m_url)
+      for (const auto& urlEntry : album.thumbURL.GetUrls())
       {
         std::string artType = urlEntry.m_aspect;
         if (artType.empty())
diff --git a/xbmc/music/dialogs/GUIDialogMusicInfo.cpp b/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
index 171ef73a4b8a..44ee58792e84 100644
--- a/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
+++ b/xbmc/music/dialogs/GUIDialogMusicInfo.cpp
@@ -783,9 +783,9 @@ void CGUIDialogMusicInfo::OnGetArt()
     // Type "thumb" returns URLs for all types of art including those without aspect.
     // Those URL without aspect are also returned for all other type values.
     if (m_bArtistInfo)
-      m_artist.thumbURL.GetThumbURLs(remotethumbs, type);
+      m_artist.thumbURL.GetThumbUrls(remotethumbs, type);
     else
-      m_album.thumbURL.GetThumbURLs(remotethumbs, type);
+      m_album.thumbURL.GetThumbUrls(remotethumbs, type);
 
     for (unsigned int i = 0; i < remotethumbs.size(); ++i)
     {
diff --git a/xbmc/music/infoscanner/MusicInfoScanner.cpp b/xbmc/music/infoscanner/MusicInfoScanner.cpp
index a42528570660..4a6d57625189 100644
--- a/xbmc/music/infoscanner/MusicInfoScanner.cpp
+++ b/xbmc/music/infoscanner/MusicInfoScanner.cpp
@@ -1312,10 +1312,12 @@ CMusicInfoScanner::UpdateDatabaseAlbumInfo(CAlbum& album,
       }
       else
       {
-        CServiceBroker::GetEventLog().Add(EventPtr(new CMediaLibraryEvent(
-          MediaTypeAlbum, album.strPath, 24146,
-          StringUtils::Format(g_localizeStrings.Get(24147).c_str(), MediaTypeAlbum, album.strAlbum.c_str()),
-          CScraperUrl::GetThumbURL(album.thumbURL.GetFirstThumb()), CURL::GetRedacted(album.strPath), EventLevel::Warning)));
+        CServiceBroker::GetEventLog().Add(EventPtr(
+            new CMediaLibraryEvent(MediaTypeAlbum, album.strPath, 24146,
+                                   StringUtils::Format(g_localizeStrings.Get(24147).c_str(),
+                                                       MediaTypeAlbum, album.strAlbum.c_str()),
+                                   CScraperUrl::GetThumbUrl(album.thumbURL.GetFirstUrlByType()),
+                                   CURL::GetRedacted(album.strPath), EventLevel::Warning)));
       }
     }
   }
@@ -1380,10 +1382,12 @@ CMusicInfoScanner::UpdateDatabaseArtistInfo(CArtist& artist,
       }
       else
       {
-        CServiceBroker::GetEventLog().Add(EventPtr(new CMediaLibraryEvent(
-          MediaTypeArtist, artist.strPath, 24146,
-          StringUtils::Format(g_localizeStrings.Get(24147).c_str(), MediaTypeArtist, artist.strArtist.c_str()),
-          CScraperUrl::GetThumbURL(artist.thumbURL.GetFirstThumb()), CURL::GetRedacted(artist.strPath), EventLevel::Warning)));
+        CServiceBroker::GetEventLog().Add(EventPtr(
+            new CMediaLibraryEvent(MediaTypeArtist, artist.strPath, 24146,
+                                   StringUtils::Format(g_localizeStrings.Get(24147).c_str(),
+                                                       MediaTypeArtist, artist.strArtist.c_str()),
+                                   CScraperUrl::GetThumbUrl(artist.thumbURL.GetFirstUrlByType()),
+                                   CURL::GetRedacted(artist.strPath), EventLevel::Warning)));
       }
     }
   }
@@ -1500,7 +1504,7 @@ CMusicInfoScanner::DownloadAlbumInfo(const CAlbum& album,
       CMusicAlbumInfo albumNfo("nfo",scrUrl);
       ADDON::ScraperPtr nfoReaderScraper = nfoReader.GetScraperInfo();
       CLog::Log(LOGDEBUG,"-- nfo-scraper: %s", nfoReaderScraper->Name().c_str());
-      CLog::Log(LOGDEBUG,"-- nfo url: %s", scrUrl.m_url[0].m_url.c_str());
+      CLog::Log(LOGDEBUG, "-- nfo url: %s", scrUrl.GetFirstThumbUrl());
       scraper.SetScraperInfo(nfoReaderScraper);
       scraper.GetAlbums().clear();
       scraper.GetAlbums().push_back(albumNfo);
@@ -1675,7 +1679,7 @@ CMusicInfoScanner::DownloadAlbumInfo(const CAlbum& album,
 
 void CMusicInfoScanner::GetAlbumArtwork(long id, const CAlbum &album)
 {
-  if (album.thumbURL.m_url.size())
+  if (album.thumbURL.HasUrls())
   {
     // Check current album thumb
     std::string artURL = m_musicDatabase.GetArtForItem(id, MediaTypeAlbum, "thumb");
@@ -1686,7 +1690,7 @@ void CMusicInfoScanner::GetAlbumArtwork(long id, const CAlbum &album)
         (StringUtils::StartsWith(artURL, "image://") &&
          CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_MUSICLIBRARY_PREFERONLINEALBUMART)))
     {
-      std::string thumb = CScraperUrl::GetThumbURL(album.thumbURL.GetFirstThumb("thumb"));
+      std::string thumb = CScraperUrl::GetThumbUrl(album.thumbURL.GetFirstUrlByType("thumb"));
       if (!thumb.empty())
       {
         CTextureCache::GetInstance().BackgroundCacheImage(thumb);
@@ -1787,7 +1791,7 @@ CMusicInfoScanner::DownloadArtistInfo(const CArtist& artist,
       CMusicArtistInfo artistNfo("nfo", scrUrl);
       ADDON::ScraperPtr nfoReaderScraper = nfoReader.GetScraperInfo();
       CLog::Log(LOGDEBUG, "-- nfo-scraper: %s", nfoReaderScraper->Name().c_str());
-      CLog::Log(LOGDEBUG, "-- nfo url: %s", scrUrl.m_url[0].m_url.c_str());
+      CLog::Log(LOGDEBUG, "-- nfo url: %s", scrUrl.GetFirstThumbUrl());
       scraper.SetScraperInfo(nfoReaderScraper);
       scraper.GetArtists().push_back(artistNfo);
     }
@@ -1931,10 +1935,10 @@ bool CMusicInfoScanner::ResolveMusicBrainz(const std::string &strMusicBrainzID,
       return false;
   }
 
-  if (!musicBrainzURL.m_url.empty())
+  if (musicBrainzURL.HasUrls())
   {
     CLog::Log(LOGDEBUG,"-- nfo-scraper: %s",preferredScraper->Name().c_str());
-    CLog::Log(LOGDEBUG,"-- nfo url: %s", musicBrainzURL.m_url[0].m_url.c_str());
+    CLog::Log(LOGDEBUG, "-- nfo url: %s", musicBrainzURL.GetFirstThumbUrl());
     bMusicBrainz = true;
   }
 
@@ -2034,7 +2038,7 @@ bool CMusicInfoScanner::SetArtistArtwork(CArtist& artist, const std::vector<std:
       if (type == "fanart")
         strArt = artist.fanart.GetImageURL();
       else
-        strArt = CScraperUrl::GetThumbURL(artist.thumbURL.GetFirstThumb(type));
+        strArt = CScraperUrl::GetThumbUrl(artist.thumbURL.GetFirstUrlByType(type));
     }
     // Add art to artist and library
     if (!strArt.empty())
@@ -2051,7 +2055,7 @@ bool CMusicInfoScanner::SetArtistArtwork(CArtist& artist, const std::vector<std:
 
 bool CMusicInfoScanner::SetAlbumArtwork(CAlbum& album, std::vector<std::string>& missing, const std::string& artfolder)
 {
-  if (album.thumbURL.m_url.empty())
+  if (!album.thumbURL.HasUrls())
   {
     if (artfolder.empty())
       return false; // No local or scraped art to process
@@ -2123,7 +2127,7 @@ bool CMusicInfoScanner::SetAlbumArtwork(CAlbum& album, std::vector<std::string>&
     // of scraper results for it (unlike artist).
     if (strArt.empty())
     {
-      strArt = CScraperUrl::GetThumbURL(album.thumbURL.GetFirstThumb(type));
+      strArt = CScraperUrl::GetThumbUrl(album.thumbURL.GetFirstUrlByType(type));
     }
     // Add art to album and library
     if (!strArt.empty())
diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index 4c61a566cae8..77b601f3e14c 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -45,11 +45,74 @@ CScraperUrl::~CScraperUrl() = default;
 
 void CScraperUrl::Clear()
 {
-  m_url.clear();
+  m_urls.clear();
   m_data.clear();
   m_relevance = 0.0;
 }
 
+const CScraperUrl::SUrlEntry CScraperUrl::GetFirstUrlByType(const std::string& type) const
+{
+  const auto url = std::find_if(m_urls.begin(), m_urls.end(), [type](const SUrlEntry& url) {
+    return url.m_type == UrlType::General && (type.empty() || url.m_aspect == type);
+  });
+  if (url != m_urls.end())
+    return *url;
+
+  return SUrlEntry();
+}
+
+const CScraperUrl::SUrlEntry CScraperUrl::GetSeasonUrl(int season, const std::string& type) const
+{
+  const auto url = std::find_if(m_urls.begin(), m_urls.end(), [season, type](const SUrlEntry& url) {
+    return url.m_type == UrlType::Season && url.m_season == season &&
+           (type.empty() || type == "thumb" || url.m_aspect == type);
+  });
+  if (url != m_urls.end())
+    return *url;
+
+  return SUrlEntry();
+}
+
+unsigned int CScraperUrl::GetMaxSeasonUrl() const
+{
+  unsigned int maxSeason = 0;
+  for (const auto& url : m_urls)
+  {
+    if (url.m_type == UrlType::Season && url.m_season > 0 &&
+        static_cast<unsigned int>(url.m_season) > maxSeason)
+      maxSeason = url.m_season;
+  }
+  return maxSeason;
+}
+
+std::string CScraperUrl::GetFirstThumbUrl() const
+{
+  if (m_urls.empty())
+    return {};
+
+  return GetThumbUrl(m_urls.front());
+}
+
+void CScraperUrl::GetThumbUrls(std::vector<std::string>& thumbs,
+                               const std::string& type,
+                               int season,
+                               bool unique) const
+{
+  for (const auto& url : m_urls)
+  {
+    if (url.m_aspect == type || type.empty() || url.m_aspect.empty())
+    {
+      if ((url.m_type == CScraperUrl::UrlType::General && season == -1) ||
+          (url.m_type == CScraperUrl::UrlType::Season && url.m_season == season))
+      {
+        std::string thumbUrl = GetThumbUrl(url);
+        if (!unique || std::find(thumbs.begin(), thumbs.end(), thumbUrl) == thumbs.end())
+          thumbs.push_back(thumbUrl);
+      }
+    }
+  }
+}
+
 bool CScraperUrl::Parse()
 {
   auto strToParse = m_data;
@@ -93,7 +156,7 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
   }
   url.m_aspect = XMLUtils::GetAttribute(element, "aspect");
 
-  m_url.push_back(url);
+  m_urls.push_back(url);
 
   return true;
 }
@@ -117,7 +180,7 @@ bool CScraperUrl::ParseString(std::string strUrl)
     url.m_season = -1;
     url.m_post = false;
     url.m_isgz = false;
-    m_url.push_back(url);
+    m_urls.push_back(url);
     m_data = strUrl;
   }
   else
@@ -132,39 +195,86 @@ bool CScraperUrl::ParseString(std::string strUrl)
   return true;
 }
 
-const CScraperUrl::SUrlEntry CScraperUrl::GetFirstThumb(const std::string& type) const
+// XML format is of strUrls is:
+// <TAG><url>...</url>...</TAG> (parsed by ParseElement) or <url>...</url> (ditto)
+bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
 {
-  const auto url = std::find_if(m_url.begin(), m_url.end(), [type](const SUrlEntry& url) {
-    return url.m_type == UrlType::General && (type.empty() || url.m_aspect == type);
-  });
-  if (url != m_url.end())
-    return *url;
+  if (strUrls.empty())
+    return false;
 
-  return {};
+  // ok, now parse the xml file
+  CXBMCTinyXML doc;
+  /* strUrls is coming from internal sources so strUrls is always in UTF-8 */
+  doc.Parse(strUrls, TIXML_ENCODING_UTF8);
+  if (doc.RootElement() != nullptr)
+  {
+    TiXmlHandle docHandle(&doc);
+    auto link = docHandle.FirstChild("episodeguide").Element();
+    if (link->FirstChildElement("url"))
+    {
+      for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
+        ParseElement(link);
+    }
+    else if (link->FirstChild() && link->FirstChild()->Value())
+      ParseElement(link);
+  }
+  else
+    return false;
+
+  return true;
 }
 
-const CScraperUrl::SUrlEntry CScraperUrl::GetSeasonThumb(int season, const std::string& type) const
+void CScraperUrl::AddElement(std::string url,
+                             std::string aspect,
+                             std::string preview,
+                             std::string referrer,
+                             std::string cache,
+                             bool post,
+                             bool isgz,
+                             int season)
 {
-  const auto url = std::find_if(m_url.begin(), m_url.end(), [season, type](const SUrlEntry& url) {
-    return url.m_type == UrlType::Season && url.m_season == season &&
-           (type.empty() || type == "thumb" || url.m_aspect == type);
-  });
-  if (url != m_url.end())
-    return *url;
+  TiXmlElement thumb("thumb");
+  thumb.SetAttribute("spoof", referrer);
+  thumb.SetAttribute("cache", cache);
+  if (post)
+    thumb.SetAttribute("post", "yes");
+  if (isgz)
+    thumb.SetAttribute("gzip", "yes");
+  if (season >= 0)
+  {
+    thumb.SetAttribute("season", StringUtils::Format("%i", season));
+    thumb.SetAttribute("type", "season");
+  }
+  thumb.SetAttribute("aspect", aspect);
+  thumb.SetAttribute("preview", preview);
+  TiXmlText text(url);
+  thumb.InsertEndChild(text);
+  m_data << thumb;
+  SUrlEntry nUrl;
+  nUrl.m_url = url;
+  nUrl.m_spoof = referrer;
+  nUrl.m_post = post;
+  nUrl.m_isgz = isgz;
+  nUrl.m_cache = cache;
+  if (season >= 0)
+  {
+    nUrl.m_type = UrlType::Season;
+    nUrl.m_season = season;
+  }
+  else
+    nUrl.m_type = UrlType::General;
+
+  nUrl.m_aspect = aspect;
 
-  return {};
+  m_urls.push_back(nUrl);
 }
 
-unsigned int CScraperUrl::GetMaxSeasonThumb() const
+std::string CScraperUrl::GetThumbUrl(const CScraperUrl::SUrlEntry& entry)
 {
-  unsigned int maxSeason = 0;
-  for (const auto& url : m_url)
-  {
-    if (url.m_type == UrlType::Season && url.m_season > 0 &&
-        static_cast<unsigned int>(url.m_season) > maxSeason)
-      maxSeason = url.m_season;
-  }
-  return maxSeason;
+  if (entry.m_spoof.empty())
+    return entry.m_url;
+
+  return entry.m_url + "|Referer=" + CURL::Encode(entry.m_spoof);
 }
 
 bool CScraperUrl::Get(const SUrlEntry& scrURL,
@@ -302,105 +412,3 @@ bool CScraperUrl::Get(const SUrlEntry& scrURL,
   }
   return true;
 }
-
-// XML format is of strUrls is:
-// <TAG><url>...</url>...</TAG> (parsed by ParseElement) or <url>...</url> (ditto)
-bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
-{
-  if (strUrls.empty())
-    return false;
-
-  // ok, now parse the xml file
-  CXBMCTinyXML doc;
-  /* strUrls is coming from internal sources so strUrls is always in UTF-8 */
-  doc.Parse(strUrls, TIXML_ENCODING_UTF8);
-  if (doc.RootElement() != nullptr)
-  {
-    TiXmlHandle docHandle(&doc);
-    auto link = docHandle.FirstChild("episodeguide").Element();
-    if (link->FirstChildElement("url"))
-    {
-      for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
-        ParseElement(link);
-    }
-    else if (link->FirstChild() && link->FirstChild()->Value())
-      ParseElement(link);
-  }
-  else
-    return false;
-
-  return true;
-}
-
-void CScraperUrl::AddElement(std::string url,
-                             std::string aspect,
-                             std::string preview,
-                             std::string referrer,
-                             std::string cache,
-                             bool post,
-                             bool isgz,
-                             int season)
-{
-  TiXmlElement thumb("thumb");
-  thumb.SetAttribute("spoof", referrer);
-  thumb.SetAttribute("cache", cache);
-  if (post)
-    thumb.SetAttribute("post", "yes");
-  if (isgz)
-    thumb.SetAttribute("gzip", "yes");
-  if (season >= 0)
-  {
-    thumb.SetAttribute("season", StringUtils::Format("%i", season));
-    thumb.SetAttribute("type", "season");
-  }
-  thumb.SetAttribute("aspect", aspect);
-  thumb.SetAttribute("preview", preview);
-  TiXmlText text(url);
-  thumb.InsertEndChild(text);
-  m_data << thumb;
-  SUrlEntry nUrl;
-  nUrl.m_url = url;
-  nUrl.m_spoof = referrer;
-  nUrl.m_post = post;
-  nUrl.m_isgz = isgz;
-  nUrl.m_cache = cache;
-  if (season >= 0)
-  {
-    nUrl.m_type = UrlType::Season;
-    nUrl.m_season = season;
-  }
-  else
-    nUrl.m_type = UrlType::General;
-
-  nUrl.m_aspect = aspect;
-
-  m_url.push_back(nUrl);
-}
-
-std::string CScraperUrl::GetThumbURL(const CScraperUrl::SUrlEntry& entry)
-{
-  if (entry.m_spoof.empty())
-    return entry.m_url;
-
-  return entry.m_url + "|Referer=" + CURL::Encode(entry.m_spoof);
-}
-
-void CScraperUrl::GetThumbURLs(std::vector<std::string>& thumbs,
-                               const std::string& type,
-                               int season,
-                               bool unique) const
-{
-  for (const auto& url : m_url)
-  {
-    if (url.m_aspect == type || type.empty() || url.m_aspect.empty())
-    {
-      if ((url.m_type == CScraperUrl::UrlType::General && season == -1) ||
-          (url.m_type == CScraperUrl::UrlType::Season && url.m_season == season))
-      {
-        std::string thumbUrl = GetThumbURL(url);
-        if (!unique || std::find(thumbs.begin(), thumbs.end(), thumbUrl) == thumbs.end())
-          thumbs.push_back(thumbUrl);
-      }
-    }
-  }
-}
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 5e727b6c7cc5..83651bb0cbe8 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -29,7 +29,10 @@ class CScraperUrl
 
   struct SUrlEntry
   {
-    SUrlEntry() : m_type(UrlType::General), m_post(false), m_isgz(false), m_season(-1) {}
+    explicit SUrlEntry(std::string url = "")
+      : m_url(std::move(url)), m_type(UrlType::General), m_post(false), m_isgz(false), m_season(-1)
+    {
+    }
 
     std::string m_spoof;
     std::string m_url;
@@ -46,6 +49,8 @@ class CScraperUrl
   explicit CScraperUrl(const TiXmlElement* element);
   ~CScraperUrl();
 
+  void Clear();
+
   bool HasData() const { return !m_data.empty(); }
   const std::string& GetData() const { return m_data; }
   void SetData(std::string data) { m_data = std::move(data); }
@@ -59,6 +64,28 @@ class CScraperUrl
   double GetRelevance() const { return m_relevance; }
   void SetRelevance(double relevance) { m_relevance = relevance; }
 
+  bool HasUrls() const { return !m_urls.empty(); }
+  const std::vector<SUrlEntry>& GetUrls() const { return m_urls; }
+  void SetUrls(std::vector<SUrlEntry> urls) { m_urls = std::move(urls); }
+  void AppendUrl(SUrlEntry url) { m_urls.push_back(std::move(url)); }
+
+  const SUrlEntry GetFirstUrlByType(const std::string& type = "") const;
+  const SUrlEntry GetSeasonUrl(int season, const std::string& type = "") const;
+  unsigned int GetMaxSeasonUrl() const;
+
+  std::string GetFirstThumbUrl() const;
+
+  /*! \brief fetch the full URLs (including referrer) of thumbs
+   \param thumbs [out] vector of thumb URLs to fill
+   \param type the type of thumb URLs to fetch, if empty (the default) picks any
+   \param season number of season that we want thumbs for, -1 indicates no season (the default)
+   \param unique avoid adding duplicate URLs when adding to a thumbs vector with existing items
+   */
+  void GetThumbUrls(std::vector<std::string>& thumbs,
+                    const std::string& type = "",
+                    int season = -1,
+                    bool unique = false) const;
+
   bool Parse();
   bool ParseString(std::string strUrl); // copies by intention
   bool ParseElement(const TiXmlElement* element);
@@ -72,27 +99,12 @@ class CScraperUrl
                   bool isgz = false,
                   int season = -1);
 
-  const SUrlEntry GetFirstThumb(const std::string& type = "") const;
-  const SUrlEntry GetSeasonThumb(int season, const std::string& type = "") const;
-  unsigned int GetMaxSeasonThumb() const;
-
   /*! \brief fetch the full URL (including referrer) of a thumb
    \param URL entry to use to create the full URL
    \return the full URL, including referrer
    */
-  static std::string GetThumbURL(const CScraperUrl::SUrlEntry& entry);
+  static std::string GetThumbUrl(const CScraperUrl::SUrlEntry& entry);
 
-  /*! \brief fetch the full URLs (including referrer) of thumbs
-   \param thumbs [out] vector of thumb URLs to fill
-   \param type the type of thumb URLs to fetch, if empty (the default) picks any
-   \param season number of season that we want thumbs for, -1 indicates no season (the default)
-   \param unique avoid adding duplicate URLs when adding to a thumbs vector with existing items
-   */
-  void GetThumbURLs(std::vector<std::string>& thumbs,
-                    const std::string& type = "",
-                    int season = -1,
-                    bool unique = false) const;
-  void Clear();
   static bool Get(const SUrlEntry& scrURL,
                   std::string& strHTML,
                   XFILE::CCurlFile& http,
@@ -101,10 +113,9 @@ class CScraperUrl
   // ATTENTION: this member MUST NOT be used directly except from databases
   std::string m_data;
 
-  std::vector<SUrlEntry> m_url;
-
 private:
   std::string m_title;
   std::string m_id;
   double m_relevance;
+  std::vector<SUrlEntry> m_urls;
 };
diff --git a/xbmc/utils/test/TestScraperUrl.cpp b/xbmc/utils/test/TestScraperUrl.cpp
index 521d40ca07d4..ecb5b14826e4 100644
--- a/xbmc/utils/test/TestScraperUrl.cpp
+++ b/xbmc/utils/test/TestScraperUrl.cpp
@@ -23,11 +23,12 @@ TEST(TestScraperUrl, General)
               "</data>\n";
   EXPECT_TRUE(a.ParseString(xmlstring));
 
-  EXPECT_STREQ("blah", a.GetFirstThumb().m_spoof.c_str());
-  EXPECT_STREQ("someurl", a.GetFirstThumb().m_url.c_str());
-  EXPECT_STREQ("", a.GetFirstThumb().m_cache.c_str());
-  EXPECT_EQ(CScraperUrl::UrlType::General, a.GetFirstThumb().m_type);
-  EXPECT_FALSE(a.GetFirstThumb().m_post);
-  EXPECT_TRUE(a.GetFirstThumb().m_isgz);
-  EXPECT_EQ(-1, a.GetFirstThumb().m_season);
+  const auto url = a.GetFirstUrlByType();
+  EXPECT_STREQ("blah", url.m_spoof.c_str());
+  EXPECT_STREQ("someurl", url.m_url.c_str());
+  EXPECT_STREQ("", url.m_cache.c_str());
+  EXPECT_EQ(CScraperUrl::UrlType::General, url.m_type);
+  EXPECT_FALSE(url.m_post);
+  EXPECT_TRUE(url.m_isgz);
+  EXPECT_EQ(-1, url.m_season);
 }
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 9dc9e3044928..ce55296d2d04 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4773,7 +4773,7 @@ std::vector<std::string> GetBasicItemAvailableArtTypes(const CVideoInfoTag& tag)
     result.emplace_back("fanart");
 
   // all other images
-  for (const auto& urlEntry : tag.m_strPictureURL.m_url)
+  for (const auto& urlEntry : tag.m_strPictureURL.GetUrls())
   {
     std::string artType = urlEntry.m_aspect;
     if (artType.empty())
@@ -4797,7 +4797,7 @@ std::vector<std::string> GetSeasonAvailableArtTypes(int mediaId, CVideoDatabase&
 
   CVideoInfoTag sourceShow;
   db.GetTvShowInfo("", sourceShow, tag.m_iIdShow);
-  for (const auto& urlEntry : sourceShow.m_strPictureURL.m_url)
+  for (const auto& urlEntry : sourceShow.m_strPictureURL.GetUrls())
   {
     std::string artType = urlEntry.m_aspect;
     if (artType.empty())
@@ -4823,7 +4823,7 @@ std::vector<std::string> GetMovieSetAvailableArtTypes(int mediaId, CVideoDatabas
       CVideoInfoTag* pTag = item->GetVideoInfoTag();
       pTag->m_strPictureURL.Parse();
 
-      for (const auto& urlEntry : pTag->m_strPictureURL.m_url)
+      for (const auto& urlEntry : pTag->m_strPictureURL.GetUrls())
       {
         if (!StringUtils::StartsWith(urlEntry.m_aspect, "set."))
           continue;
diff --git a/xbmc/video/VideoInfoDownloader.cpp b/xbmc/video/VideoInfoDownloader.cpp
index c52b9bc77290..8048647d11dc 100644
--- a/xbmc/video/VideoInfoDownloader.cpp
+++ b/xbmc/video/VideoInfoDownloader.cpp
@@ -69,7 +69,7 @@ void CVideoInfoDownloader::Process()
     return;
   }
 
-  if (m_url.m_url.empty())
+  if (!m_url.HasUrls())
   {
     // empty url when it's not supposed to be..
     // this might happen if the previously scraped item was removed from the site (see ticket #10537)
@@ -78,17 +78,20 @@ void CVideoInfoDownloader::Process()
   else if (m_state == GET_DETAILS)
   {
     if (!GetDetails(m_url, m_movieDetails))
-      CLog::Log(LOGERROR, "%s: Error getting details from %s", __FUNCTION__,m_url.m_url[0].m_url.c_str());
+      CLog::Log(LOGERROR, "%s: Error getting details from %s", __FUNCTION__,
+                m_url.GetFirstThumbUrl());
   }
   else if (m_state == GET_EPISODE_DETAILS)
   {
     if (!GetEpisodeDetails(m_url, m_movieDetails))
-      CLog::Log(LOGERROR, "%s: Error getting episode details from %s", __FUNCTION__, m_url.m_url[0].m_url.c_str());
+      CLog::Log(LOGERROR, "%s: Error getting episode details from %s", __FUNCTION__,
+                m_url.GetFirstThumbUrl());
   }
   else if (m_state == GET_EPISODE_LIST)
   {
     if (!GetEpisodeList(m_url, m_episode))
-      CLog::Log(LOGERROR, "%s: Error getting episode list from %s", __FUNCTION__, m_url.m_url[0].m_url.c_str());
+      CLog::Log(LOGERROR, "%s: Error getting episode list from %s", __FUNCTION__,
+                m_url.GetFirstThumbUrl());
   }
   m_found = 1;
   m_state = DO_NOTHING;
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index f4677c7e67da..325957488997 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -592,14 +592,14 @@ namespace VIDEO
       movieTitle = tag->GetTitle();
       movieYear = tag->GetYear(); // movieYear is expected to be >= 0
     }
-    if (pURL && !pURL->m_url.empty())
+    if (pURL && pURL->HasUrls())
       url = *pURL;
     else if ((retVal = FindVideo(movieTitle, movieYear, info2, url, pDlgProgress)) <= 0)
       return retVal < 0 ? INFO_CANCELLED : INFO_NOT_FOUND;
 
     CLog::Log(LOGDEBUG,
               "VideoInfoScanner: Fetching url '%s' using %s scraper (content: '%s')",
-              url.m_url[0].m_url.c_str(), info2->Name().c_str(),
+              url.GetFirstThumbUrl(), info2->Name().c_str(),
               TranslateContent(info2->Content()).c_str());
 
     long lResult = -1;
@@ -676,14 +676,14 @@ namespace VIDEO
       movieTitle = tag->GetTitle();
       movieYear = tag->GetYear(); // movieYear is expected to be >= 0
     }
-    if (pURL && !pURL->m_url.empty())
+    if (pURL && pURL->HasUrls())
       url = *pURL;
     else if ((retVal = FindVideo(movieTitle, movieYear, info2, url, pDlgProgress)) <= 0)
       return retVal < 0 ? INFO_CANCELLED : INFO_NOT_FOUND;
 
     CLog::Log(LOGDEBUG,
               "VideoInfoScanner: Fetching url '%s' using %s scraper (content: '%s')",
-              url.m_url[0].m_url.c_str(), info2->Name().c_str(),
+              url.GetFirstThumbUrl(), info2->Name().c_str(),
               TranslateContent(info2->Content()).c_str());
 
     if (GetDetails(pItem, url, info2,
@@ -755,14 +755,14 @@ namespace VIDEO
       movieTitle = tag->GetTitle();
       movieYear = tag->GetYear(); // movieYear is expected to be >= 0
     }
-    if (pURL && !pURL->m_url.empty())
+    if (pURL && pURL->HasUrls())
       url = *pURL;
     else if ((retVal = FindVideo(movieTitle, movieYear, info2, url, pDlgProgress)) <= 0)
       return retVal < 0 ? INFO_CANCELLED : INFO_NOT_FOUND;
 
     CLog::Log(LOGDEBUG,
               "VideoInfoScanner: Fetching url '%s' using %s scraper (content: '%s')",
-              url.m_url[0].m_url.c_str(), info2->Name().c_str(),
+              url.GetFirstThumbUrl(), info2->Name().c_str(),
               TranslateContent(info2->Content()).c_str());
 
     if (GetDetails(pItem, url, info2,
@@ -1554,7 +1554,7 @@ namespace VIDEO
     }
 
     // add online art
-    for (const auto& url : pItem->GetVideoInfoTag()->m_strPictureURL.m_url)
+    for (const auto& url : pItem->GetVideoInfoTag()->m_strPictureURL.GetUrls())
     {
       if (url.m_type != CScraperUrl::UrlType::General)
         continue;
@@ -1584,7 +1584,7 @@ namespace VIDEO
 
   std::string CVideoInfoScanner::GetImage(const CScraperUrl::SUrlEntry &image, const std::string& itemPath)
   {
-    std::string thumb = CScraperUrl::GetThumbURL(image);
+    std::string thumb = CScraperUrl::GetThumbUrl(image);
     if (!thumb.empty() &&
       thumb.find("/") == std::string::npos &&
       thumb.find("\\") == std::string::npos)
@@ -2030,7 +2030,7 @@ namespace VIDEO
       }
     }
     // add online art
-    for (const auto& url : show.m_strPictureURL.m_url)
+    for (const auto& url : show.m_strPictureURL.GetUrls())
     {
       if (url.m_type != CScraperUrl::UrlType::Season)
         continue;
@@ -2040,7 +2040,7 @@ namespace VIDEO
       std::map<std::string, std::string>& art = seasonArt[url.m_season];
       if (find(artTypes.begin(), artTypes.end(), aspect) == artTypes.end() || art.find(aspect) != art.end())
         continue;
-      std::string image = CScraperUrl::GetThumbURL(url);
+      std::string image = CScraperUrl::GetThumbUrl(url);
       if (!image.empty())
         art.insert(std::make_pair(aspect, image));
     }
@@ -2073,8 +2073,8 @@ namespace VIDEO
             break;
           }
         }
-        if (i->thumb.empty() && !i->thumbUrl.GetFirstThumb().m_url.empty())
-          i->thumb = CScraperUrl::GetThumbURL(i->thumbUrl.GetFirstThumb());
+        if (i->thumb.empty() && !i->thumbUrl.GetFirstUrlByType().m_url.empty())
+          i->thumb = CScraperUrl::GetThumbUrl(i->thumbUrl.GetFirstUrlByType());
         if (!i->thumb.empty())
           CTextureCache::GetInstance().BackgroundCacheImage(i->thumb);
       }
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 500280948744..1335110f3eea 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -276,7 +276,7 @@ bool CVideoInfoTag::Save(TiXmlNode *node, const std::string &tag, bool savePathI
     XMLUtils::SetString(node, "name", it->strName);
     XMLUtils::SetString(node, "role", it->strRole);
     XMLUtils::SetInt(node, "order", it->order);
-    XMLUtils::SetString(node, "thumb", it->thumbUrl.GetFirstThumb().m_url);
+    XMLUtils::SetString(node, "thumb", it->thumbUrl.GetFirstUrlByType().m_url);
   }
   XMLUtils::SetStringArray(movie, "artist", m_artist);
   XMLUtils::SetStringArray(movie, "showlink", m_showLink);
@@ -968,7 +968,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
   if (XMLUtils::GetString(movie, "basepath", value))
     SetBasePath(value);
 
-  size_t iThumbCount = m_strPictureURL.m_url.size();
+  size_t iThumbCount = m_strPictureURL.GetUrls().size();
   std::string xmlAdd = m_strPictureURL.GetData();
 
   const TiXmlElement* thumb = movie->FirstChildElement("thumb");
@@ -985,11 +985,11 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
   }
 
   // prioritise thumbs from nfos
-  if (prioritise && iThumbCount && iThumbCount != m_strPictureURL.m_url.size())
+  if (prioritise && iThumbCount && iThumbCount != m_strPictureURL.GetUrls().size())
   {
-    rotate(m_strPictureURL.m_url.begin(),
-           m_strPictureURL.m_url.begin()+iThumbCount,
-           m_strPictureURL.m_url.end());
+    auto thumbUrls = m_strPictureURL.GetUrls();
+    rotate(thumbUrls.begin(), thumbUrls.begin() + iThumbCount, thumbUrls.end());
+    m_strPictureURL.SetUrls(thumbUrls);
     m_strPictureURL.SetData(xmlAdd);
   }
 
diff --git a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
index 5c7f57f6f19e..ebf5c46a3ff8 100644
--- a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
@@ -351,7 +351,7 @@ void CGUIDialogVideoInfo::SetMovie(const CFileItem *item)
         item->SetArt("thumb", it->thumb);
       else if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOLIBRARY_ACTORTHUMBS))
       { // backward compatibility
-        std::string thumb = CScraperUrl::GetThumbURL(it->thumbUrl.GetFirstThumb());
+        std::string thumb = CScraperUrl::GetThumbUrl(it->thumbUrl.GetFirstUrlByType());
         if (!thumb.empty())
         {
           item->SetArt("thumb", thumb);
@@ -826,7 +826,7 @@ void CGUIDialogVideoInfo::OnGetArt()
     // Grab the thumbnails from the web
     std::vector<std::string> thumbs;
     int season = (m_movieItem->GetVideoInfoTag()->m_type == MediaTypeSeason) ? m_movieItem->GetVideoInfoTag()->m_iSeason : -1;
-    m_movieItem->GetVideoInfoTag()->m_strPictureURL.GetThumbURLs(thumbs, type, season);
+    m_movieItem->GetVideoInfoTag()->m_strPictureURL.GetThumbUrls(thumbs, type, season);
 
     for (unsigned int i = 0; i < thumbs.size(); ++i)
     {
@@ -1951,7 +1951,7 @@ bool CGUIDialogVideoInfo::ManageVideoItemArtwork(const CFileItemPtr &item, const
     if (type == MediaTypeSeason)
     {
       videodb.GetTvShowInfo("", tag, item->GetVideoInfoTag()->m_iIdShow);
-      tag.m_strPictureURL.GetThumbURLs(thumbs, artType, item->GetVideoInfoTag()->m_iSeason);
+      tag.m_strPictureURL.GetThumbUrls(thumbs, artType, item->GetVideoInfoTag()->m_iSeason);
     }
     else if (type == MediaTypeVideoCollection)
     {
@@ -1963,14 +1963,14 @@ bool CGUIDialogVideoInfo::ManageVideoItemArtwork(const CFileItemPtr &item, const
         {
           CVideoInfoTag* pTag = items[i]->GetVideoInfoTag();
           pTag->m_strPictureURL.Parse();
-          pTag->m_strPictureURL.GetThumbURLs(thumbs, "set." + artType, -1, true);
+          pTag->m_strPictureURL.GetThumbUrls(thumbs, "set." + artType, -1, true);
         }
       }
     }
     else
     {
       tag = *item->GetVideoInfoTag();
-      tag.m_strPictureURL.GetThumbURLs(thumbs, artType);
+      tag.m_strPictureURL.GetThumbUrls(thumbs, artType);
     }
 
     for (size_t i = 0; i < thumbs.size(); i++)
diff --git a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
index 13a9cf083031..cc42552317bb 100644
--- a/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
+++ b/xbmc/video/jobs/VideoLibraryRefreshingJob.cpp
@@ -154,7 +154,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
       hasDetails = true;
 
     // if we don't have an url or need to refresh anyway do the web search
-    if (!hasDetails && (needsRefresh || scraperUrl.m_url.empty()))
+    if (!hasDetails && (needsRefresh || !scraperUrl.HasUrls()))
     {
       SetTitle(StringUtils::Format(g_localizeStrings.Get(197).c_str(), scraper->Name().c_str()));
       SetText(itemTitle);
@@ -213,7 +213,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
           }
 
           CLog::Log(LOGDEBUG, "CVideoLibraryRefreshingJob: user selected item '%s' with URL '%s'",
-                    scraperUrl.GetTitle().c_str(), scraperUrl.m_url.at(0).m_url.c_str());
+                    scraperUrl.GetTitle().c_str(), scraperUrl.GetFirstThumbUrl());
         }
       }
       else if (result < 0 || !VIDEO::CVideoInfoScanner::DownloadFailed(GetProgressDialog()))
@@ -225,7 +225,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
 
     // if the URL is still empty, check whether or not we're allowed
     // to prompt and ask the user to input a new search title
-    if (!hasDetails && scraperUrl.m_url.empty())
+    if (!hasDetails && !scraperUrl.HasUrls())
     {
       if (IsModal())
       {
@@ -333,7 +333,7 @@ bool CVideoLibraryRefreshingJob::Work(CVideoDatabase &db)
     CVideoInfoScanner scanner;
     if (!scanner.RetrieveVideoInfo(items, scanSettings.parent_name,
                                    scraper->Content(), !ignoreNfo,
-                                   scraperUrl.m_url.empty() ? NULL : &scraperUrl,
+                                   scraperUrl.HasUrls() ? &scraperUrl : nullptr,
                                    m_refreshAll, GetProgressDialog()))
     {
       // something went wrong

From bae03d241ef7572187b2e7bd064584e786370ad1 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 7 May 2020 22:29:23 +0200
Subject: [PATCH 08/10] [utils] CScraperUrl: refactor parsing methods

---
 xbmc/addons/Scraper.cpp             |  32 ++++----
 xbmc/interfaces/legacy/ListItem.cpp |   3 +-
 xbmc/music/Album.cpp                |   2 +-
 xbmc/music/Artist.cpp               |   2 +-
 xbmc/music/MusicDatabase.cpp        |   4 +-
 xbmc/utils/ScraperUrl.cpp           | 118 +++++++++++++---------------
 xbmc/utils/ScraperUrl.h             |  22 +++---
 xbmc/utils/test/TestScraperUrl.cpp  |   2 +-
 xbmc/video/VideoDatabase.cpp        |   6 +-
 xbmc/video/VideoInfoScanner.cpp     |   2 +-
 xbmc/video/VideoInfoTag.cpp         |   6 +-
 11 files changed, 97 insertions(+), 102 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index 958883382b3c..d4d35af06c47 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -267,7 +267,7 @@ std::vector<std::string> CScraper::Run(const std::string &function,
           extras.emplace_back(xchain->FirstChild()->Value());
       }
       else
-        scrURL2.ParseElement(xchain);
+        scrURL2.ParseAndAppendUrl(xchain);
       // Fix for empty chains. $$1 would still contain the
       // previous value as there is no child of the xml node.
       // since $$1 will always either contain the data from an
@@ -494,9 +494,9 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
         continue;
 
       if (pxeUrl)
-        scurlRet.ParseElement(pxeUrl);
+        scurlRet.ParseAndAppendUrl(pxeUrl);
       else if (!strcmp(doc.RootElement()->Value(), "url"))
-        scurlRet.ParseElement(doc.RootElement());
+        scurlRet.ParseAndAppendUrl(doc.RootElement());
       else
         continue;
       break;
@@ -518,7 +518,7 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
     CFileItem item("resolve me", false);
 
     if (XFILE::CPluginDirectory::GetPluginResult(str.str(), item, false))
-      scurlRet.ParseString(item.GetDynPath());
+      scurlRet.ParseFromData(item.GetDynPath());
 
     return scurlRet;
   }
@@ -570,9 +570,9 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
         continue;
 
       if (pxeUrl)
-        scurlRet.ParseElement(pxeUrl);
+        scurlRet.ParseAndAppendUrl(pxeUrl);
       else if (!strcmp(doc.RootElement()->Value(), "url"))
-        scurlRet.ParseElement(doc.RootElement());
+        scurlRet.ParseAndAppendUrl(doc.RootElement());
       else
         continue;
       break;
@@ -700,7 +700,7 @@ static void ParseThumbs(CScraperUrl &scurl,
     std::string url = FromString(item, prefix.str() + ".url");
     std::string aspect = FromString(item, prefix.str() + ".aspect");
     std::string preview = FromString(item, prefix.str() + ".preview");
-    scurl.AddElement(url, aspect, preview);
+    scurl.AddParsedUrl(url, aspect, preview);
   }
 }
 
@@ -890,7 +890,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
     CLog::Log(LOGDEBUG, "%s: CreateSearchUrl failed", __FUNCTION__);
     throw CScraperError();
   }
-  scurl.ParseString(vcsOut[0]);
+  scurl.ParseFromData(vcsOut[0]);
 
   // do the search, and parse the result into a list
   vcsIn.clear();
@@ -940,7 +940,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
           scurlMovie.SetId(id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
-          scurlMovie.ParseElement(pxeLink);
+          scurlMovie.ParseAndAppendUrl(pxeLink);
 
         // calculate the relevance of this hit
         std::string sCompareTitle = scurlMovie.GetTitle();
@@ -1025,7 +1025,7 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
 
   if (vcsOut.empty() || vcsOut[0].empty())
     return vcali;
-  scurl.ParseString(vcsOut[0]);
+  scurl.ParseFromData(vcsOut[0]);
 
   // the next function is passed the contents of the returned URL, and returns
   // an empty string on failure; on success, returns XML matches in the form:
@@ -1070,9 +1070,9 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
         TiXmlElement *pxeLink = pxeAlbum->FirstChildElement("url");
         CScraperUrl scurlAlbum;
         if (!pxeLink)
-          scurlAlbum.ParseString(scurl.GetData());
+          scurlAlbum.ParseFromData(scurl.GetData());
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
-          scurlAlbum.ParseElement(pxeLink);
+          scurlAlbum.ParseAndAppendUrl(pxeLink);
 
         if (!scurlAlbum.HasUrls())
           continue;
@@ -1122,7 +1122,7 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
 
   if (vcsOut.empty() || vcsOut[0].empty())
     return vcari;
-  scurl.ParseString(vcsOut[0]);
+  scurl.ParseFromData(vcsOut[0]);
 
   // the next function is passed the contents of the returned URL, and returns
   // an empty string on failure; on success, returns XML matches in the form:
@@ -1159,9 +1159,9 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
 
         TiXmlElement *pxeLink = pxeArtist->FirstChildElement("url");
         if (!pxeLink)
-          scurlArtist.ParseString(scurl.GetData());
+          scurlArtist.ParseFromData(scurl.GetData());
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
-          scurlArtist.ParseElement(pxeLink);
+          scurlArtist.ParseAndAppendUrl(pxeLink);
 
         if (!scurlArtist.HasUrls())
           continue;
@@ -1263,7 +1263,7 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
           scurlEp.SetId(id);
 
         for (; pxeLink && pxeLink->FirstChild(); pxeLink = pxeLink->NextSiblingElement("url"))
-          scurlEp.ParseElement(pxeLink);
+          scurlEp.ParseAndAppendUrl(pxeLink);
 
         // date must be the format of yyyy-mm-dd
         ep.cDate.SetValid(false);
diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 17d3b4ede9b5..f73df260bbb2 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -691,7 +691,8 @@ namespace XBMCAddon
     void ListItem::addAvailableArtwork(std::string url, std::string art_type, std::string preview, std::string referrer, std::string cache, bool post, bool isgz, int season)
     {
       XBMCAddonUtils::GuiLock lock(languageHook, m_offscreen);
-      GetVideoInfoTag()->m_strPictureURL.AddElement(url, art_type, preview, referrer, cache, post, isgz, season);
+      GetVideoInfoTag()->m_strPictureURL.AddParsedUrl(url, art_type, preview, referrer, cache, post,
+                                                      isgz, season);
     }
 
     void ListItem::addStreamInfo(const char* cType, const Properties& dictionary)
diff --git a/xbmc/music/Album.cpp b/xbmc/music/Album.cpp
index a5ddc9966208..eb250bad47bc 100644
--- a/xbmc/music/Album.cpp
+++ b/xbmc/music/Album.cpp
@@ -533,7 +533,7 @@ bool CAlbum::Load(const TiXmlElement *album, bool append, bool prioritise)
   const TiXmlElement* thumb = album->FirstChildElement("thumb");
   while (thumb)
   {
-    thumbURL.ParseElement(thumb);
+    thumbURL.ParseAndAppendUrl(thumb);
     if (prioritise)
     {
       std::string temp;
diff --git a/xbmc/music/Artist.cpp b/xbmc/music/Artist.cpp
index 34ec5c2f9e91..3d3d95fffa01 100644
--- a/xbmc/music/Artist.cpp
+++ b/xbmc/music/Artist.cpp
@@ -98,7 +98,7 @@ bool CArtist::Load(const TiXmlElement *artist, bool append, bool prioritise)
   const TiXmlElement* thumb = artist->FirstChildElement("thumb");
   while (thumb)
   {
-    thumbURL.ParseElement(thumb);
+    thumbURL.ParseAndAppendUrl(thumb);
     if (prioritise)
     {
       std::string temp;
diff --git a/xbmc/music/MusicDatabase.cpp b/xbmc/music/MusicDatabase.cpp
index 1631ce53777a..a553cda927b1 100644
--- a/xbmc/music/MusicDatabase.cpp
+++ b/xbmc/music/MusicDatabase.cpp
@@ -2468,7 +2468,7 @@ CAlbum CMusicDatabase::GetAlbumFromDataset(const dbiplus::sql_record* const reco
   album.strOrigReleaseDate = record->at(offset + album_strOrigReleaseDate).get_asString();
   album.bBoxedSet = record->at(offset + album_bBoxedSet).get_asInt() == 1;
   if (imageURL)
-    album.thumbURL.ParseString(record->at(offset + album_strThumbURL).get_asString());
+    album.thumbURL.ParseFromData(record->at(offset + album_strThumbURL).get_asString());
   album.fRating = record->at(offset + album_fRating).get_asFloat();
   album.iUserrating = record->at(offset + album_iUserrating).get_asInt();
   album.iVotes = record->at(offset + album_iVotes).get_asInt();
@@ -2550,7 +2550,7 @@ CArtist CMusicDatabase::GetArtistFromDataset(const dbiplus::sql_record* const re
   {
     artist.fanart.m_xml = record->at(artist_strFanart).get_asString();
     artist.fanart.Unpack();
-    artist.thumbURL.ParseString(record->at(artist_strImage).get_asString());
+    artist.thumbURL.ParseFromData(record->at(artist_strImage).get_asString());
   }
 
   return artist;
diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index 77b601f3e14c..68bc1a441836 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -33,12 +33,12 @@ CScraperUrl::CScraperUrl() : m_relevance(0.0)
 
 CScraperUrl::CScraperUrl(std::string strUrl) : CScraperUrl()
 {
-  ParseString(std::move(strUrl));
+  ParseFromData(std::move(strUrl));
 }
 
 CScraperUrl::CScraperUrl(const TiXmlElement* element) : CScraperUrl()
 {
-  ParseElement(element);
+  ParseAndAppendUrl(element);
 }
 
 CScraperUrl::~CScraperUrl() = default;
@@ -115,38 +115,67 @@ void CScraperUrl::GetThumbUrls(std::vector<std::string>& thumbs,
 
 bool CScraperUrl::Parse()
 {
-  auto strToParse = m_data;
+  auto dataToParse = m_data;
   m_data.clear();
-  return ParseString(std::move(strToParse));
+  return ParseFromData(std::move(dataToParse));
 }
 
-bool CScraperUrl::ParseElement(const TiXmlElement* element)
+bool CScraperUrl::ParseFromData(std::string data)
 {
-  if (!element || !element->FirstChild() || !element->FirstChild()->Value())
+  if (data.empty())
+    return false;
+
+  CXBMCTinyXML doc;
+  /* strUrl is coming from internal sources (usually generated by scraper or from database)
+   * so strUrl is always in UTF-8 */
+  doc.Parse(data, TIXML_ENCODING_UTF8);
+
+  auto pElement = doc.RootElement();
+  if (pElement == nullptr)
+  {
+    m_urls.emplace_back(data);
+    m_data = data;
+  }
+  else
+  {
+    while (pElement != nullptr)
+    {
+      ParseAndAppendUrl(pElement);
+      pElement = pElement->NextSiblingElement(pElement->Value());
+    }
+  }
+
+  return true;
+}
+
+bool CScraperUrl::ParseAndAppendUrl(const TiXmlElement* element)
+{
+  if (element == nullptr || element->FirstChild() == nullptr ||
+      element->FirstChild()->Value() == nullptr)
     return false;
 
   std::stringstream stream;
   stream << *element;
   m_data += stream.str();
 
-  SUrlEntry url;
-  url.m_url = element->FirstChild()->Value();
+  SUrlEntry url(element->FirstChild()->ValueStr());
   url.m_spoof = XMLUtils::GetAttribute(element, "spoof");
+
   const char* szPost = element->Attribute("post");
   if (szPost && StringUtils::CompareNoCase(szPost, "yes") == 0)
     url.m_post = true;
   else
     url.m_post = false;
+
   const char* szIsGz = element->Attribute("gzip");
   if (szIsGz && StringUtils::CompareNoCase(szIsGz, "yes") == 0)
     url.m_isgz = true;
   else
     url.m_isgz = false;
+
   url.m_cache = XMLUtils::GetAttribute(element, "cache");
 
   const char* szType = element->Attribute("type");
-  url.m_type = UrlType::General;
-  url.m_season = -1;
   if (szType && StringUtils::CompareNoCase(szType, "season") == 0)
   {
     url.m_type = UrlType::Season;
@@ -154,6 +183,7 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
     if (szSeason)
       url.m_season = atoi(szSeason);
   }
+
   url.m_aspect = XMLUtils::GetAttribute(element, "aspect");
 
   m_urls.push_back(url);
@@ -161,51 +191,17 @@ bool CScraperUrl::ParseElement(const TiXmlElement* element)
   return true;
 }
 
-bool CScraperUrl::ParseString(std::string strUrl)
-{
-  if (strUrl.empty())
-    return false;
-
-  CXBMCTinyXML doc;
-  /* strUrl is coming from internal sources (usually generated by scraper or from database)
-   * so strUrl is always in UTF-8 */
-  doc.Parse(strUrl, TIXML_ENCODING_UTF8);
-
-  auto pElement = doc.RootElement();
-  if (pElement == nullptr)
-  {
-    SUrlEntry url;
-    url.m_url = strUrl;
-    url.m_type = UrlType::General;
-    url.m_season = -1;
-    url.m_post = false;
-    url.m_isgz = false;
-    m_urls.push_back(url);
-    m_data = strUrl;
-  }
-  else
-  {
-    while (pElement != nullptr)
-    {
-      ParseElement(pElement);
-      pElement = pElement->NextSiblingElement(pElement->Value());
-    }
-  }
-
-  return true;
-}
-
 // XML format is of strUrls is:
 // <TAG><url>...</url>...</TAG> (parsed by ParseElement) or <url>...</url> (ditto)
-bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
+bool CScraperUrl::ParseAndAppendUrlsFromEpisodeGuide(std::string episodeGuide)
 {
-  if (strUrls.empty())
+  if (episodeGuide.empty())
     return false;
 
   // ok, now parse the xml file
   CXBMCTinyXML doc;
   /* strUrls is coming from internal sources so strUrls is always in UTF-8 */
-  doc.Parse(strUrls, TIXML_ENCODING_UTF8);
+  doc.Parse(episodeGuide, TIXML_ENCODING_UTF8);
   if (doc.RootElement() != nullptr)
   {
     TiXmlHandle docHandle(&doc);
@@ -213,10 +209,10 @@ bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
     if (link->FirstChildElement("url"))
     {
       for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
-        ParseElement(link);
+        ParseAndAppendUrl(link);
     }
     else if (link->FirstChild() && link->FirstChild()->Value())
-      ParseElement(link);
+      ParseAndAppendUrl(link);
   }
   else
     return false;
@@ -224,14 +220,14 @@ bool CScraperUrl::ParseEpisodeGuide(std::string strUrls)
   return true;
 }
 
-void CScraperUrl::AddElement(std::string url,
-                             std::string aspect,
-                             std::string preview,
-                             std::string referrer,
-                             std::string cache,
-                             bool post,
-                             bool isgz,
-                             int season)
+void CScraperUrl::AddParsedUrl(std::string url,
+                               std::string aspect,
+                               std::string preview,
+                               std::string referrer,
+                               std::string cache,
+                               bool post,
+                               bool isgz,
+                               int season)
 {
   TiXmlElement thumb("thumb");
   thumb.SetAttribute("spoof", referrer);
@@ -249,9 +245,10 @@ void CScraperUrl::AddElement(std::string url,
   thumb.SetAttribute("preview", preview);
   TiXmlText text(url);
   thumb.InsertEndChild(text);
+
   m_data << thumb;
-  SUrlEntry nUrl;
-  nUrl.m_url = url;
+
+  SUrlEntry nUrl(url);
   nUrl.m_spoof = referrer;
   nUrl.m_post = post;
   nUrl.m_isgz = isgz;
@@ -261,9 +258,6 @@ void CScraperUrl::AddElement(std::string url,
     nUrl.m_type = UrlType::Season;
     nUrl.m_season = season;
   }
-  else
-    nUrl.m_type = UrlType::General;
-
   nUrl.m_aspect = aspect;
 
   m_urls.push_back(nUrl);
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 83651bb0cbe8..07cf67396361 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -87,17 +87,17 @@ class CScraperUrl
                     bool unique = false) const;
 
   bool Parse();
-  bool ParseString(std::string strUrl); // copies by intention
-  bool ParseElement(const TiXmlElement* element);
-  bool ParseEpisodeGuide(std::string strUrls); // copies by intention
-  void AddElement(std::string url,
-                  std::string aspect = "",
-                  std::string preview = "",
-                  std::string referrer = "",
-                  std::string cache = "",
-                  bool post = false,
-                  bool isgz = false,
-                  int season = -1);
+  bool ParseFromData(std::string data); // copies by intention
+  bool ParseAndAppendUrl(const TiXmlElement* element);
+  bool ParseAndAppendUrlsFromEpisodeGuide(std::string episodeGuide); // copies by intention
+  void AddParsedUrl(std::string url,
+                    std::string aspect = "",
+                    std::string preview = "",
+                    std::string referrer = "",
+                    std::string cache = "",
+                    bool post = false,
+                    bool isgz = false,
+                    int season = -1);
 
   /*! \brief fetch the full URL (including referrer) of a thumb
    \param URL entry to use to create the full URL
diff --git a/xbmc/utils/test/TestScraperUrl.cpp b/xbmc/utils/test/TestScraperUrl.cpp
index ecb5b14826e4..1feb18175dc9 100644
--- a/xbmc/utils/test/TestScraperUrl.cpp
+++ b/xbmc/utils/test/TestScraperUrl.cpp
@@ -21,7 +21,7 @@ TEST(TestScraperUrl, General)
               "  <someotherurl>\n"
               "  </someotherurl>\n"
               "</data>\n";
-  EXPECT_TRUE(a.ParseString(xmlstring));
+  EXPECT_TRUE(a.ParseFromData(xmlstring));
 
   const auto url = a.GetFirstUrlByType();
   EXPECT_STREQ("blah", url.m_spoof.c_str());
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index ce55296d2d04..5b0775bc9f06 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4312,7 +4312,7 @@ void CVideoDatabase::GetCast(int media_id, const std::string &media_type, std::v
       info.strName = m_pDS2->fv(0).get_asString();
       info.strRole = m_pDS2->fv(1).get_asString();
       info.order = m_pDS2->fv(2).get_asInt();
-      info.thumbUrl.ParseString(m_pDS2->fv(3).get_asString());
+      info.thumbUrl.ParseFromData(m_pDS2->fv(3).get_asString());
       info.thumb = m_pDS2->fv(4).get_asString();
       cast.emplace_back(std::move(info));
 
@@ -6669,7 +6669,7 @@ bool CVideoDatabase::GetPeopleNav(const std::string& strBaseDir, CFileItemList&
 
         pItem->m_bIsFolder=true;
         pItem->GetVideoInfoTag()->SetPlayCount(i.second.playcount);
-        pItem->GetVideoInfoTag()->m_strPictureURL.ParseString(i.second.thumb);
+        pItem->GetVideoInfoTag()->m_strPictureURL.ParseFromData(i.second.thumb);
         pItem->GetVideoInfoTag()->m_iDbId = i.first;
         pItem->GetVideoInfoTag()->m_type = type;
         pItem->GetVideoInfoTag()->m_relevance = i.second.appearances;
@@ -6690,7 +6690,7 @@ bool CVideoDatabase::GetPeopleNav(const std::string& strBaseDir, CFileItemList&
           pItem->SetPath(itemUrl.ToString());
 
           pItem->m_bIsFolder=true;
-          pItem->GetVideoInfoTag()->m_strPictureURL.ParseString(m_pDS->fv(2).get_asString());
+          pItem->GetVideoInfoTag()->m_strPictureURL.ParseFromData(m_pDS->fv(2).get_asString());
           pItem->GetVideoInfoTag()->m_iDbId = m_pDS->fv(0).get_asInt();
           pItem->GetVideoInfoTag()->m_type = type;
           if (idContent != VIDEODB_CONTENT_TVSHOWS)
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index 325957488997..6d1f7dbed559 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -1679,7 +1679,7 @@ namespace VIDEO
         if (!showInfo.m_strEpisodeGuide.empty())
         {
           CScraperUrl url;
-          url.ParseEpisodeGuide(showInfo.m_strEpisodeGuide);
+          url.ParseAndAppendUrlsFromEpisodeGuide(showInfo.m_strEpisodeGuide);
 
           if (pDlgProgress)
           {
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 1335110f3eea..8a1082e8ccec 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -446,7 +446,7 @@ void CVideoInfoTag::Archive(CArchive& ar)
       ar >> info.thumb;
       std::string strXml;
       ar >> strXml;
-      info.thumbUrl.ParseString(strXml);
+      info.thumbUrl.ParseFromData(strXml);
       m_cast.push_back(info);
     }
 
@@ -974,7 +974,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
   const TiXmlElement* thumb = movie->FirstChildElement("thumb");
   while (thumb)
   {
-    m_strPictureURL.ParseElement(thumb);
+    m_strPictureURL.ParseAndAppendUrl(thumb);
     if (prioritise)
     {
       std::string temp;
@@ -1049,7 +1049,7 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
       const TiXmlElement* thumb = node->FirstChildElement("thumb");
       while (thumb)
       {
-        info.thumbUrl.ParseElement(thumb);
+        info.thumbUrl.ParseAndAppendUrl(thumb);
         thumb = thumb->NextSiblingElement("thumb");
       }
       const char* clear=node->Attribute("clear");

From 39eaa7f3e102a6ff07f1ef85cb812a41d273a5b9 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 8 May 2020 15:06:46 +0200
Subject: [PATCH 09/10] [utils] CScraperUrl: avoid parsing the same data
 multiple times

---
 xbmc/utils/ScraperUrl.cpp | 48 +++++++++++++++++++++++++++++----------
 xbmc/utils/ScraperUrl.h   |  3 ++-
 2 files changed, 38 insertions(+), 13 deletions(-)

diff --git a/xbmc/utils/ScraperUrl.cpp b/xbmc/utils/ScraperUrl.cpp
index 68bc1a441836..f242a40f57ff 100644
--- a/xbmc/utils/ScraperUrl.cpp
+++ b/xbmc/utils/ScraperUrl.cpp
@@ -27,7 +27,7 @@
 #include <cstring>
 #include <sstream>
 
-CScraperUrl::CScraperUrl() : m_relevance(0.0)
+CScraperUrl::CScraperUrl() : m_relevance(0.0), m_parsed(false)
 {
 }
 
@@ -48,6 +48,13 @@ void CScraperUrl::Clear()
   m_urls.clear();
   m_data.clear();
   m_relevance = 0.0;
+  m_parsed = false;
+}
+
+void CScraperUrl::SetData(std::string data)
+{
+  m_data = std::move(data);
+  m_parsed = false;
 }
 
 const CScraperUrl::SUrlEntry CScraperUrl::GetFirstUrlByType(const std::string& type) const
@@ -115,6 +122,9 @@ void CScraperUrl::GetThumbUrls(std::vector<std::string>& thumbs,
 
 bool CScraperUrl::Parse()
 {
+  if (m_parsed)
+    return true;
+
   auto dataToParse = m_data;
   m_data.clear();
   return ParseFromData(std::move(dataToParse));
@@ -145,6 +155,7 @@ bool CScraperUrl::ParseFromData(std::string data)
     }
   }
 
+  m_parsed = true;
   return true;
 }
 
@@ -154,6 +165,8 @@ bool CScraperUrl::ParseAndAppendUrl(const TiXmlElement* element)
       element->FirstChild()->Value() == nullptr)
     return false;
 
+  bool wasEmpty = m_data.empty();
+
   std::stringstream stream;
   stream << *element;
   m_data += stream.str();
@@ -188,6 +201,9 @@ bool CScraperUrl::ParseAndAppendUrl(const TiXmlElement* element)
 
   m_urls.push_back(url);
 
+  if (wasEmpty)
+    m_parsed = true;
+
   return true;
 }
 
@@ -202,20 +218,23 @@ bool CScraperUrl::ParseAndAppendUrlsFromEpisodeGuide(std::string episodeGuide)
   CXBMCTinyXML doc;
   /* strUrls is coming from internal sources so strUrls is always in UTF-8 */
   doc.Parse(episodeGuide, TIXML_ENCODING_UTF8);
-  if (doc.RootElement() != nullptr)
+  if (doc.RootElement() == nullptr)
+    return false;
+
+  bool wasEmpty = m_data.empty();
+
+  TiXmlHandle docHandle(&doc);
+  auto link = docHandle.FirstChild("episodeguide").Element();
+  if (link->FirstChildElement("url"))
   {
-    TiXmlHandle docHandle(&doc);
-    auto link = docHandle.FirstChild("episodeguide").Element();
-    if (link->FirstChildElement("url"))
-    {
-      for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
-        ParseAndAppendUrl(link);
-    }
-    else if (link->FirstChild() && link->FirstChild()->Value())
+    for (link = link->FirstChildElement("url"); link; link = link->NextSiblingElement("url"))
       ParseAndAppendUrl(link);
   }
-  else
-    return false;
+  else if (link->FirstChild() && link->FirstChild()->Value())
+    ParseAndAppendUrl(link);
+
+  if (wasEmpty)
+    m_parsed = true;
 
   return true;
 }
@@ -229,6 +248,8 @@ void CScraperUrl::AddParsedUrl(std::string url,
                                bool isgz,
                                int season)
 {
+  bool wasEmpty = m_data.empty();
+
   TiXmlElement thumb("thumb");
   thumb.SetAttribute("spoof", referrer);
   thumb.SetAttribute("cache", cache);
@@ -261,6 +282,9 @@ void CScraperUrl::AddParsedUrl(std::string url,
   nUrl.m_aspect = aspect;
 
   m_urls.push_back(nUrl);
+
+  if (wasEmpty)
+    m_parsed = true;
 }
 
 std::string CScraperUrl::GetThumbUrl(const CScraperUrl::SUrlEntry& entry)
diff --git a/xbmc/utils/ScraperUrl.h b/xbmc/utils/ScraperUrl.h
index 07cf67396361..f6c13bacf723 100644
--- a/xbmc/utils/ScraperUrl.h
+++ b/xbmc/utils/ScraperUrl.h
@@ -53,7 +53,7 @@ class CScraperUrl
 
   bool HasData() const { return !m_data.empty(); }
   const std::string& GetData() const { return m_data; }
-  void SetData(std::string data) { m_data = std::move(data); }
+  void SetData(std::string data);
 
   const std::string& GetTitle() const { return m_title; }
   void SetTitle(std::string title) { m_title = std::move(title); }
@@ -118,4 +118,5 @@ class CScraperUrl
   std::string m_id;
   double m_relevance;
   std::vector<SUrlEntry> m_urls;
+  bool m_parsed;
 };

From 63b1fa09e365553e422636ef13b195294a5b7e43 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 8 May 2020 15:07:16 +0200
Subject: [PATCH 10/10] [video] only parse CVideoInfoTag::m_strPictureURL if
 really needed

---
 xbmc/interfaces/legacy/InfoTagVideo.cpp   |  3 ++-
 xbmc/video/VideoDatabase.cpp              | 20 +++++++-------------
 xbmc/video/VideoInfoTag.cpp               |  2 ++
 xbmc/video/dialogs/GUIDialogVideoInfo.cpp |  3 +++
 4 files changed, 14 insertions(+), 14 deletions(-)

diff --git a/xbmc/interfaces/legacy/InfoTagVideo.cpp b/xbmc/interfaces/legacy/InfoTagVideo.cpp
index 7ea8957958c0..38100e0eafca 100644
--- a/xbmc/interfaces/legacy/InfoTagVideo.cpp
+++ b/xbmc/interfaces/legacy/InfoTagVideo.cpp
@@ -70,7 +70,8 @@ namespace XBMCAddon
 
     String InfoTagVideo::getPictureURL()
     {
-      return infoTag->m_strPictureURL.GetFirstUrlByType().m_url;
+      infoTag->m_strPictureURL.Parse();
+      return infoTag->m_strPictureURL.GetFirstThumbUrl();
     }
 
     String InfoTagVideo::getTVShowTitle()
diff --git a/xbmc/video/VideoDatabase.cpp b/xbmc/video/VideoDatabase.cpp
index 5b0775bc9f06..c852aa0aa417 100644
--- a/xbmc/video/VideoDatabase.cpp
+++ b/xbmc/video/VideoDatabase.cpp
@@ -4039,8 +4039,6 @@ CVideoInfoTag CVideoDatabase::GetDetailsForMovie(const dbiplus::sql_record* cons
     if (getDetails & VideoDbDetailsUniqueID)
      GetUniqueIDs(details.m_iDbId, MediaTypeMovie, details);
 
-    details.m_strPictureURL.Parse();
-
     if (getDetails & VideoDbDetailsShowLink)
     {
       // create tvshowlink string
@@ -4119,8 +4117,6 @@ CVideoInfoTag CVideoDatabase::GetDetailsForTvShow(const dbiplus::sql_record* con
     if (getDetails & VideoDbDetailsUniqueID)
       GetUniqueIDs(details.m_iDbId, MediaTypeTvShow, details);
 
-    details.m_strPictureURL.Parse();
-
     details.m_parsedDetails = getDetails;
   }
 
@@ -4218,8 +4214,6 @@ CVideoInfoTag CVideoDatabase::GetDetailsForEpisode(const dbiplus::sql_record* co
     if (getDetails & VideoDbDetailsUniqueID)
       GetUniqueIDs(details.m_iDbId, MediaTypeEpisode, details);
 
-    details.m_strPictureURL.Parse();
-
     if (getDetails &  VideoDbDetailsBookmark)
       GetBookMarkForEpisode(details, details.m_EpBookmark);
 
@@ -4274,8 +4268,6 @@ CVideoInfoTag CVideoDatabase::GetDetailsForMusicVideo(const dbiplus::sql_record*
     if (getDetails & VideoDbDetailsTag)
       GetTags(details.m_iDbId, MediaTypeMusicVideo, details.m_tags);
 
-    details.m_strPictureURL.Parse();
-
     if (getDetails & VideoDbDetailsStream)
       GetStreamDetails(details);
 
@@ -4764,15 +4756,19 @@ bool CVideoDatabase::GetArtTypes(const MediaType &mediaType, std::vector<std::st
 
 namespace
 {
-std::vector<std::string> GetBasicItemAvailableArtTypes(const CVideoInfoTag& tag)
+std::vector<std::string> GetBasicItemAvailableArtTypes(int mediaId,
+                                                       VIDEODB_CONTENT_TYPE dbType,
+                                                       CVideoDatabase& db)
 {
   std::vector<std::string> result;
+  CVideoInfoTag tag = db.GetDetailsByTypeAndId(dbType, mediaId);
 
   //! @todo artwork: fanart stored separately, doesn't need to be
   if (tag.m_fanart.GetNumFanarts() && std::find(result.cbegin(), result.cend(), "fanart") == result.cend())
     result.emplace_back("fanart");
 
   // all other images
+  tag.m_strPictureURL.Parse();
   for (const auto& urlEntry : tag.m_strPictureURL.GetUrls())
   {
     std::string artType = urlEntry.m_aspect;
@@ -4797,6 +4793,7 @@ std::vector<std::string> GetSeasonAvailableArtTypes(int mediaId, CVideoDatabase&
 
   CVideoInfoTag sourceShow;
   db.GetTvShowInfo("", sourceShow, tag.m_iIdShow);
+  sourceShow.m_strPictureURL.Parse();
   for (const auto& urlEntry : sourceShow.m_strPictureURL.GetUrls())
   {
     std::string artType = urlEntry.m_aspect;
@@ -4852,10 +4849,7 @@ std::vector<std::string> CVideoDatabase::GetAvailableArtTypesForItem(int mediaId
     dbType = VIDEODB_CONTENT_MUSICVIDEOS;
 
   if (dbType != VIDEODB_CONTENT_UNKNOWN)
-  {
-    CVideoInfoTag tag = GetDetailsByTypeAndId(dbType, mediaId);
-    return GetBasicItemAvailableArtTypes(tag);
-  }
+    return GetBasicItemAvailableArtTypes(mediaId, dbType, *this);
   if (mediaType == MediaTypeSeason)
     return GetSeasonAvailableArtTypes(mediaId, *this);
   if (mediaType == MediaTypeVideoCollection)
diff --git a/xbmc/video/VideoInfoTag.cpp b/xbmc/video/VideoInfoTag.cpp
index 8a1082e8ccec..9a715cac51b6 100644
--- a/xbmc/video/VideoInfoTag.cpp
+++ b/xbmc/video/VideoInfoTag.cpp
@@ -968,6 +968,8 @@ void CVideoInfoTag::ParseNative(const TiXmlElement* movie, bool prioritise)
   if (XMLUtils::GetString(movie, "basepath", value))
     SetBasePath(value);
 
+  // make sure the picture URLs have been parsed
+  m_strPictureURL.Parse();
   size_t iThumbCount = m_strPictureURL.GetUrls().size();
   std::string xmlAdd = m_strPictureURL.GetData();
 
diff --git a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
index ebf5c46a3ff8..253289ce7312 100644
--- a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
@@ -824,6 +824,7 @@ void CGUIDialogVideoInfo::OnGetArt()
     }
 
     // Grab the thumbnails from the web
+    m_movieItem->GetVideoInfoTag()->m_strPictureURL.Parse();
     std::vector<std::string> thumbs;
     int season = (m_movieItem->GetVideoInfoTag()->m_type == MediaTypeSeason) ? m_movieItem->GetVideoInfoTag()->m_iSeason : -1;
     m_movieItem->GetVideoInfoTag()->m_strPictureURL.GetThumbUrls(thumbs, type, season);
@@ -1951,6 +1952,7 @@ bool CGUIDialogVideoInfo::ManageVideoItemArtwork(const CFileItemPtr &item, const
     if (type == MediaTypeSeason)
     {
       videodb.GetTvShowInfo("", tag, item->GetVideoInfoTag()->m_iIdShow);
+      tag.m_strPictureURL.Parse();
       tag.m_strPictureURL.GetThumbUrls(thumbs, artType, item->GetVideoInfoTag()->m_iSeason);
     }
     else if (type == MediaTypeVideoCollection)
@@ -1970,6 +1972,7 @@ bool CGUIDialogVideoInfo::ManageVideoItemArtwork(const CFileItemPtr &item, const
     else
     {
       tag = *item->GetVideoInfoTag();
+      tag.m_strPictureURL.Parse();
       tag.m_strPictureURL.GetThumbUrls(thumbs, artType);
     }
 
