From 2b423d4582237551f978c87dd1b327cd6652a732 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 19 Dec 2019 00:28:43 +0100
Subject: [PATCH 1/3] [settings/lib] add ISettingsValueSerializer interface

---
 xbmc/settings/lib/CMakeLists.txt             |  1 +
 xbmc/settings/lib/ISettingsValueSerializer.h | 21 ++++++++++++++++++++
 2 files changed, 22 insertions(+)
 create mode 100644 xbmc/settings/lib/ISettingsValueSerializer.h

diff --git a/xbmc/settings/lib/CMakeLists.txt b/xbmc/settings/lib/CMakeLists.txt
index 628d39e5f232..de1e6e0bf1fd 100644
--- a/xbmc/settings/lib/CMakeLists.txt
+++ b/xbmc/settings/lib/CMakeLists.txt
@@ -15,6 +15,7 @@ set(HEADERS ISetting.h
             ISettingControlCreator.h
             ISettingCreator.h
             ISettingsHandler.h
+            ISettingsValueSerializer.h
             ISubSettings.h
             Setting.h
             SettingCategoryAccess.h
diff --git a/xbmc/settings/lib/ISettingsValueSerializer.h b/xbmc/settings/lib/ISettingsValueSerializer.h
new file mode 100644
index 000000000000..94bf66405625
--- /dev/null
+++ b/xbmc/settings/lib/ISettingsValueSerializer.h
@@ -0,0 +1,21 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include <string>
+
+class CSettingsManager;
+
+class ISettingsValueSerializer
+{
+public:
+  virtual ~ISettingsValueSerializer() = default;
+
+  virtual std::string SerializeValues(const CSettingsManager* settingsManager) const = 0;
+};

From 6a5362c4087c00dfb0382e1c7c49378e757e58b2 Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Thu, 19 Dec 2019 00:30:01 +0100
Subject: [PATCH 2/3] [settings] add JSON serialization implementation of
 ISettingsValueSerializer

---
 xbmc/settings/CMakeLists.txt                  |   2 +
 .../SettingsValueFlatJsonSerializer.cpp       | 139 ++++++++++++++++++
 .../SettingsValueFlatJsonSerializer.h         |  40 +++++
 3 files changed, 181 insertions(+)
 create mode 100644 xbmc/settings/SettingsValueFlatJsonSerializer.cpp
 create mode 100644 xbmc/settings/SettingsValueFlatJsonSerializer.h

diff --git a/xbmc/settings/CMakeLists.txt b/xbmc/settings/CMakeLists.txt
index 461b893be0e8..44cbcbe07ae5 100644
--- a/xbmc/settings/CMakeLists.txt
+++ b/xbmc/settings/CMakeLists.txt
@@ -12,6 +12,7 @@ set(SOURCES AdvancedSettings.cpp
             SettingPath.cpp
             Settings.cpp
             SettingsBase.cpp
+            SettingsValueFlatJsonSerializer.cpp
             SettingUtils.cpp
             SkinSettings.cpp
             SettingsComponent.cpp)
@@ -31,6 +32,7 @@ set(HEADERS AdvancedSettings.h
             SettingPath.h
             Settings.h
             SettingsBase.h
+            SettingsValueFlatJsonSerializer.h
             SettingUtils.h
             SkinSettings.h
             SettingsComponent.h)
diff --git a/xbmc/settings/SettingsValueFlatJsonSerializer.cpp b/xbmc/settings/SettingsValueFlatJsonSerializer.cpp
new file mode 100644
index 000000000000..7ede4516b99d
--- /dev/null
+++ b/xbmc/settings/SettingsValueFlatJsonSerializer.cpp
@@ -0,0 +1,139 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "SettingsValueFlatJsonSerializer.h"
+
+#include "settings/lib/Setting.h"
+#include "settings/lib/SettingDefinitions.h"
+#include "settings/lib/SettingSection.h"
+#include "settings/lib/SettingType.h"
+#include "settings/lib/SettingsManager.h"
+#include "utils/JSONVariantWriter.h"
+#include "utils/log.h"
+
+CSettingsValueFlatJsonSerializer::CSettingsValueFlatJsonSerializer(bool compact /* = true */)
+  : m_compact(compact)
+{ }
+
+std::string CSettingsValueFlatJsonSerializer::SerializeValues(
+  const CSettingsManager* settingsManager) const
+{
+  if (settingsManager == nullptr)
+    return "";
+
+  CVariant root(CVariant::VariantTypeObject);
+
+  const auto sections = settingsManager->GetSections();
+  for (const auto& section : sections)
+    SerializeSection(root, section);
+
+  std::string result;
+  if (!CJSONVariantWriter::Write(root, result, m_compact))
+  {
+    CLog::Log(LOGWARNING,
+      "CSettingsValueFlatJsonSerializer: failed to serialize settings into JSON");
+    return "";
+  }
+
+  return result;
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeSection(
+  CVariant& parent, std::shared_ptr<CSettingSection> section) const
+{
+  if (section == nullptr)
+    return;
+
+  const auto categories = section->GetCategories();
+  for (const auto& category : categories)
+    SerializeCategory(parent, category);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeCategory(
+  CVariant& parent, std::shared_ptr<CSettingCategory> category) const
+{
+  if (category == nullptr)
+    return;
+
+  const auto groups = category->GetGroups();
+  for (const auto& group : groups)
+    SerializeGroup(parent, group);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeGroup(
+  CVariant& parent, std::shared_ptr<CSettingGroup> group) const
+{
+  if (group == nullptr)
+    return;
+
+  const auto settings = group->GetSettings();
+  for (const auto& setting : settings)
+    SerializeSetting(parent, setting);
+}
+
+void CSettingsValueFlatJsonSerializer::SerializeSetting(
+  CVariant& parent, std::shared_ptr<CSetting> setting) const
+{
+  if (setting == nullptr)
+    return;
+
+  // ignore references and action settings (which don't have a value)
+  if (setting->GetType() == SettingType::Reference || setting->GetType() == SettingType::Action)
+    return;
+
+  const auto valueObj = SerializeSettingValue(setting);
+  if (valueObj.isNull())
+    return;
+
+  parent[setting->GetId()] = valueObj;
+}
+
+CVariant CSettingsValueFlatJsonSerializer::SerializeSettingValue(
+  std::shared_ptr<CSetting> setting) const
+{
+  switch (setting->GetType())
+  {
+    case SettingType::Action:
+      return CVariant::ConstNullVariant;
+
+    case SettingType::Boolean:
+      return CVariant(std::static_pointer_cast<CSettingBool>(setting)->GetValue());
+
+    case SettingType::Integer:
+      return CVariant(std::static_pointer_cast<CSettingInt>(setting)->GetValue());
+
+    case SettingType::Number:
+      return CVariant(std::static_pointer_cast<CSettingNumber>(setting)->GetValue());
+
+    case SettingType::String:
+      return CVariant(std::static_pointer_cast<CSettingString>(setting)->GetValue());
+
+    case SettingType::List:
+    {
+      const auto settingList = std::static_pointer_cast<CSettingList>(setting);
+
+      CVariant settingListValuesObj(CVariant::VariantTypeArray);
+      const auto settingListValues = settingList->GetValue();
+      for (const auto& settingListValue : settingListValues)
+      {
+        const auto valueObj = SerializeSettingValue(settingListValue);
+        if (!valueObj.isNull())
+          settingListValuesObj.push_back(valueObj);
+      }
+
+      return settingListValuesObj;
+    }
+
+    case SettingType::Unknown:
+    default:
+      CLog::Log(LOGWARNING,
+        "CSettingsValueFlatJsonSerializer: failed to serialize setting \"{}\" with value \"{}\" " \
+        "of unknown type", setting->GetId(), setting->ToString());
+      return CVariant::ConstNullVariant;
+  }
+}
diff --git a/xbmc/settings/SettingsValueFlatJsonSerializer.h b/xbmc/settings/SettingsValueFlatJsonSerializer.h
new file mode 100644
index 000000000000..5708224b06f9
--- /dev/null
+++ b/xbmc/settings/SettingsValueFlatJsonSerializer.h
@@ -0,0 +1,40 @@
+/*
+ *  Copyright (C) 2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "settings/lib/ISettingsValueSerializer.h"
+#include "utils/Variant.h"
+
+#include <memory>
+
+class CSetting;
+class CSettingCategory;
+class CSettingGroup;
+class CSettingSection;
+
+class CSettingsValueFlatJsonSerializer : public ISettingsValueSerializer
+{
+public:
+  explicit CSettingsValueFlatJsonSerializer(bool compact = true);
+  ~CSettingsValueFlatJsonSerializer() = default;
+
+  void SetCompact(bool compact = true) { m_compact = compact; }
+
+  // implementation of ISettingsValueSerializer
+  std::string SerializeValues(const CSettingsManager* settingsManager) const override;
+
+private:
+  void SerializeSection(CVariant& parent, std::shared_ptr<CSettingSection> section) const;
+  void SerializeCategory(CVariant& parent, std::shared_ptr<CSettingCategory> category) const;
+  void SerializeGroup(CVariant& parent, std::shared_ptr<CSettingGroup> group) const;
+  void SerializeSetting(CVariant& parent, std::shared_ptr<CSetting> setting) const;
+  CVariant SerializeSettingValue(std::shared_ptr<CSetting> setting) const;
+
+  bool m_compact;
+};

From 1571fa76f00f87d55cba52635544171390afb22e Mon Sep 17 00:00:00 2001
From: montellese <montellese@kodi.tv>
Date: Fri, 20 Dec 2019 14:12:31 -0800
Subject: [PATCH 3/3] pass path settings as JSON to python scrapers (thanks
 @romanvm)

---
 xbmc/addons/Scraper.cpp | 49 ++++++++++++++++++++++++++++++++---------
 xbmc/addons/Scraper.h   |  8 +++++++
 2 files changed, 47 insertions(+), 10 deletions(-)

diff --git a/xbmc/addons/Scraper.cpp b/xbmc/addons/Scraper.cpp
index effb20d56764..5a45877c3fa7 100644
--- a/xbmc/addons/Scraper.cpp
+++ b/xbmc/addons/Scraper.cpp
@@ -12,6 +12,7 @@
 #include "ServiceBroker.h"
 #include "URL.h"
 #include "Util.h"
+#include "addons/settings/AddonSettings.h"
 #include "filesystem/CurlFile.h"
 #include "filesystem/Directory.h"
 #include "filesystem/File.h"
@@ -24,6 +25,7 @@
 #include "music/infoscanner/MusicArtistInfo.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/SettingsComponent.h"
+#include "settings/SettingsValueFlatJsonSerializer.h"
 #include "utils/CharsetConverter.h"
 #include "utils/ScraperParser.h"
 #include "utils/ScraperUrl.h"
@@ -346,6 +348,21 @@ std::string CScraper::InternalRun(const std::string &function,
   return m_parser.Parse(function, this);
 }
 
+std::string CScraper::GetPathSettingsAsJSON()
+{
+  static const std::string EmptyPathSettings = "{}";
+
+  if (!LoadSettings(false))
+    return EmptyPathSettings;
+
+  CSettingsValueFlatJsonSerializer jsonSerializer;
+  const auto json = jsonSerializer.SerializeValues(GetSettings()->GetSettingsManager());
+  if (json.empty())
+    return EmptyPathSettings;
+
+  return json;
+}
+
 bool CScraper::Load()
 {
   if (m_fLoaded || m_isPython)
@@ -430,8 +447,9 @@ CScraperUrl CScraper::NfoUrl(const std::string &sNfoContent)
   if (m_isPython)
   {
     std::stringstream str;
-    str << "plugin://" << ID() << "?action=NfoUrl&nfo="
-      << CURL::Encode(sNfoContent);
+    str << "plugin://" << ID() << "?action=NfoUrl&nfo=" << CURL::Encode(sNfoContent)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
+
     CFileItemList items;
     if (!XFILE::CDirectory::GetDirectory(str.str(), items, "", DIR_FLAG_DEFAULTS))
       return scurlRet;
@@ -513,7 +531,8 @@ CScraperUrl CScraper::ResolveIDToUrl(const std::string &externalID)
   if (m_isPython)
   {
     std::stringstream str;
-    str << "plugin://" << ID() << "?action=resolveid&key=" << CURL::Encode(externalID);
+    str << "plugin://" << ID() << "?action=resolveid&key=" << CURL::Encode(externalID)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
 
     CFileItem item("resolve me", false);
 
@@ -819,10 +838,12 @@ static bool PythonDetails(const std::string &ID,
                           const std::string &key,
                           const std::string &url,
                           const std::string &action,
+                          const std::string &pathSettings,
                           T &result)
 {
   std::stringstream str;
   str << "plugin://" << ID << "?action=" << action << "&" << key << "=" << CURL::Encode(url);
+  str << "&pathSettings=" << CURL::Encode(pathSettings);
 
   CFileItem item(url, false);
 
@@ -870,6 +891,7 @@ std::vector<CScraperUrl> CScraper::FindMovie(XFILE::CCurlFile &fcurl,
     std::map<std::string, std::string> additionals{{"title", sTitle}};
     if (!sYear.empty())
       additionals.insert({"year", sYear});
+    additionals.emplace("pathSettings", GetPathSettingsAsJSON());
     return PythonFind<CScraperUrl>(ID(), additionals);
   }
 
@@ -1000,7 +1022,8 @@ std::vector<CMusicAlbumInfo> CScraper::FindAlbum(CCurlFile &fcurl,
     return vcali;
 
   if (m_isPython)
-    return PythonFind<CMusicAlbumInfo>(ID(), {{"title", sAlbum}, {"artist", sArtist}});
+    return PythonFind<CMusicAlbumInfo>(ID(),
+      {{"title", sAlbum}, {"artist", sArtist}, {"pathSettings", GetPathSettingsAsJSON()}});
 
   // scraper function is given the album and artist as parameters and
   // returns an XML <url> element parseable by CScraperUrl
@@ -1100,7 +1123,8 @@ std::vector<CMusicArtistInfo> CScraper::FindArtist(CCurlFile &fcurl, const std::
     return vcari;
 
   if (m_isPython)
-    return PythonFind<CMusicArtistInfo>(ID(), {{"artist", sArtist}});
+    return PythonFind<CMusicArtistInfo>(ID(),
+      {{"artist", sArtist}, {"pathSettings", GetPathSettingsAsJSON()}});
 
   // scraper function is given the artist as parameter and
   // returns an XML <url> element parseable by CScraperUrl
@@ -1189,7 +1213,9 @@ EPISODELIST CScraper::GetEpisodeList(XFILE::CCurlFile &fcurl, const CScraperUrl
   {
     std::stringstream str;
     str << "plugin://" << ID()
-        << "?action=getepisodelist&url=" << CURL::Encode(scurl.m_url.front().m_url);
+        << "?action=getepisodelist&url=" << CURL::Encode(scurl.m_url.front().m_url)
+        << "&pathSettings=" << CURL::Encode(GetPathSettingsAsJSON());
+
     CFileItemList items;
     if (!XFILE::CDirectory::GetDirectory(str.str(), items, "", DIR_FLAG_DEFAULTS))
       return vcep;
@@ -1283,7 +1309,7 @@ bool CScraper::GetVideoDetails(XFILE::CCurlFile &fcurl,
 
   if (m_isPython)
     return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
-                         fMovie ? "getdetails" : "getepisodedetails", video);
+      fMovie ? "getdetails" : "getepisodedetails", GetPathSettingsAsJSON(), video);
 
   std::string sFunc = fMovie ? "GetDetails" : "GetEpisodeDetails";
   std::vector<std::string> vcsIn;
@@ -1326,7 +1352,8 @@ bool CScraper::GetAlbumDetails(CCurlFile &fcurl, const CScraperUrl &scurl, CAlbu
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url, "getdetails", album);
+    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+      "getdetails", GetPathSettingsAsJSON(), album);
 
   std::vector<std::string> vcsOut = RunNoThrow("GetAlbumDetails", scurl, fcurl);
 
@@ -1364,7 +1391,8 @@ bool CScraper::GetArtistDetails(CCurlFile &fcurl,
             Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "url", scurl.m_url.front().m_url, "getdetails", artist);
+    return PythonDetails(ID(), "url", scurl.m_url.front().m_url,
+      "getdetails", GetPathSettingsAsJSON(), artist);
 
   // pass in the original search string for chaining to search other sites
   std::vector<std::string> vcIn;
@@ -1402,7 +1430,8 @@ bool CScraper::GetArtwork(XFILE::CCurlFile &fcurl, CVideoInfoTag &details)
             ADDON::TranslateContent(Content()).c_str(), Version().asString().c_str());
 
   if (m_isPython)
-    return PythonDetails(ID(), "id", details.GetUniqueID(), "getartwork", details);
+    return PythonDetails(ID(), "id", details.GetUniqueID(),
+      "getartwork", GetPathSettingsAsJSON(), details);
 
   std::vector<std::string> vcsIn;
   CScraperUrl scurl;
diff --git a/xbmc/addons/Scraper.h b/xbmc/addons/Scraper.h
index ad73f8c04080..0881ec14a60f 100644
--- a/xbmc/addons/Scraper.h
+++ b/xbmc/addons/Scraper.h
@@ -152,6 +152,14 @@ class CScraper : public CAddon
   std::string SearchStringEncoding() const
     { return m_parser.GetSearchStringEncoding(); }
 
+  /*! \brief Get the scraper settings for a particular path in the form of a JSON string
+   Loads the default and user settings (if not already loaded) and returns the user settings in the
+   form of an JSON string. It is used in Python scrapers.
+   \return a string containing the JSON settings
+   \sa SetPathSettings
+   */
+  std::string GetPathSettingsAsJSON();
+
   bool Load();
   std::vector<std::string> Run(const std::string& function,
                               const CScraperUrl& url,
