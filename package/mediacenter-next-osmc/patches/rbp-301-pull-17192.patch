From e02554dce9d9caeac071fbc9d1a44fdf9f553eb6 Mon Sep 17 00:00:00 2001
From: djp952 <djp952@gmail.com>
Date: Tue, 14 Jan 2020 07:53:52 -0500
Subject: [PATCH] [PVR] Convert EPG First Aired from time_t to date string

---
 .../include/kodi/versions.h                   |   4 +-
 .../include/kodi/xbmc_epg_types.h             |   3 +-
 xbmc/pvr/addons/PVRClient.cpp                 |   9 +-
 xbmc/pvr/epg/EpgDatabase.cpp                  | 146 ++++++++++++++++--
 xbmc/pvr/epg/EpgDatabase.h                    |   2 +-
 xbmc/pvr/epg/EpgInfoTag.cpp                   |  20 ++-
 xbmc/pvr/epg/EpgInfoTag.h                     |  16 +-
 xbmc/pvr/guilib/guiinfo/PVRGUIInfo.cpp        |  21 ++-
 8 files changed, 167 insertions(+), 54 deletions(-)

diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index cbe4e5e6f077..9eae141d49e0 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -97,8 +97,8 @@
 #define ADDON_INSTANCE_VERSION_PERIPHERAL_DEPENDS     "addon-instance/Peripheral.h" \
                                                       "addon-instance/PeripheralUtils.h"
 
-#define ADDON_INSTANCE_VERSION_PVR                    "6.1.0"
-#define ADDON_INSTANCE_VERSION_PVR_MIN                "6.1.0"
+#define ADDON_INSTANCE_VERSION_PVR                    "6.2.0"
+#define ADDON_INSTANCE_VERSION_PVR_MIN                "6.2.0"
 #define ADDON_INSTANCE_VERSION_PVR_XML_ID             "kodi.binary.instance.pvr"
 #define ADDON_INSTANCE_VERSION_PVR_DEPENDS            "xbmc_pvr_dll.h" \
                                                       "xbmc_pvr_types.h" \
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_epg_types.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_epg_types.h
index 4197ed67b912..2fafa7a8b05a 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_epg_types.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/xbmc_epg_types.h
@@ -58,6 +58,7 @@ extern "C" {
   /* EPG_TAG.iFlags values */
   const unsigned int EPG_TAG_FLAG_UNDEFINED = 0x00000000; /*!< @brief nothing special to say about this entry */
   const unsigned int EPG_TAG_FLAG_IS_SERIES = 0x00000001; /*!< @brief this EPG entry is part of a series */
+  const unsigned int EPG_TAG_FLAG_IS_NEW    = 0x00000002; /*!< @brief this EPG entry will be flagged as new */
 
   /* Special EPG_TAG.iUniqueBroadcastId value */
 
@@ -97,7 +98,7 @@ extern "C" {
     int           iGenreType;          /*!< @brief (optional) genre type */
     int           iGenreSubType;       /*!< @brief (optional) genre sub type */
     const char *  strGenreDescription; /*!< @brief (optional) genre. Will be used only when iGenreType == EPG_GENRE_USE_STRING or iGenreSubType == EPG_GENRE_USE_STRING. Use EPG_STRING_TOKEN_SEPARATOR to separate different genres. */
-    time_t        firstAired;          /*!< @brief (optional) first aired in UTC */
+    const char *  strFirstAired;       /*!< @brief (optional) first aired date of the event. Used only for display purposes. Specify in W3C date format "YYYY-MM-DD". */
     int           iParentalRating;     /*!< @brief (optional) parental rating */
     int           iStarRating;         /*!< @brief (optional) star rating */
     int           iSeriesNumber;       /*!< @brief (optional) series number */
diff --git a/xbmc/pvr/addons/PVRClient.cpp b/xbmc/pvr/addons/PVRClient.cpp
index e00534d8c17b..2f15b57d4def 100644
--- a/xbmc/pvr/addons/PVRClient.cpp
+++ b/xbmc/pvr/addons/PVRClient.cpp
@@ -649,8 +649,11 @@ class CAddonEpgTag : public EPG_TAG
     startTime = t;
     kodiTag->EndAsUTC().GetAsTime(t);
     endTime = t;
-    kodiTag->FirstAiredAsUTC().GetAsTime(t);
-    firstAired = t;
+
+    const CDateTime firstAired = kodiTag->FirstAired();
+    if (firstAired.IsValid())
+      m_strFirstAired = firstAired.GetAsW3CDate();
+
     iUniqueBroadcastId = kodiTag->UniqueBroadcastID();
     iUniqueChannelId = kodiTag->UniqueChannelID();
     iParentalRating = kodiTag->ParentalRating();
@@ -674,6 +677,7 @@ class CAddonEpgTag : public EPG_TAG
     strIconPath = m_strIconPath.c_str();
     strSeriesLink = m_strSeriesLink.c_str();
     strGenreDescription = m_strGenreDescription.c_str();
+    strFirstAired = m_strFirstAired.c_str();
   }
 
   virtual ~CAddonEpgTag() = default;
@@ -691,6 +695,7 @@ class CAddonEpgTag : public EPG_TAG
   std::string m_strIconPath;
   std::string m_strSeriesLink;
   std::string m_strGenreDescription;
+  std::string m_strFirstAired;
 };
 
 PVR_ERROR CPVRClient::IsRecordable(const std::shared_ptr<const CPVREpgInfoTag>& tag, bool& bIsRecordable) const
diff --git a/xbmc/pvr/epg/EpgDatabase.cpp b/xbmc/pvr/epg/EpgDatabase.cpp
index 530d8305f8a6..5a46057964be 100644
--- a/xbmc/pvr/epg/EpgDatabase.cpp
+++ b/xbmc/pvr/epg/EpgDatabase.cpp
@@ -85,10 +85,9 @@ void CPVREpgDatabase::CreateTables()
         "iGenreType      integer, "
         "iGenreSubType   integer, "
         "sGenre          varchar(128), "
-        "iFirstAired     integer, "
+        "sFirstAired     varchar(32), "
         "iParentalRating integer, "
         "iStarRating     integer, "
-        "bNotify         bool, " // Unused. Could be removed, but beware: sqlite does not support 'ALTER TABLE x DROP COLUMN y'.
         "iSeriesId       integer, "
         "iEpisodeId      integer, "
         "iEpisodePart    integer, "
@@ -143,6 +142,122 @@ void CPVREpgDatabase::UpdateTables(int iVersion)
   {
     m_pDS->exec("ALTER TABLE epgtags ADD sSeriesLink varchar(255);");
   }
+
+  if (iVersion < 13)
+  {
+    const bool isMySQL = StringUtils::EqualsNoCase(
+        CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_databaseEpg.type, "mysql");
+
+    m_pDS->exec(
+        "CREATE TABLE epgtags_new ("
+        "idBroadcast     integer primary key, "
+        "iBroadcastUid   integer, "
+        "idEpg           integer, "
+        "sTitle          varchar(128), "
+        "sPlotOutline    text, "
+        "sPlot           text, "
+        "sOriginalTitle  varchar(128), "
+        "sCast           varchar(255), "
+        "sDirector       varchar(255), "
+        "sWriter         varchar(255), "
+        "iYear           integer, "
+        "sIMDBNumber     varchar(50), "
+        "sIconPath       varchar(255), "
+        "iStartTime      integer, "
+        "iEndTime        integer, "
+        "iGenreType      integer, "
+        "iGenreSubType   integer, "
+        "sGenre          varchar(128), "
+        "sFirstAired     varchar(32), "
+        "iParentalRating integer, "
+        "iStarRating     integer, "
+        "iSeriesId       integer, "
+        "iEpisodeId      integer, "
+        "iEpisodePart    integer, "
+        "sEpisodeName    varchar(128), "
+        "iFlags          integer, "
+        "sSeriesLink     varchar(255)"
+        ")"
+    );
+
+    m_pDS->exec(
+        "INSERT INTO epgtags_new ("
+        "idBroadcast, "
+        "iBroadcastUid, "
+        "idEpg, "
+        "sTitle, "
+        "sPlotOutline, "
+        "sPlot, "
+        "sOriginalTitle, "
+        "sCast, "
+        "sDirector, "
+        "sWriter, "
+        "iYear, "
+        "sIMDBNumber, "
+        "sIconPath, "
+        "iStartTime, "
+        "iEndTime, "
+        "iGenreType, "
+        "iGenreSubType, "
+        "sGenre, "
+        "sFirstAired, "
+        "iParentalRating, "
+        "iStarRating, "
+        "iSeriesId, "
+        "iEpisodeId, "
+        "iEpisodePart, "
+        "sEpisodeName, "
+        "iFlags, "
+        "sSeriesLink"
+        ") "
+        "SELECT "
+        "idBroadcast, "
+        "iBroadcastUid, "
+        "idEpg, "
+        "sTitle, "
+        "sPlotOutline, "
+        "sPlot, "
+        "sOriginalTitle, "
+        "sCast, "
+        "sDirector, "
+        "sWriter, "
+        "iYear, "
+        "sIMDBNumber, "
+        "sIconPath, "
+        "iStartTime, "
+        "iEndTime, "
+        "iGenreType, "
+        "iGenreSubType, "
+        "sGenre, "
+        "'' AS sFirstAired, "
+        "iParentalRating, "
+        "iStarRating, "
+        "iSeriesId, "
+        "iEpisodeId, "
+        "iEpisodePart, "
+        "sEpisodeName, "
+        "iFlags, "
+        "sSeriesLink "
+        "FROM epgtags"
+    );
+
+    if (isMySQL)
+      m_pDS->exec(
+        "UPDATE epgtags_new INNER JOIN epgtags ON epgtags_new.idBroadcast = epgtags.idBroadcast "
+        "SET epgtags_new.sFirstAired = DATE(FROM_UNIXTIME(epgtags.iFirstAired)) "
+        "WHERE epgtags.iFirstAired > 0"
+      );
+    else
+      m_pDS->exec(
+        "UPDATE epgtags_new SET sFirstAired = "
+        "COALESCE((SELECT STRFTIME('%Y-%m-%d', iFirstAired, 'UNIXEPOCH') "
+        "FROM epgtags WHERE epgtags.idBroadcast = epgtags_new.idBroadcast "
+        "AND epgtags.iFirstAired > 0), '')"
+      );
+
+    m_pDS->exec("DROP TABLE epgtags");
+    m_pDS->exec("ALTER TABLE epgtags_new RENAME TO epgtags");
+  }
 }
 
 bool CPVREpgDatabase::DeleteEpg()
@@ -234,12 +349,9 @@ std::shared_ptr<CPVREpgInfoTag> CPVREpgDatabase::CreateEpgTag(
     const CDateTime endTime(iEndTime);
     newTag->m_endTime = endTime;
 
-    time_t iFirstAired = static_cast<time_t>(m_pDS->fv("iFirstAired").get_asInt());
-    if (iFirstAired > 0)
-    {
-      const CDateTime firstAired(iFirstAired);
-      newTag->m_firstAired = firstAired;
-    }
+    const std::string sFirstAired = m_pDS->fv("sFirstAired").get_asString();
+    if (sFirstAired.length() > 0)
+      newTag->m_firstAired.SetFromW3CDate(sFirstAired);
 
     int iBroadcastUID = m_pDS->fv("iBroadcastUid").get_asInt();
     // Compat: null value for broadcast uid changed from numerical -1 to 0 with PVR Addon API v4.0.0
@@ -909,9 +1021,9 @@ int CPVREpgDatabase::Persist(const CPVREpgInfoTag& tag, bool bSingleUpdate /* =
   tag.StartAsUTC().GetAsTime(iStartTime);
   tag.EndAsUTC().GetAsTime(iEndTime);
 
-  time_t iFirstAired = 0;
-  if (tag.FirstAiredAsUTC().IsValid())
-    tag.FirstAiredAsUTC().GetAsTime(iFirstAired);
+  std::string sFirstAired;
+  if (tag.FirstAired().IsValid())
+    sFirstAired = tag.FirstAired().GetAsW3CDate();
 
   int iBroadcastId = tag.DatabaseID();
   std::string strQuery;
@@ -925,15 +1037,15 @@ int CPVREpgDatabase::Persist(const CPVREpgInfoTag& tag, bool bSingleUpdate /* =
   {
     strQuery = PrepareSQL("REPLACE INTO epgtags (idEpg, iStartTime, "
         "iEndTime, sTitle, sPlotOutline, sPlot, sOriginalTitle, sCast, sDirector, sWriter, iYear, sIMDBNumber, "
-        "sIconPath, iGenreType, iGenreSubType, sGenre, iFirstAired, iParentalRating, iStarRating, bNotify, iSeriesId, "
+        "sIconPath, iGenreType, iGenreSubType, sGenre, sFirstAired, iParentalRating, iStarRating, iSeriesId, "
         "iEpisodeId, iEpisodePart, sEpisodeName, iFlags, sSeriesLink, iBroadcastUid) "
-        "VALUES (%u, %u, %u, '%s', '%s', '%s', '%s', '%s', '%s', '%s', %i, '%s', '%s', %i, %i, '%s', %u, %i, %i, %i, %i, %i, %i, '%s', %i, '%s', %i);",
+        "VALUES (%u, %u, %u, '%s', '%s', '%s', '%s', '%s', '%s', '%s', %i, '%s', '%s', %i, %i, '%s', '%s', %i, %i, %i, %i, %i, '%s', %i, '%s', %i);",
         tag.EpgID(), static_cast<unsigned int>(iStartTime), static_cast<unsigned int>(iEndTime),
         tag.Title().c_str(), tag.PlotOutline().c_str(), tag.Plot().c_str(),
         tag.OriginalTitle().c_str(), tag.DeTokenize(tag.Cast()).c_str(), tag.DeTokenize(tag.Directors()).c_str(),
         tag.DeTokenize(tag.Writers()).c_str(), tag.Year(), tag.IMDBNumber().c_str(),
         tag.Icon().c_str(), tag.GenreType(), tag.GenreSubType(), strGenre.c_str(),
-        static_cast<unsigned int>(iFirstAired), tag.ParentalRating(), tag.StarRating(), false /* unused */,
+        sFirstAired.c_str(), tag.ParentalRating(), tag.StarRating(),
         tag.SeriesNumber(), tag.EpisodeNumber(), tag.EpisodePart(), tag.EpisodeName().c_str(), tag.Flags(), tag.SeriesLink().c_str(),
         tag.UniqueBroadcastID());
   }
@@ -941,15 +1053,15 @@ int CPVREpgDatabase::Persist(const CPVREpgInfoTag& tag, bool bSingleUpdate /* =
   {
     strQuery = PrepareSQL("REPLACE INTO epgtags (idEpg, iStartTime, "
         "iEndTime, sTitle, sPlotOutline, sPlot, sOriginalTitle, sCast, sDirector, sWriter, iYear, sIMDBNumber, "
-        "sIconPath, iGenreType, iGenreSubType, sGenre, iFirstAired, iParentalRating, iStarRating, bNotify, iSeriesId, "
+        "sIconPath, iGenreType, iGenreSubType, sGenre, sFirstAired, iParentalRating, iStarRating, iSeriesId, "
         "iEpisodeId, iEpisodePart, sEpisodeName, iFlags, sSeriesLink, iBroadcastUid, idBroadcast) "
-        "VALUES (%u, %u, %u, '%s', '%s', '%s', '%s', '%s', '%s', '%s', %i, '%s', '%s', %i, %i, '%s', %u, %i, %i, %i, %i, %i, %i, '%s', %i, '%s', %i, %i);",
+        "VALUES (%u, %u, %u, '%s', '%s', '%s', '%s', '%s', '%s', '%s', %i, '%s', '%s', %i, %i, '%s', '%s', %i, %i, %i, %i, %i, '%s', %i, '%s', %i, %i);",
         tag.EpgID(), static_cast<unsigned int>(iStartTime), static_cast<unsigned int>(iEndTime),
         tag.Title().c_str(), tag.PlotOutline().c_str(), tag.Plot().c_str(),
         tag.OriginalTitle().c_str(), tag.DeTokenize(tag.Cast()).c_str(), tag.DeTokenize(tag.Directors()).c_str(),
         tag.DeTokenize(tag.Writers()).c_str(), tag.Year(), tag.IMDBNumber().c_str(),
         tag.Icon().c_str(), tag.GenreType(), tag.GenreSubType(), strGenre.c_str(),
-        static_cast<unsigned int>(iFirstAired), tag.ParentalRating(), tag.StarRating(), false /* unused */,
+        sFirstAired.c_str(), tag.ParentalRating(), tag.StarRating(),
         tag.SeriesNumber(), tag.EpisodeNumber(), tag.EpisodePart(), tag.EpisodeName().c_str(), tag.Flags(), tag.SeriesLink().c_str(),
         tag.UniqueBroadcastID(), iBroadcastId);
   }
diff --git a/xbmc/pvr/epg/EpgDatabase.h b/xbmc/pvr/epg/EpgDatabase.h
index b76681394d1c..7f42d0f111e9 100644
--- a/xbmc/pvr/epg/EpgDatabase.h
+++ b/xbmc/pvr/epg/EpgDatabase.h
@@ -63,7 +63,7 @@ namespace PVR
      * @brief Get the minimal database version that is required to operate correctly.
      * @return The minimal database version.
      */
-    int GetSchemaVersion() const override { return 12; }
+    int GetSchemaVersion() const override { return 13; }
 
     /*!
      * @brief Get the default sqlite database filename.
diff --git a/xbmc/pvr/epg/EpgInfoTag.cpp b/xbmc/pvr/epg/EpgInfoTag.cpp
index e82798719080..d5d13677a8c4 100644
--- a/xbmc/pvr/epg/EpgInfoTag.cpp
+++ b/xbmc/pvr/epg/EpgInfoTag.cpp
@@ -72,9 +72,9 @@ CPVREpgInfoTag::CPVREpgInfoTag(const EPG_TAG& data, int iClientId, const std::sh
   m_iFlags(data.iFlags),
   m_iEpgID(iEpgID)
 {
-  // firstAired is optional, so check if supported before assigning it
-  if (data.firstAired > 0)
-    m_firstAired = time_t(data.firstAired + CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_iPVRTimeCorrection);
+  // strFirstAired is optional, so check if supported before assigning it
+  if (data.strFirstAired && strlen(data.strFirstAired) > 0)
+    m_firstAired.SetFromW3CDate(data.strFirstAired);
 
   if (channelData)
   {
@@ -419,18 +419,11 @@ const std::vector<std::string> CPVREpgInfoTag::Genre() const
   return m_genre;
 }
 
-CDateTime CPVREpgInfoTag::FirstAiredAsUTC() const
+CDateTime CPVREpgInfoTag::FirstAired() const
 {
   return m_firstAired;
 }
 
-CDateTime CPVREpgInfoTag::FirstAiredAsLocalTime() const
-{
-  CDateTime retVal;
-  retVal.SetFromUTCDateTime(m_firstAired);
-  return retVal;
-}
-
 int CPVREpgInfoTag::ParentalRating() const
 {
   return m_iParentalRating;
@@ -667,6 +660,11 @@ bool CPVREpgInfoTag::IsGapTag() const
   return m_bIsGapTag;
 }
 
+bool CPVREpgInfoTag::IsNew() const
+{
+  return (m_iFlags & EPG_TAG_FLAG_IS_NEW) > 0;
+}
+
 const std::vector<std::string> CPVREpgInfoTag::Tokenize(const std::string& str)
 {
   return StringUtils::Split(str.c_str(), EPG_STRING_TOKEN_SEPARATOR);
diff --git a/xbmc/pvr/epg/EpgInfoTag.h b/xbmc/pvr/epg/EpgInfoTag.h
index dd0abfb637ee..0cb0bda13704 100644
--- a/xbmc/pvr/epg/EpgInfoTag.h
+++ b/xbmc/pvr/epg/EpgInfoTag.h
@@ -271,15 +271,9 @@ namespace PVR
 
     /*!
      * @brief Get the first air date of this event.
-     * @return The first air date in UTC.
+     * @return The first air date.
      */
-    CDateTime FirstAiredAsUTC() const;
-
-    /*!
-     * @brief Get the first air date of this event.
-     * @return The first air date as local time.
-     */
-    CDateTime FirstAiredAsLocalTime() const;
+    CDateTime FirstAired() const;
 
     /*!
      * @brief Get the parental rating of this event.
@@ -393,6 +387,12 @@ namespace PVR
      */
     bool IsGapTag() const;
 
+    /*!
+     * @brief Check whether this tag will be flagged as new.
+     * @return True if this tag will be flagged as new, false otherwise
+     */
+    bool IsNew() const;
+
     /*!
      * @brief Return the flags (EPG_TAG_FLAG_*) of this event as a bitfield.
      * @return the flags.
diff --git a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.cpp b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.cpp
index f41a073ff7f5..6333bf8d80ae 100644
--- a/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.cpp
+++ b/xbmc/pvr/guilib/guiinfo/PVRGUIInfo.cpp
@@ -609,9 +609,14 @@ bool CPVRGUIInfo::GetListItemAndPlayerLabel(const CFileItem* item, const CGUIInf
         return false;
       case VIDEOPLAYER_PREMIERED:
       case LISTITEM_PREMIERED:
-        if (epgTag->FirstAiredAsLocalTime().IsValid())
+        if (epgTag->FirstAired().IsValid())
         {
-          strValue = epgTag->FirstAiredAsLocalTime().GetAsLocalizedDate(true);
+          strValue = epgTag->FirstAired().GetAsLocalizedDate(true);
+          return true;
+        }
+        else if (epgTag->Year() > 0)
+        {
+          strValue = StringUtils::Format("%i", epgTag->Year());
           return true;
         }
         return false;
@@ -1249,16 +1254,8 @@ bool CPVRGUIInfo::GetListItemAndPlayerBool(const CFileItem* item, const CGUIInfo
     case LISTITEM_IS_NEW:
       if (item->IsEPG())
       {
-        const std::shared_ptr<CPVREpgInfoTag> epgTag = item->GetEPGInfoTag();
-        const CDateTime firstAired = epgTag->FirstAiredAsUTC();
-        const CDateTime start = epgTag->StartAsUTC();
-        if (firstAired.IsValid() && start.IsValid())
-        {
-          bValue = firstAired.GetYear() == start.GetYear() &&
-                   firstAired.GetMonth() == start.GetMonth() &&
-                   firstAired.GetDay() == start.GetDay();
-          return true;
-        }
+        bValue = item->GetEPGInfoTag()->IsNew();
+        return true;
       }
       break;
     case MUSICPLAYER_CONTENT:
