From 792be7bfd45ba43508a5a21f42b3e515e0336b59 Mon Sep 17 00:00:00 2001
From: Alwin Esch <alwin.esch@web.de>
Date: Sun, 28 Apr 2019 22:00:59 +0200
Subject: [PATCH] [addons] Bring back audioengine addon interface (not ADSP)

This is a mandatory for Webbrowser addon system!

There are no changes on Audio Engine and from usage mostly equal to other
audioengine calls in Kodi.
---
 xbmc/addons/binary-addons/AddonDll.cpp        |   3 +
 xbmc/addons/interfaces/AudioEngine.cpp        | 382 ++++++++++++
 xbmc/addons/interfaces/AudioEngine.h          | 181 ++++++
 xbmc/addons/interfaces/CMakeLists.txt         |   2 +
 .../include/kodi/AudioEngine.h                | 586 ++++++++++++++++++
 .../include/kodi/CMakeLists.txt               |   1 +
 .../include/kodi/versions.h                   |   4 +-
 7 files changed, 1157 insertions(+), 2 deletions(-)
 create mode 100644 xbmc/addons/interfaces/AudioEngine.cpp
 create mode 100644 xbmc/addons/interfaces/AudioEngine.h
 create mode 100644 xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h

diff --git a/xbmc/addons/binary-addons/AddonDll.cpp b/xbmc/addons/binary-addons/AddonDll.cpp
index 2fb2c2cd843f..2dd19ccde4d9 100644
--- a/xbmc/addons/binary-addons/AddonDll.cpp
+++ b/xbmc/addons/binary-addons/AddonDll.cpp
@@ -28,6 +28,7 @@
 #include "Util.h"
 
 // Global addon callback handle classes
+#include "addons/interfaces/AudioEngine.h"
 #include "addons/interfaces/Filesystem.h"
 #include "addons/interfaces/General.h"
 #include "addons/interfaces/Network.h"
@@ -559,6 +560,7 @@ bool CAddonDll::InitInterface(KODI_HANDLE firstKodiInstance)
   m_interface.toAddon = (KodiToAddonFuncTable_Addon*) calloc(1, sizeof(KodiToAddonFuncTable_Addon));
 
   Interface_General::Init(&m_interface);
+  Interface_AudioEngine::Init(&m_interface);
   Interface_Filesystem::Init(&m_interface);
   Interface_Network::Init(&m_interface);
   Interface_GUIGeneral::Init(&m_interface);
@@ -573,6 +575,7 @@ void CAddonDll::DeInitInterface()
   Interface_GUIGeneral::DeInit(&m_interface);
   Interface_Network::DeInit(&m_interface);
   Interface_Filesystem::DeInit(&m_interface);
+  Interface_AudioEngine::DeInit(&m_interface);
   Interface_General::DeInit(&m_interface);
 
   if (m_interface.libBasePath)
diff --git a/xbmc/addons/interfaces/AudioEngine.cpp b/xbmc/addons/interfaces/AudioEngine.cpp
new file mode 100644
index 000000000000..99dbdbd4ad9c
--- /dev/null
+++ b/xbmc/addons/interfaces/AudioEngine.cpp
@@ -0,0 +1,382 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "AudioEngine.h"
+
+#include "ServiceBroker.h"
+#include "addons/kodi-addon-dev-kit/include/kodi/AddonBase.h"
+#include "cores/AudioEngine/Interfaces/AE.h"
+#include "cores/AudioEngine/Interfaces/AEStream.h"
+#include "cores/AudioEngine/Utils/AEChannelData.h"
+#include "cores/AudioEngine/Utils/AEStreamData.h"
+#include "utils/log.h"
+
+using namespace kodi; // addon-dev-kit namespace
+using namespace kodi::audioengine; // addon-dev-kit namespace
+
+namespace ADDON
+{
+
+void Interface_AudioEngine::Init(AddonGlobalInterface* addonInterface)
+{
+  addonInterface->toKodi->kodi_audioengine = static_cast<AddonToKodiFuncTable_kodi_audioengine*>(malloc(sizeof(AddonToKodiFuncTable_kodi_audioengine)));
+
+  // write KODI audio DSP specific add-on function addresses to callback table
+  addonInterface->toKodi->kodi_audioengine->make_stream = audioengine_make_stream;
+  addonInterface->toKodi->kodi_audioengine->free_stream = audioengine_free_stream;
+  addonInterface->toKodi->kodi_audioengine->get_current_sink_format = audioengine_get_current_sink_format;
+
+  // AEStream add-on function callback table
+  addonInterface->toKodi->kodi_audioengine->aestream_get_space = aestream_get_space;
+  addonInterface->toKodi->kodi_audioengine->aestream_add_data = aestream_add_data;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_delay = aestream_get_delay;
+  addonInterface->toKodi->kodi_audioengine->aestream_is_buffering = aestream_is_buffering;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_cache_time = aestream_get_cache_time;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_cache_total = aestream_get_cache_total;
+  addonInterface->toKodi->kodi_audioengine->aestream_pause = aestream_pause;
+  addonInterface->toKodi->kodi_audioengine->aestream_resume = aestream_resume;
+  addonInterface->toKodi->kodi_audioengine->aestream_drain = aestream_drain;
+  addonInterface->toKodi->kodi_audioengine->aestream_is_draining = aestream_is_draining;
+  addonInterface->toKodi->kodi_audioengine->aestream_is_drained = aestream_is_drained;
+  addonInterface->toKodi->kodi_audioengine->aestream_flush = aestream_flush;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_volume = aestream_get_volume;
+  addonInterface->toKodi->kodi_audioengine->aestream_set_volume = aestream_set_volume;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_amplification = aestream_get_amplification;
+  addonInterface->toKodi->kodi_audioengine->aestream_set_amplification = aestream_set_amplification;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_frame_size = aestream_get_frame_size;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_channel_count = aestream_get_channel_count;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_sample_rate = aestream_get_sample_rate;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_data_format = aestream_get_data_format;
+  addonInterface->toKodi->kodi_audioengine->aestream_get_resample_ratio = aestream_get_resample_ratio;
+  addonInterface->toKodi->kodi_audioengine->aestream_set_resample_ratio = aestream_set_resample_ratio;
+}
+
+void Interface_AudioEngine::DeInit(AddonGlobalInterface* addonInterface)
+{
+  if (addonInterface->toKodi) /* <-- Safe check, needed so long old addon way is present */
+  {
+    free(addonInterface->toKodi->kodi_audioengine);
+    addonInterface->toKodi->kodi_audioengine = nullptr;
+  }
+}
+
+AEStreamHandle* Interface_AudioEngine::audioengine_make_stream(void* kodiBase, AudioEngineFormat* streamFormat, unsigned int options)
+{
+  if (!kodiBase || !streamFormat)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamFormat='%p')",
+              __FUNCTION__, kodiBase, static_cast<void*>(streamFormat));
+    return nullptr;
+  }
+
+  AEAudioFormat format;
+  format.m_dataFormat = streamFormat->m_dataFormat;
+  format.m_sampleRate = streamFormat->m_sampleRate;
+  format.m_channelLayout = streamFormat->m_channels;
+
+  /* Translate addon options to kodi's options */
+  int kodiOption = 0;
+  if (options & AUDIO_STREAM_FORCE_RESAMPLE)
+    kodiOption |= AESTREAM_FORCE_RESAMPLE;
+  if (options & AUDIO_STREAM_PAUSED)
+    kodiOption |= AESTREAM_PAUSED;
+  if (options & AUDIO_STREAM_AUTOSTART)
+    kodiOption |= AESTREAM_AUTOSTART;
+
+  return CServiceBroker::GetActiveAE()->MakeStream(format, kodiOption);
+}
+
+void Interface_AudioEngine::audioengine_free_stream(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  CServiceBroker::GetActiveAE()->FreeStream(static_cast<IAEStream*>(streamHandle), true);
+}
+
+bool Interface_AudioEngine::audioengine_get_current_sink_format(void* kodiBase, AudioEngineFormat *format)
+{
+  if (!kodiBase || !format)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', format='%p')", __FUNCTION__, kodiBase, static_cast<void*>(format));
+    return false;
+  }
+
+  AEAudioFormat sinkFormat;
+  if (!CServiceBroker::GetActiveAE()->GetCurrentSinkFormat(sinkFormat))
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - failed to get current sink format from AE!", __FUNCTION__);
+    return false;
+  }
+
+  format->m_channelCount = sinkFormat.m_channelLayout.Count();
+  for (unsigned int ch = 0; ch < format->m_channelCount; ++ch)
+  {
+    format->m_channels[ch] = sinkFormat.m_channelLayout[ch];
+  }
+
+  format->m_dataFormat = sinkFormat.m_dataFormat;
+  format->m_sampleRate = sinkFormat.m_sampleRate;
+  format->m_frames = sinkFormat.m_frames;
+  format->m_frameSize = sinkFormat.m_frameSize;
+
+  return true;
+}
+
+unsigned int Interface_AudioEngine::aestream_get_space(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return 0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetSpace();
+}
+
+unsigned int Interface_AudioEngine::aestream_add_data(void* kodiBase, AEStreamHandle* streamHandle, uint8_t* const *data,
+                                                      unsigned int offset, unsigned int frames, double pts, bool hasDownmix,
+                                                      double centerMixLevel)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return 0;
+  }
+
+  IAEStream::ExtData extData;
+  extData.pts = pts;
+  extData.hasDownmix = hasDownmix;
+  extData.centerMixLevel = centerMixLevel;
+  return static_cast<IAEStream*>(streamHandle)->AddData(data, offset, frames, &extData);
+}
+
+double Interface_AudioEngine::aestream_get_delay(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetDelay();
+}
+
+bool Interface_AudioEngine::aestream_is_buffering(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return false;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->IsBuffering();
+}
+
+double Interface_AudioEngine::aestream_get_cache_time(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetCacheTime();
+}
+
+double Interface_AudioEngine::aestream_get_cache_total(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetCacheTotal();
+}
+
+void Interface_AudioEngine::aestream_pause(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->Pause();
+}
+
+void Interface_AudioEngine::aestream_resume(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->Resume();
+}
+
+void Interface_AudioEngine::aestream_drain(void* kodiBase, AEStreamHandle* streamHandle, bool wait)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->Drain(wait);
+}
+
+bool Interface_AudioEngine::aestream_is_draining(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return false;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->IsDraining();
+}
+
+bool Interface_AudioEngine::aestream_is_drained(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return false;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->IsDrained();
+}
+
+void Interface_AudioEngine::aestream_flush(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->Flush();
+}
+
+float Interface_AudioEngine::aestream_get_volume(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0f;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetVolume();
+}
+
+void  Interface_AudioEngine::aestream_set_volume(void* kodiBase, AEStreamHandle* streamHandle, float volume)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->SetVolume(volume);
+}
+
+float Interface_AudioEngine::aestream_get_amplification(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0f;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetAmplification();
+}
+
+void Interface_AudioEngine::aestream_set_amplification(void* kodiBase, AEStreamHandle* streamHandle, float amplify)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->SetAmplification(amplify);
+}
+
+unsigned int Interface_AudioEngine::aestream_get_frame_size(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return 0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetFrameSize();
+}
+
+unsigned int Interface_AudioEngine::aestream_get_channel_count(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return 0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetChannelCount();
+}
+
+unsigned int Interface_AudioEngine::aestream_get_sample_rate(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return 0;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetSampleRate();
+}
+
+AEDataFormat Interface_AudioEngine::aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return AE_FMT_INVALID;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetDataFormat();
+}
+
+double Interface_AudioEngine::aestream_get_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return -1.0f;
+  }
+
+  return static_cast<IAEStream*>(streamHandle)->GetResampleRatio();
+}
+
+void Interface_AudioEngine::aestream_set_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle, double ratio)
+{
+  if (!kodiBase || !streamHandle)
+  {
+    CLog::Log(LOGERROR, "Interface_AudioEngine::{} - invalid stream data (kodiBase='%p', streamHandle='%p')", __FUNCTION__, kodiBase, streamHandle);
+    return;
+  }
+
+  static_cast<IAEStream*>(streamHandle)->SetResampleRatio(ratio);
+}
+
+} /* namespace ADDON */
diff --git a/xbmc/addons/interfaces/AudioEngine.h b/xbmc/addons/interfaces/AudioEngine.h
new file mode 100644
index 000000000000..434cda6208f0
--- /dev/null
+++ b/xbmc/addons/interfaces/AudioEngine.h
@@ -0,0 +1,181 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h"
+
+namespace ADDON
+{
+
+struct Interface_AudioEngine
+{
+  static void Init(AddonGlobalInterface* addonInterface);
+  static void DeInit(AddonGlobalInterface* addonInterface);
+
+  /**
+  * Creates and returns a new handle to an IAEStream in the format specified, this function should never fail
+  * @param[in] streamFormat Format to use for stream
+  * @param[in] options A bit field of stream options (see: enum AEStreamOptions)
+  * @return a new Handle to an IAEStream that will accept data in the requested format
+  */
+  static AEStreamHandle* audioengine_make_stream(void *kodiBase, AudioEngineFormat* streamFormat, unsigned int options);
+
+  /**
+  * This method will remove the specifyed stream from the engine.
+  * For OSX/IOS this is essential to reconfigure the audio output.
+  * @param[in] streamHandle The stream to be altered
+  */
+  static void audioengine_free_stream(void *kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Get the current sink data format
+  *
+  * @param[in] sinkFormat sink data format. For more details see AudioEngineFormat.
+  * @return Returns true on success, else false.
+  */
+  static bool audioengine_get_current_sink_format(void* kodiBase, AudioEngineFormat *sinkFormat);
+
+  /**
+  * Returns the amount of space available in the stream
+  * @return The number of bytes AddData will consume
+  */
+  static unsigned int aestream_get_space(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Add planar or interleaved PCM data to the stream
+  * @param[in] data array of pointers to the planes
+  * @param[in] offset to frame in frames
+  * @param[in] frames number of frames
+  * @return The number of frames consumed
+  */
+  static unsigned int aestream_add_data(void* kodiBase, AEStreamHandle* streamHandle, uint8_t* const *data,
+                                        unsigned int offset, unsigned int frames,  double pts, bool hasDownmix,
+                                        double centerMixLevel);
+
+  /**
+  * Returns the time in seconds that it will take
+  * for the next added packet to be heard from the speakers.
+  * @return seconds
+  */
+  static double aestream_get_delay(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns if the stream is buffering
+  * @return True if the stream is buffering
+  */
+  static bool aestream_is_buffering(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns the time in seconds that it will take
+  * to underrun the cache if no sample is added.
+  * @return seconds
+  */
+  static double aestream_get_cache_time(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns the total time in seconds of the cache
+  * @return seconds
+  */
+  static double aestream_get_cache_total(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Pauses the stream playback
+  */
+  static void aestream_pause(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Resumes the stream after pausing
+  */
+  static void aestream_resume(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Start draining the stream
+  * @note Once called AddData will not consume more data.
+  */
+  static void aestream_drain(void* kodiBase, AEStreamHandle* streamHandle, bool wait);
+
+  /**
+  * Returns true if the is stream draining
+  */
+  static bool aestream_is_draining(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns true if the is stream has finished draining
+  */
+  static bool aestream_is_drained(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Flush all buffers dropping the audio data
+  */
+  static void aestream_flush(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Return the stream's current volume level
+  * @return The volume level between 0.0 and 1.0
+  */
+  static float aestream_get_volume(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Set the stream's volume level
+  * @param volume The new volume level between 0.0 and 1.0
+  */
+  static void  aestream_set_volume(void* kodiBase, AEStreamHandle* streamHandle, float volume);
+
+  /**
+  * Gets the stream's volume amplification in linear units.
+  * @return The volume amplification factor between 1.0 and 1000.0
+  */
+  static float aestream_get_amplification(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Sets the stream's volume amplification in linear units.
+  * @param amplify The volume amplification factor between 1.0 and 1000.0
+  */
+  static void aestream_set_amplification(void* kodiBase, AEStreamHandle* streamHandle, float amplify);
+
+  /**
+  * Returns the size of one audio frame in bytes (channelCount * resolution)
+  * @return The size in bytes of one frame
+  */
+  static unsigned int aestream_get_frame_size(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns the number of channels the stream is configured to accept
+  * @return The channel count
+  */
+  static unsigned int aestream_get_channel_count(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Returns the stream's sample rate, if the stream is using a dynamic sample rate, this value will NOT reflect any changes made by calls to SetResampleRatio()
+  * @return The stream's sample rate (eg, 48000)
+  */
+  static unsigned int aestream_get_sample_rate(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Return the data format the stream has been configured with
+  * @return The stream's data format (eg, AE_FMT_S16LE)
+  */
+  static AEDataFormat aestream_get_data_format(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Return the resample ratio
+  * @note This will return an undefined value if the stream is not resampling
+  * @return the current resample ratio or undefined if the stream is not resampling
+  */
+  static double aestream_get_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle);
+
+  /**
+  * Sets the resample ratio
+  * @note This function may return false if the stream is not resampling, if you wish to use this be sure to set the AESTREAM_FORCE_RESAMPLE option
+  * @param[in] ratio the new sample rate ratio, calculated by ((double)desiredRate / (double)GetSampleRate())
+  */
+  static void aestream_set_resample_ratio(void* kodiBase, AEStreamHandle* streamHandle, double ratio);
+};
+
+} /* namespace ADDON */
diff --git a/xbmc/addons/interfaces/CMakeLists.txt b/xbmc/addons/interfaces/CMakeLists.txt
index a064cf2d5da6..cd2f330a9781 100644
--- a/xbmc/addons/interfaces/CMakeLists.txt
+++ b/xbmc/addons/interfaces/CMakeLists.txt
@@ -1,9 +1,11 @@
 set(SOURCES AddonInterfaces.cpp
+            AudioEngine.cpp
             General.cpp
             Filesystem.cpp
             Network.cpp)
 
 set(HEADERS AddonInterfaces.h
+            AudioEngine.h
             General.h
             Filesystem.h
             Network.h)
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
new file mode 100644
index 000000000000..051d4955d6c0
--- /dev/null
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/AudioEngine.h
@@ -0,0 +1,586 @@
+/*
+ *  Copyright (C) 2005-2019 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "AddonBase.h"
+
+#ifdef BUILD_KODI_ADDON
+#include "AEChannelData.h"
+#else
+#include "cores/AudioEngine/Utils/AEChannelData.h"
+#endif
+
+//==============================================================================
+///
+/// \defgroup cpp_kodi_audioengine  Interface - kodi::audioengine
+/// \ingroup cpp
+/// @brief **Audio engine functions**
+///
+///
+/// It has the header \ref AudioEngine.h "#include <kodi/AudioEngine.h>" be included
+/// to enjoy it.
+///
+//------------------------------------------------------------------------------
+
+//==============================================================================
+///
+/// \defgroup cpp_kodi_audioengine_Defs Definitions, structures and enumerators
+/// \ingroup cpp_kodi_audioengine
+/// @brief **Library definition values**
+///
+//------------------------------------------------------------------------------
+
+extern "C"
+{
+
+//============================================================================
+/// \ingroup cpp_kodi_audioengine_Defs
+/// @brief Bit options to pass to CAddonAEStream
+///
+typedef enum AudioEngineStreamOptions
+{
+  /// force resample even if rates match
+  AUDIO_STREAM_FORCE_RESAMPLE = 1 << 0,
+  /// create the stream paused
+  AUDIO_STREAM_PAUSED         = 1 << 1,
+  /// autostart the stream when enough data is buffered
+  AUDIO_STREAM_AUTOSTART      = 1 << 2,
+} AudioEngineStreamOptions;
+//----------------------------------------------------------------------------
+
+//============================================================================
+/// \defgroup cpp_kodi_audioengine_Defs_AudioEngineFormat struct AudioEngineFormat
+/// \ingroup cpp_kodi_audioengine_Defs
+/// @brief The audio format structure that fully defines a stream's audio
+/// information
+///
+//@{
+struct AudioEngineFormat
+{
+  /// The stream's data format (eg, AE_FMT_S16LE)
+  enum AEDataFormat m_dataFormat;
+
+  /// The stream's sample rate (eg, 48000)
+  unsigned int m_sampleRate;
+
+  /// The encoded streams sample rate if a bitstream, otherwise undefined
+  unsigned int m_encodedRate;
+
+  /// The amount of used speaker channels
+  unsigned int m_channelCount;
+
+  /// The stream's channel layout
+  enum AEChannel m_channels[AE_CH_MAX];
+
+  /// The number of frames per period
+  unsigned int m_frames;
+
+  /// The size of one frame in bytes
+  unsigned int m_frameSize;
+
+  AudioEngineFormat()
+  {
+    m_dataFormat = AE_FMT_INVALID;
+    m_sampleRate = 0;
+    m_encodedRate = 0;
+    m_frames = 0;
+    m_frameSize = 0;
+    m_channelCount = 0;
+
+    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
+    {
+      m_channels[ch] = AE_CH_MAX;
+    }
+  }
+
+  /// Function to compare the format structure with another
+  bool compareFormat(const AudioEngineFormat *fmt)
+  {
+    if (!fmt)
+    {
+      return false;
+    }
+
+    if (m_dataFormat    != fmt->m_dataFormat    ||
+        m_sampleRate    != fmt->m_sampleRate    ||
+        m_encodedRate   != fmt->m_encodedRate   ||
+        m_frames        != fmt->m_frames        ||
+        m_frameSize     != fmt->m_frameSize     ||
+        m_channelCount  != fmt->m_channelCount)
+    {
+      return false;
+    }
+
+    for (unsigned int ch = 0; ch < AE_CH_MAX; ++ch)
+    {
+      if (fmt->m_channels[ch] != m_channels[ch])
+      {
+        return false;
+      }
+    }
+
+    return true;
+  }
+};
+//@}
+//----------------------------------------------------------------------------
+
+/* A stream handle pointer, which is only used internally by the addon stream handle */
+typedef void AEStreamHandle;
+
+/*
+  * Function address structure, not need to visible on dev kit doxygen
+  * documentation
+  */
+typedef struct AddonToKodiFuncTable_kodi_audioengine
+{
+  AEStreamHandle* (*make_stream)(void *kodiBase, AudioEngineFormat* format, unsigned int options);
+  void (*free_stream)(void *kodiBase, AEStreamHandle *stream);
+  bool (*get_current_sink_format)(void *kodiBase, AudioEngineFormat* sink_format);
+
+  // Audio Engine Stream definitions
+  unsigned int (*aestream_get_space)(void *kodiBase, AEStreamHandle *handle);
+  unsigned int (*aestream_add_data)(void *kodiBase, AEStreamHandle *handle, uint8_t* const *data,
+                                    unsigned int offset, unsigned int frames, double pts, bool hasDownmix,
+                                    double centerMixLevel);
+  double (*aestream_get_delay)(void *kodiBase, AEStreamHandle *handle);
+  bool (*aestream_is_buffering)(void *kodiBase, AEStreamHandle *handle);
+  double (*aestream_get_cache_time)(void *kodiBase, AEStreamHandle *handle);
+  double (*aestream_get_cache_total)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_pause)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_resume)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_drain)(void *kodiBase, AEStreamHandle *handle, bool wait);
+  bool (*aestream_is_draining)(void *kodiBase, AEStreamHandle *handle);
+  bool (*aestream_is_drained)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_flush)(void *kodiBase, AEStreamHandle *handle);
+  float (*aestream_get_volume)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_set_volume)(void *kodiBase, AEStreamHandle *handle, float volume);
+  float (*aestream_get_amplification)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_set_amplification)(void *kodiBase, AEStreamHandle *handle, float amplify);
+  unsigned int (*aestream_get_frame_size)(void *kodiBase, AEStreamHandle *handle);
+  unsigned int (*aestream_get_channel_count)(void *kodiBase, AEStreamHandle *handle);
+  unsigned int (*aestream_get_sample_rate)(void *kodiBase, AEStreamHandle *handle);
+  AEDataFormat (*aestream_get_data_format)(void *kodiBase, AEStreamHandle *handle);
+  double (*aestream_get_resample_ratio)(void *kodiBase, AEStreamHandle *handle);
+  void (*aestream_set_resample_ratio)(void *kodiBase, AEStreamHandle *handle, double ratio);
+} AddonToKodiFuncTable_kodi_audioengine;
+
+} /* extern "C" */
+
+namespace kodi
+{
+namespace audioengine
+{
+
+//============================================================================
+///
+/// \defgroup cpp_kodi_audioengine_CAddonAEStream class CAddonAEStream
+/// \ingroup cpp_kodi_audioengine
+/// @brief **Audio Engine Stream Class**
+///
+///
+/// It has the header \ref AudioEngine.h "#include <kodi/AudioEngine.h>" be
+/// included to enjoy it.
+///
+//----------------------------------------------------------------------------
+class CAddonAEStream
+{
+public:
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Contructs new class to an Kodi IAEStream in the format specified.
+  ///
+  /// @param[in] format       The data format the incoming audio will be in
+  ///                         (e.g. \ref AE_FMT_S16LE)
+  /// @param[in] options      [opt] A bit field of stream options (see: enum \ref AudioEngineStreamOptions)
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Audio engine format information:**
+  /// @code
+  /// /*
+  ///  * Audio engine format information
+  ///  *
+  ///  * Only as example shown here! See always the original structure on related header.
+  ///  */
+  /// typedef struct AudioEngineFormat
+  /// {
+  ///   enum AEDataFormat    m_dataFormat;             /* The stream's data format (eg, AE_FMT_S16LE) */
+  ///   unsigned int         m_sampleRate;             /* The stream's sample rate (eg, 48000) */
+  ///   unsigned int         m_encodedRate;            /* The encoded streams sample rate if a bitstream, otherwise undefined */
+  ///   unsigned int         m_channelCount;           /* The amount of used speaker channels */
+  ///   enum AEChannel       m_channels[AE_CH_MAX];    /* The stream's channel layout */
+  ///   unsigned int         m_frames;                 /* The number of frames per period */
+  ///   unsigned int         m_frameSamples;           /* The number of samples in one frame */
+  ///   unsigned int         m_frameSize;              /* The size of one frame in bytes */
+  ///
+  ///   /* Function to compare the format structure with another */
+  ///   bool compareFormat(const AudioEngineFormat *fmt);
+  /// } AudioEngineFormat;
+  /// @endcode
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Bit options to pass to CAELib_Stream (on Kodi by <c>IAE::MakeStream</c>)**
+  ///
+  /// | enum AEStreamOptions        | Value: | Description:
+  /// |----------------------------:|:------:|:-----------------------------------
+  /// | AUDIO_STREAM_FORCE_RESAMPLE | 1 << 0 | Force resample even if rates match
+  /// | AUDIO_STREAM_PAUSED         | 1 << 1 | Create the stream paused
+  /// | AUDIO_STREAM_AUTOSTART      | 1 << 2 | Autostart the stream when enough data is buffered
+  ///
+  ///
+  /// ------------------------------------------------------------------------
+  ///
+  /// **Example:**
+  /// ~~~~~~~~~~~~~{.cpp}
+  ///
+  /// #include <kodi/AudioEngine.h>
+  ///
+  /// using namespace kodi::audioengine;
+  ///
+  /// ...
+  ///
+  /// AudioEngineFormat format;
+  /// format.m_dataFormat = AE_FMT_FLOAT;
+  /// format.m_channelCount = 2;
+  /// format.m_channels[0] = AE_CH_FL;
+  /// format.m_channels[1] = AE_CH_FR;
+  /// format.m_channels[2] = AE_CH_NULL;
+  /// format.m_sampleRate = 48000;
+  /// format.m_frameSize = sizeof(float)*format.m_channelCount;
+  /// format.m_frames = 512;
+  /// CAddonAEStream* stream = new CAddonAEStream(format, AE_STREAM_AUTOSTART);
+  ///
+  /// ~~~~~~~~~~~~~
+  ///
+  CAddonAEStream(AudioEngineFormat format, unsigned int options = 0)
+    : m_kodiBase(::kodi::addon::CAddonBase::m_interface->toKodi->kodiBase),
+      m_cb(::kodi::addon::CAddonBase::m_interface->toKodi->kodi_audioengine)
+  {
+    m_StreamHandle = m_cb->make_stream(m_kodiBase, &format, options);
+    if (m_StreamHandle == nullptr)
+    {
+      kodi::Log(ADDON_LOG_FATAL, "CAddonAEStream: make_stream failed!");
+    }
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Class destructor
+  ///
+  ~CAddonAEStream()
+  {
+    if (m_StreamHandle)
+    {
+      m_cb->free_stream(m_kodiBase, m_StreamHandle);
+      m_StreamHandle = nullptr;
+    }
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the amount of space available in the stream
+  ///
+  /// @return                 The number of bytes AddData will consume
+  ///
+  unsigned int GetSpace()
+  {
+    return m_cb->aestream_get_space(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Add planar or interleaved PCM data to the stream
+  ///
+  /// @param[in] data           array of pointers to the planes
+  /// @param[in] offset         to frame in frames
+  /// @param[in] frames         number of frames
+  /// @param[in] pts            [opt] presentation timestamp, default is 0
+  /// @param[in] hasDownmix     [opt] set true if downmix is present, default is false
+  /// @param[in] centerMixLevel [opt] level to mix left and right to center default is 1.0
+  /// @return                   The number of frames consumed
+  ///
+  unsigned int AddData(uint8_t* const *data, unsigned int offset, unsigned int frames,
+                        double pts = 0, bool hasDownmix = false, double centerMixLevel = 1.0)
+  {
+    return m_cb->aestream_add_data(m_kodiBase, m_StreamHandle, data, offset, frames, pts, hasDownmix, centerMixLevel);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the time in seconds that it will take for the next added
+  /// packet to be heard from the speakers.
+  ///
+  /// @return seconds
+  ///
+  double GetDelay()
+  {
+    return m_cb->aestream_get_delay(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns if the stream is buffering
+  ///
+  /// @return True if the stream is buffering
+  ///
+  bool IsBuffering()
+  {
+    return m_cb->aestream_is_buffering(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the time in seconds of the stream's cached audio samples.
+  /// Engine buffers excluded.
+  ///
+  /// @return seconds
+  ///
+  double GetCacheTime()
+  {
+    return m_cb->aestream_get_cache_time(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the total time in seconds of the cache
+  ///
+  /// @return seconds
+  ///
+  double GetCacheTotal()
+  {
+    return m_cb->aestream_get_cache_total(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Pauses the stream playback
+  ///
+  void Pause()
+  {
+    return m_cb->aestream_pause(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Resumes the stream after pausing
+  ///
+  void Resume()
+  {
+    return m_cb->aestream_resume(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Start draining the stream
+  ///
+  /// @param[in] wait         [opt] Wait until drain is finished if set to
+  ///                         true, otherwise it returns direct
+  ///
+  /// @note Once called AddData will not consume more data.
+  ///
+  void Drain(bool wait = true)
+  {
+    return m_cb->aestream_drain(m_kodiBase, m_StreamHandle, wait);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns true if the is stream draining
+  ///
+  bool IsDraining()
+  {
+    return m_cb->aestream_is_draining(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns true if the is stream has finished draining
+  ///
+  bool IsDrained()
+  {
+    return m_cb->aestream_is_drained(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Flush all buffers dropping the audio data
+  ///
+  void Flush()
+  {
+    return m_cb->aestream_flush(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Return the stream's current volume level
+  ///
+  /// @return The volume level between 0.0 and 1.0
+  ///
+  float GetVolume()
+  {
+    return m_cb->aestream_get_volume(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Set the stream's volume level
+  ///
+  /// @param[in] volume               The new volume level between 0.0 and 1.0
+  ///
+  void SetVolume(float volume)
+  {
+    return m_cb->aestream_set_volume(m_kodiBase, m_StreamHandle, volume);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Gets the stream's volume amplification in linear units.
+  ///
+  /// @return The volume amplification factor between 1.0 and 1000.0
+  ///
+  float GetAmplification()
+  {
+    return m_cb->aestream_get_amplification(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Sets the stream's volume amplification in linear units.
+  ///
+  /// @param[in] amplify              The volume amplification factor between
+  ///                                 1.0 and 1000.0
+  ///
+  void SetAmplification(float amplify)
+  {
+    return m_cb->aestream_set_amplification(m_kodiBase, m_StreamHandle, amplify);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the size of one audio frame in bytes (channelCount * resolution)
+  ///
+  /// @return The size in bytes of one frame
+  ///
+  unsigned int GetFrameSize() const
+  {
+    return m_cb->aestream_get_frame_size(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the number of channels the stream is configured to accept
+  ///
+  /// @return The channel count
+  ///
+  unsigned int GetChannelCount() const
+  {
+    return m_cb->aestream_get_channel_count(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Returns the stream's sample rate, if the stream is using a dynamic
+  /// sample rate, this value will NOT reflect any changes made by calls to
+  /// SetResampleRatio()
+  ///
+  /// @return The stream's sample rate (eg, 48000)
+  ///
+  unsigned int GetSampleRate() const
+  {
+    return m_cb->aestream_get_sample_rate(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Return the data format the stream has been configured with
+  ///
+  /// @return The stream's data format (eg, AUDIOENGINE_FMT_S16LE)
+  ///
+  AEDataFormat GetDataFormat() const
+  {
+    return m_cb->aestream_get_data_format(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Return the resample ratio
+  ///
+  /// @note This will return an undefined value if the stream is not resampling
+  ///
+  /// @return the current resample ratio or undefined if the stream is not resampling
+  ///
+  double GetResampleRatio()
+  {
+    return m_cb->aestream_get_resample_ratio(m_kodiBase, m_StreamHandle);
+  }
+  //--------------------------------------------------------------------------
+
+  //==========================================================================
+  /// @ingroup cpp_kodi_audioengine_CAddonAEStream
+  /// @brief Sets the resample ratio
+  ///
+  /// @note This function may return false if the stream is not resampling, if
+  /// you wish to use this be sure to set the AESTREAM_FORCE_RESAMPLE option
+  ///
+  /// @param[in] ratio         the new sample rate ratio, calculated by
+  ///                          ((double)desiredRate / (double)GetSampleRate())
+  ///
+  void SetResampleRatio(double ratio)
+  {
+    m_cb->aestream_set_resample_ratio(m_kodiBase, m_StreamHandle, ratio);
+  }
+  //--------------------------------------------------------------------------
+
+private:
+  void* m_kodiBase;
+  AddonToKodiFuncTable_kodi_audioengine* m_cb;
+  AEStreamHandle  *m_StreamHandle;
+};
+
+//============================================================================
+/// @ingroup cpp_kodi_audioengine
+/// @brief Get the current sink data format
+///
+/// @param[in] format Current sink data format. For more details see AudioEngineFormat.
+/// @return Returns true on success, else false.
+///
+inline bool GetCurrentSinkFormat(AudioEngineFormat &format)
+{
+  using namespace kodi::addon;
+  return CAddonBase::m_interface->toKodi->kodi_audioengine->get_current_sink_format(CAddonBase::m_interface->toKodi->kodiBase, &format);
+}
+//----------------------------------------------------------------------------
+
+} /* audioengine */
+} /* kodi */
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
index 2b981549668b..6d644dbb3e67 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/CMakeLists.txt
@@ -1,4 +1,5 @@
 set(HEADERS AddonBase.h
+            AudioEngine.h
             Filesystem.h
             General.h
             Network.h
diff --git a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
index a9f17986c30b..4ba563f68ca9 100644
--- a/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
+++ b/xbmc/addons/kodi-addon-dev-kit/include/kodi/versions.h
@@ -50,8 +50,8 @@
 #define ADDON_GLOBAL_VERSION_GUI_DEPENDS              "libKODI_guilib.h" \
                                                       "gui/"
 
-#define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.0.1"
-#define ADDON_GLOBAL_VERSION_AUDIOENGINE_MIN          "1.0.1"
+#define ADDON_GLOBAL_VERSION_AUDIOENGINE              "1.0.2"
+#define ADDON_GLOBAL_VERSION_AUDIOENGINE_MIN          "1.0.2"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_XML_ID       "kodi.binary.global.audioengine"
 #define ADDON_GLOBAL_VERSION_AUDIOENGINE_DEPENDS      "AudioEngine.h"
 
